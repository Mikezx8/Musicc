<!DOCTYPE html>
<html lang="en">
<style>
/* ========================================
   SOUNDWAVE - Music Streaming App
   Pure CSS - Black & White Theme
   ======================================== */

/* CSS Reset & Variables */
*, *::before, *::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --bg-primary: #000000;
    --bg-secondary: #0a0a0a;
    --bg-card: #111111;
    --bg-hover: #1a1a1a;
    --bg-tertiary: #181818;
    --text-primary: #ffffff;
    --text-secondary: #a0a0a0;
    --text-muted: #666666;
    --border-color: #222222;
    --accent: #ffffff;
    --success: #22c55e;
    --warning: #f59e0b;
    --error: #ef4444;
}

html, body {
    height: 100%;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 0.05em;
    font-weight: 400;
}

/* ========================================
   LAYOUT
   ======================================== */
.app-container {
    display: flex;
    min-height: 100vh;
    background-color: var(--bg-primary);
}

/* ========================================
   SIDEBAR
   ======================================== */
.sidebar {
    width: 256px;
    height: 100vh;
    background-color: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    position: fixed;
    left: 0;
    top: 0;
}

.sidebar-logo {
    padding: 24px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.sidebar-logo svg {
    width: 32px;
    height: 32px;
}

.sidebar-logo span {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 24px;
    letter-spacing: 0.1em;
}

.sidebar-nav {
    padding: 0 12px;
}

.nav-item {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 12px;
    background: none;
    border: none;
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
}

.nav-item:hover {
    color: var(--text-primary);
}

.nav-item.active {
    background-color: var(--bg-hover);
    color: var(--text-primary);
}

.nav-item svg {
    width: 20px;
    height: 20px;
}

.sidebar-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 16px 24px;
}

.playlist-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    margin-bottom: 8px;
}

.playlist-header span {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
}

.playlist-header button {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    transition: color 0.2s;
}

.playlist-header button:hover {
    color: var(--text-primary);
}

.liked-songs-btn {
    width: calc(100% - 24px);
    margin: 0 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
    background: none;
    border: none;
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: color 0.2s;
    text-align: left;
}

.liked-songs-btn:hover {
    color: var(--text-primary);
}

.liked-songs-icon {
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, #333 0%, #1a1a1a 100%);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.liked-songs-icon svg {
    width: 16px;
    height: 16px;
}

.liked-count {
    margin-left: auto;
    font-size: 12px;
    color: var(--text-muted);
}

.playlist-list {
    padding: 8px 12px;
    overflow-y: auto;
    flex: 1;
}

/* Enhanced Discover Cards */
.discover-track-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 16px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.discover-track-card:hover {
    border-color: var(--accent-color);
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
}

.discover-track-cover {
    width: 100%;
    aspect-ratio: 1;
    margin-bottom: 12px;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    cursor: pointer;
}

.cover-image-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
}

.cover-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.placeholder-icon {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    color: var(--text-muted);
}

.cover-badge {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    color: white;
}

.spotify-badge {
    background: #1DB954;
}

.youtube-badge {
    background: #FF0000;
}

.cover-play-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.discover-track-cover:hover .cover-play-overlay {
    opacity: 1;
}

.cover-play-overlay svg {
    width: 48px;
    height: 48px;
    fill: white;
}

.discover-track-info {
    margin-bottom: 12px;
}

.track-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-artist {
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-album {
    font-size: 12px;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.discover-track-actions {
    display: flex;
    gap: 8px;
}

.btn-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 1px solid var(--border-color);
    background: var(--bg-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.btn-icon:hover {
    background: var(--bg-hover);
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.btn-icon svg {
    width: 16px;
    height: 16px;
}

.download-btn {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
}

.download-btn:hover {
    background: var(--success-hover);
}

.like-btn:hover {
    background: var(--error-color);
    border-color: var(--error-color);
    color: white;
}

/* Playlist Cards */
.playlist-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 16px;
    transition: all 0.3s ease;
    cursor: pointer;
}

.playlist-card:hover {
    border-color: var(--accent-color);
    transform: translateY(-4px);
}

.playlist-card-cover {
    width: 100%;
    aspect-ratio: 1;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
    margin-bottom: 12px;
}

.playlist-card-play-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.playlist-card-cover:hover .playlist-card-play-overlay {
    opacity: 1;
}

.playlist-card-play-overlay svg {
    width: 48px;
    height: 48px;
    fill: white;
}

.playlist-card-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.playlist-card-count {
    font-size: 12px;
    color: var(--text-muted);
}

.full-width {
    width: 100%;
}

/* Track Options Modal */
.track-options-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.track-options-content {
    background: var(--bg-card);
    border-radius: 12px;
    padding: 20px;
    min-width: 250px;
    max-width: 90%;
}

.track-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.track-option-item {
    padding: 12px 16px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: background 0.2s ease;
}

.track-option-item:hover {
    background: var(--bg-hover);
}

.track-option-item svg {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
}

.danger-option {
    color: var(--error-color);
}

.playlist-item {
    display: block;
    width: 100%;
    padding: 8px 12px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 14px;
    font-family: inherit;
    text-align: left;
    cursor: pointer;
    transition: color 0.2s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.playlist-item:hover {
    color: var(--text-primary);
}

/* ========================================
   MAIN CONTENT
   ======================================== */
.main-content {
    flex: 1;
    margin-left: 256px;
    overflow-y: auto;
    padding-bottom: 112px;
    min-height: 100vh;
}

.main-content::-webkit-scrollbar {
    display: none;
}

/* Top Header */
.top-header {
    position: sticky;
    top: 0;
    z-index: 10;
    background-color: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border-color);
    padding: 16px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.header-left {
    display: flex;
    align-items: center;
    gap: 20px;
}

.logo-section {
    display: flex;
    flex-direction: column;
}

.header-subtitle {
    font-size: 12px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 12px;
}

.btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--bg-card);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn:hover {
    background-color: var(--bg-hover);
    border-color: var(--text-muted);
}

.btn-small {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background-color: var(--bg-card);
    color: var(--text-secondary);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    padding: 6px 14px;
    font-size: 12px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-small:hover {
    background-color: var(--bg-hover);
    color: var(--text-primary);
}

.btn-primary-small {
    background-color: var(--text-primary);
    color: var(--bg-primary);
    border-color: var(--text-primary);
}

.btn-primary-small:hover {
    background-color: var(--text-secondary);
}

.notification-btn {
    position: relative;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 8px;
    transition: color 0.2s;
}

.notification-btn:hover {
    color: var(--text-primary);
}

.notification-btn svg {
    width: 20px;
    height: 20px;
}

.notification-dot {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 8px;
    height: 8px;
    background-color: var(--text-primary);
    border-radius: 50%;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* Progress bar container */
#progressBar {
    position: relative;
    flex: 1;
    height: 4px;
    background-color: var(--bg-card);
    border-radius: 2px;
    cursor: pointer;
    overflow: visible; /* Changed from hidden to visible so thumb can show */
}

/* Progress fill */
#progressFill {
    height: 100%;
    background-color: var(--text-primary);
    border-radius: 2px;
    width: 0%;
    position: relative; /* Remove absolute positioning */
    transition: width 0.1s ease;
}

/* Thumb positioned absolutely on the progress bar */
#progressBar .progress-thumb {
    position: absolute;
    left: 0%; /* Will be updated by JavaScript */
    top: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
    background-color: var(--text-primary);
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.2s, left 0.1s ease;
    cursor: pointer;
    z-index: 2;
}

#progressBar:hover .progress-thumb {
    opacity: 1;
}

.profile-btn {
    width: 36px;
    height: 36px;
    background-color: var(--bg-card);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s;
}

.profile-btn:hover {
    background-color: var(--bg-hover);
}

.profile-btn svg {
    width: 20px;
    height: 20px;
    color: var(--text-primary);
}

/* ========================================
   TABS
   ======================================== */
.tabs {
    display: flex;
    gap: 4px;
    padding: 0 32px;
    background-color: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    overflow-x: auto;
}

.tab-btn {
    padding: 16px 20px;
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-secondary);
    font-size: 13px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s ease;
}

.tab-btn:hover {
    color: var(--text-primary);
}

.tab-btn.active {
    color: var(--text-primary);
    border-bottom-color: var(--text-primary);
}

/* ========================================
   SETTINGS PANEL
   ======================================== */
.settings-panel {
    position: fixed;
    top: 0;
    right: -400px;
    width: 400px;
    height: 100vh;
    background-color: var(--bg-secondary);
    border-left: 1px solid var(--border-color);
    z-index: 100;
    transition: right 0.3s ease;
    overflow-y: auto;
    padding: 24px;
}

.settings-panel.active {
    right: 0;
}

.settings-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 32px;
}

.settings-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    letter-spacing: 0.05em;
}

/* Equalizer Animation */
.equalizer {
    width: 20px;
    height: 20px;
    position: absolute;
    bottom: 8px;
    left: 8px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.equalizer.playing {
    opacity: 1;
}

.eq-bar {
    transform: scale(1, -1) translate(0, -24px);
    fill: white;
}

.eq-bar--1 {
    animation-name: short-eq;
    animation-duration: 0.5s;
    animation-iteration-count: infinite;
    animation-delay: 0s;
    animation-play-state: paused;
}

.eq-bar--2 {
    animation-name: tall-eq;
    animation-duration: 0.5s;
    animation-iteration-count: infinite;
    animation-delay: 0.17s;
    animation-play-state: paused;
}

.eq-bar--3 {
    animation-name: short-eq;
    animation-duration: 0.5s;
    animation-iteration-count: infinite;
    animation-delay: 0.34s;
    animation-play-state: paused;
}

.equalizer.playing .eq-bar--1,
.equalizer.playing .eq-bar--2,
.equalizer.playing .eq-bar--3 {
    animation-play-state: running;
}

@keyframes short-eq {
    0% {
        height: 8px;
    }
    50% {
        height: 4px;
    }
    100% {
        height: 8px;
    }
}

@keyframes tall-eq {
    0% {
        height: 16px;
    }
    50% {
        height: 6px;
    }
    100% {
        height: 16px;
    }
}

.close-settings {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 28px;
    cursor: pointer;
    padding: 4px 8px;
    transition: color 0.2s;
}

.close-settings:hover {
    color: var(--text-primary);
}

.settings-group {
    margin-bottom: 32px;
}

.settings-group-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 16px;
}

.setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 0;
    border-bottom: 1px solid var(--border-color);
}

.setting-label div:first-child {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.setting-description {
    font-size: 12px;
    color: var(--text-muted);
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 24px;
    transition: 0.3s;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 2px;
    bottom: 2px;
    background-color: var(--text-muted);
    border-radius: 50%;
    transition: 0.3s;
}

.toggle-switch input:checked + .toggle-slider {
    background-color: var(--text-primary);
    border-color: var(--text-primary);
}

.toggle-switch input:checked + .toggle-slider:before {
    transform: translateX(20px);
    background-color: var(--bg-primary);
}

.select-control {
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px 12px;
    color: var(--text-primary);
    font-size: 13px;
    font-family: inherit;
    cursor: pointer;
    outline: none;
}

.select-control:focus {
    border-color: var(--text-primary);
}

.settings-actions {
    display: flex;
    justify-content: flex-end;
    padding-top: 16px;
}

/* ========================================
   CONTENT AREA
   ======================================== */
.content-area {
    padding: 32px;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* ========================================
   SEARCH SECTION
   ======================================== */
.search-section {
    margin-bottom: 48px;
}

.search-hero {
    text-align: center;
    margin-bottom: 32px;
}

.search-hero-title {
    font-size: 64px;
    margin-bottom: 8px;
}

.search-hero-subtitle {
    color: var(--text-secondary);
    font-size: 16px;
}

.search-container {
    max-width: 600px;
    margin: 0 auto;
}

.search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}

.search-input-wrapper svg {
    position: absolute;
    left: 20px;
    width: 20px;
    height: 20px;
    color: var(--text-muted);
}

.search-input-wrapper input {
    width: 100%;
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 50px;
    padding: 16px 50px 16px 52px;
    color: var(--text-primary);
    font-size: 15px;
    font-family: inherit;
    outline: none;
    transition: all 0.2s ease;
}

.search-input-wrapper input::placeholder {
    color: var(--text-muted);
}

.search-input-wrapper input:focus {
    border-color: var(--text-primary);
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);
}

.clear-search-btn {
    position: absolute;
    right: 16px;
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
    transition: color 0.2s;
}

.clear-search-btn:hover {
    color: var(--text-primary);
}

.search-results-section {
    margin-top: 32px;
}

.result-count {
    font-size: 13px;
    color: var(--text-muted);
    font-weight: 400;
}

.search-results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 24px;
    margin-top: 24px;
}

/* ========================================
   DISCOVER SECTION
   ======================================== */
.discover-section {
    margin-bottom: 48px;
}

.quick-genre-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
}

.genre-quick-btn {
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 50px;
    padding: 10px 20px;
    color: var(--text-secondary);
    font-size: 13px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
}

.genre-quick-btn:hover {
    background-color: var(--text-primary);
    color: var(--bg-primary);
    border-color: var(--text-primary);
}

/* ========================================
   GENRE GRID
   ======================================== */
.genre-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 16px;
}

.genre-card {
    position: relative;
    aspect-ratio: 16/9;
    border-radius: 8px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.genre-card:hover {
    transform: scale(1.02);
}

.genre-card-bg {
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    opacity: 0.6;
}

.genre-card-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 100%);
}

.genre-card-content {
    position: relative;
    z-index: 1;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 20px;
}

.genre-card-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 24px;
    letter-spacing: 0.05em;
}

.genre-card-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

/* ========================================
   LIBRARY SECTION
   ======================================== */
.library-header {
    margin-bottom: 32px;
}

.library-title {
    font-size: 48px;
    margin-bottom: 8px;
}

.library-subtitle {
    color: var(--text-secondary);
    font-size: 16px;
}

.library-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    margin-bottom: 48px;
}

.stat-card {
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 24px;
    text-align: center;
}

.stat-number {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 48px;
    line-height: 1;
    margin-bottom: 8px;
}

.stat-label {
    font-size: 12px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

/* ========================================
   NO CONTENT STATE
   ======================================== */
.no-content {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
}

.no-content-icon {
    font-size: 48px;
    margin-bottom: 16px;
}

.no-content-text {
    font-size: 18px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 8px;
}

.no-content-subtext {
    font-size: 14px;
    color: var(--text-muted);
}

/* ========================================
   PLAYLIST GRID
   ======================================== */
.playlist-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 24px;
}

.playlist-card {
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.playlist-card:hover {
    background-color: var(--bg-hover);
    border-color: var(--text-muted);
}

.playlist-card-cover {
    width: 100%;
    aspect-ratio: 1;
    background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-card) 100%);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
    font-size: 48px;
}

.playlist-card-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 4px;
}

.playlist-card-count {
    font-size: 13px;
    color: var(--text-muted);
}

/* ========================================
   MODAL
   ======================================== */
.modal-overlay {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
}

.modal-content {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    width: 100%;
    max-width: 480px;
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 24px 24px 0;
}

.modal-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    letter-spacing: 0.05em;
}

.close-modal-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 28px;
    cursor: pointer;
    padding: 4px 8px;
    transition: color 0.2s;
}

.close-modal-btn:hover {
    color: var(--text-primary);
}

.modal-body {
    padding: 24px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

.input-control {
    width: 100%;
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px 16px;
    color: var(--text-primary);
    font-size: 14px;
    font-family: inherit;
    outline: none;
    transition: border-color 0.2s;
}

.input-control:focus {
    border-color: var(--text-primary);
}

.input-control::placeholder {
    color: var(--text-muted);
}

/* Modal Overlay & Content (if not already present) */
.modal-overlay {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
}

/* Form Groups */
.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

.textarea-control {
    resize: none;
    min-height: 100px;
}

/* Status Bar */
.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 32px;
    background-color: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    font-size: 13px;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--text-muted);
}

.status-dot.active {
    background-color: var(--success);
}

/* Progress Section */
.progress-section {
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 24px;
    margin-top: 32px;
}

.progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: var(--bg-secondary);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 16px;
}

.progress-bar-container .progress-bar {
    height: 100%;
    background-color: var(--success);
    width: 0%;
    transition: width 0.3s ease;
}

.progress-log {
    max-height: 200px;
    overflow-y: auto;
    font-size: 12px;
    color: var(--text-secondary);
}

.log-entry {
    padding: 4px 0;
}

/* Controls Section */
.controls-section {
    margin-bottom: 32px;
}

.control-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 16px;
}

.btn-success {
    background-color: var(--success);
    color: var(--bg-primary);
    border-color: var(--success);
}

.btn-success:hover {
    opacity: 0.9;
}

/* Loading & Error States */
.loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 40px;
}

.loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--bg-hover);
    border-top-color: var(--text-primary);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Download Header & Refresh Button */
.downloaded-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
}

.refresh-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--bg-card);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.refresh-btn:hover {
    background-color: var(--bg-hover);
}

/* Load More Container */
.load-more-container {
    text-align: center;
    padding: 32px 0;
}

.load-more-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px 24px;
    color: var(--text-primary);
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.load-more-btn:hover {
    background-color: var(--bg-hover);
}

.textarea-control {
    resize: none;
    min-height: 100px;
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    padding: 0 24px 24px;
}

.btn-primary {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--text-primary);
    color: var(--bg-primary);
    border: none;
    border-radius: 6px;
    padding: 10px 20px;
    font-size: 14px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-primary:hover {
    background-color: var(--text-secondary);
}

/* ========================================
   FEATURED SECTION
   ======================================== */
.featured-section {
    position: relative;
    overflow: hidden;
    border-radius: 4px;
    background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-primary) 100%);
    padding: 48px;
    margin-bottom: 48px;
}

.featured-content {
    position: relative;
    z-index: 2;
    max-width: 500px;
}

.featured-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--text-muted);
    margin-bottom: 8px;
    display: block;
}

/* ============================================
   PLAYBACK CONTROL BUTTONS STYLING
   ============================================ */

.control-buttons {
    display: flex;
    align-items: center;
    gap: 10px;
    justify-content: center;
}

.control-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    position: relative;
}

.control-btn:hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
}

.control-btn:active {
    transform: scale(0.95);
}

/* Active state for shuffle */
.control-btn.active {
    color: var(--accent-color) !important;
}

.control-btn.active::after {
    content: '';
    position: absolute;
    bottom: -4px;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--accent-color);
}

/* Repeat one indicator */
.control-btn.repeat-one svg {
    position: relative;
}

.repeat-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    font-weight: bold;
    color: var(--accent-color);
    pointer-events: none;
}

/* Skip buttons */
.control-btn.skip {
    width: 40px;
    height: 40px;
}

.control-btn.skip:hover {
    background: rgba(255, 255, 255, 0.15);
}

.pause-bar {
    width: 3px;
    height: 18px;
    background: white;
    border-radius: 1px;
}

/* SVG sizing */
.control-btn svg {
    width: 18px;
    height: 18px;
}

.control-btn.skip svg {
    width: 20px;
    height: 20px;
}

/* Disabled state */
.control-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.control-btn:disabled:hover {
    background: transparent;
    transform: none;
}

/* Tooltip on hover */
.control-btn::before {
    content: attr(title);
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 1000;
}

.control-btn:hover::before {
    opacity: 1;
}

/* Pulse animation for active shuffle/repeat */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.7;
    }
}

.control-btn.active:not(.repeat-one) svg {
    animation: pulse 2s ease-in-out infinite;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .control-buttons {
        gap: 8px;
    }
    
    .control-btn {
        width: 32px;
        height: 32px;
    }
    
    .control-btn.skip {
        width: 36px;
        height: 36px;
    }
    
    .play-pause-btn {
        width: 44px;
        height: 44px;
    }
    
    .control-btn svg {
        width: 16px;
        height: 16px;
    }
    
    .control-btn.skip svg {
        width: 18px;
        height: 18px;
    }
}

/* Focus styles for accessibility */
.control-btn:focus-visible {
    outline: 2px solid var(--accent-color);
    outline-offset: 2px;
}

.control-btn:focus:not(:focus-visible) {
    outline: none;
}

/* Loading state */
.control-btn.loading {
    pointer-events: none;
    opacity: 0.6;
}

.control-btn.loading svg {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

.featured-title {
    font-size: 72px;
    line-height: 1;
    margin-bottom: 16px;
}

.featured-description {
    color: var(--text-secondary);
    font-size: 14px;
    line-height: 1.6;
    margin-bottom: 24px;
}

.featured-actions {
    display: flex;
    align-items: center;
    gap: 16px;
}

.featured-actions .btn-primary {
    border-radius: 50px;
    padding: 12px 24px;
}

.featured-actions .btn-primary svg {
    width: 16px;
    height: 16px;
}

.btn-secondary {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: transparent;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 50px;
    padding: 12px 24px;
    font-size: 14px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: background-color 0.2s;
}

.btn-secondary:hover {
    background-color: var(--bg-card);
}

.featured-bg {
    position: absolute;
    right: 0;
    top: 0;
    width: 50%;
    height: 100%;
    opacity: 0.3;
}

.featured-bg img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.featured-bg::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to right, var(--bg-primary) 0%, transparent 100%);
}

/* ========================================
   SECTIONS
   ======================================== */
.section {
    margin-bottom: 48px;
}

.section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 24px;
}

.section-title {
    font-size: 32px;
}

.section-link {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    transition: color 0.2s;
}

.section-link:hover {
    color: var(--text-primary);
}

/* ========================================
   ALBUM GRID
   ======================================== */
.album-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 24px;
}

.album-card {
    background-color: var(--bg-card);
    border-radius: 4px;
    padding: 16px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.album-card:hover {
    background-color: var(--bg-hover);
}

.album-cover {
    position: relative;
    aspect-ratio: 1;
    margin-bottom: 16px;
    overflow: hidden;
    border-radius: 4px;
    background-color: var(--bg-secondary);
}

.album-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.play-btn-overlay {
    position: absolute;
    bottom: 8px;
    right: 8px;
    width: 44px;
    height: 44px;
    background-color: var(--text-primary);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transform: translateY(8px);
    transition: all 0.2s ease;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.play-btn-overlay svg {
    width: 18px;
    height: 18px;
    color: var(--bg-primary);
    margin-left: 2px;
}

.album-card:hover .play-btn-overlay {
    opacity: 1;
    transform: translateY(0);
}

.play-btn-overlay:hover {
    transform: scale(1.05);
}

.album-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.album-artist {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ========================================
   TRACKS TABLE
   ======================================== */
.tracks-table {
    background-color: var(--bg-card);
    border-radius: 4px;
    overflow: hidden;
}

.tracks-header {
    display: grid;
    grid-template-columns: 48px 2fr 1fr 100px 100px;
    gap: 16px;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
}

.track-row {
    display: grid;
    grid-template-columns: 48px 2fr 1fr 100px 100px;
    gap: 16px;
    padding: 12px 16px;
    align-items: center;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
}

.track-row:last-child {
    border-bottom: none;
}

.track-row:hover {
    background-color: var(--bg-hover);
}

.track-row > div:first-child {
    position: relative;
}

.track-number {
    color: var(--text-muted);
    font-size: 14px;
}

.track-play-btn {
    position: absolute;
    inset: 0;
    background: none;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    opacity: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.track-play-btn svg {
    width: 16px;
    height: 16px;
}

.track-row:hover .track-number {
    opacity: 0;
}

.track-row:hover .track-play-btn {
    opacity: 1;
}

.track-info {
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 0;
}

.track-thumb {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    overflow: hidden;
    flex-shrink: 0;
    background-color: var(--bg-secondary);
}

.track-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.track-details {
    min-width: 0;
}

.track-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-artist {
    font-size: 12px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-album {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-plays {
    font-size: 13px;
    color: var(--text-secondary);
}

.track-duration-col {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 16px;
}

.track-duration {
    font-size: 13px;
    color: var(--text-secondary);
}

.track-more-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    opacity: 0;
    transition: opacity 0.2s;
}

.track-row:hover .track-more-btn {
    opacity: 1;
}

.track-more-btn:hover {
    color: var(--text-primary);
}

.track-more-btn svg {
    width: 16px;
    height: 16px;
}

/* Responsive columns */
@media (max-width: 900px) {
    .col-album, .track-album {
        display: none;
    }
    
    .tracks-header, .track-row {
        grid-template-columns: 48px 2fr 100px 100px;
    }
}

@media (max-width: 700px) {
    .col-plays, .track-plays {
        display: none;
    }
    
    .tracks-header, .track-row {
        grid-template-columns: 48px 2fr 100px;
    }
}

/* ========================================
   ARTISTS GRID
   ======================================== */
.artists-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 24px;
}

.artist-card {
    text-align: center;
    cursor: pointer;
}

.artist-avatar {
    position: relative;
    width: 100%;
    aspect-ratio: 1;
    margin-bottom: 16px;
    border-radius: 50%;
    overflow: hidden;
    background-color: var(--bg-card);
}

.artist-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.artist-play-overlay {
    position: absolute;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.artist-card:hover .artist-play-overlay {
    opacity: 1;
}

/* Floating circular button (BLACK) */
.progress-fab {
    position: fixed;
    bottom: 90px;
    right: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    background: #000;
    color: #fff;
    font-size: 22px;
    cursor: pointer;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    z-index: 9999;
}

.progress-fab:hover {
    transform: scale(1.05);
}

/* Modal wrapper */
.progress-modal {
    position: fixed;
    inset: 0;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.progress-modal.hidden {
    display: none !important;
}

/* Backdrop */
.progress-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.75);
}

/* Modal content */
.progress-modal-content {
    position: relative;
    width: min(90%, 520px);
    max-height: 80vh;
    background: #000;
    color: #fff;
    border-radius: 16px;
    padding: 16px;
    overflow: hidden;
    box-shadow: 0 30px 80px rgba(0,0,0,0.8);
}

/* Close button */
.progress-modal-close {
    position: absolute;
    top: 10px;
    right: 10px;
    border: none;
    background: transparent;
    color: #fff;
    font-size: 20px;
    cursor: pointer;
}

/* Scrollable log */
.progress-log {
    max-height: 220px;
    overflow-y: auto;
}

.artist-play-btn {
    width: 56px;
    height: 56px;
    background-color: var(--text-primary);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    transition: transform 0.2s;
}

.artist-play-btn:hover {
    transform: scale(1.05);
}

.artist-play-btn svg {
    width: 24px;
    height: 24px;
    color: var(--bg-primary);
    margin-left: 3px;
}

.artist-name {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
}

.artist-followers {
    font-size: 12px;
    color: var(--text-secondary);
}

/* ========================================
   NOW PLAYING BAR
   ======================================== */
.now-playing-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 88px;
    background-color: var(--bg-secondary);
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    z-index: 50;
}

.now-playing-info {
    display: flex;
    align-items: center;
    gap: 16px;
    width: 30%;
    min-width: 180px;
}

.now-playing-cover {
    width: 56px;
    height: 56px;
    border-radius: 4px;
    overflow: hidden;
    flex-shrink: 0;
    background-color: var(--bg-card);
}

.now-playing-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.now-playing-details {
    min-width: 0;
}

.now-playing-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.now-playing-artist {
    font-size: 12px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.like-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 8px;
    transition: color 0.2s;
    flex-shrink: 0;
}

.like-btn:hover {
    color: var(--text-primary);
}

.like-btn.active {
    color: var(--text-primary);
}

.like-btn.active svg {
    fill: currentColor;
}

.like-btn svg {
    width: 18px;
    height: 18px;
}

/* Player Controls */
.player-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 40%;
    max-width: 600px;
}

.control-buttons {
    display: flex;
    align-items: center;
    gap: 16px;
}

.control-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 8px;
    transition: color 0.2s;
}

.control-btn:hover {
    color: var(--text-primary);
}

.control-btn svg {
    width: 18px;
    height: 18px;
}

.control-btn.skip svg {
    width: 20px;
    height: 20px;
}

.play-pause-btn {
    width: 36px;
    height: 36px;
    background-color: var(--text-primary);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s;
}

.play-pause-btn:hover {
    transform: scale(1.05);
}

.play-pause-btn .play-icon {
    width: 14px;
    height: 14px;
    color: var(--bg-primary);
    margin-left: 2px;
}

.play-pause-btn .pause-icon {
    display: none;
    gap: 3px;
}

.play-pause-btn.playing .play-icon {
    display: none;
}

.play-pause-btn.playing .pause-icon {
    display: flex;
}

.pause-bar {
    width: 3px;
    height: 12px;
    background-color: var(--bg-primary);
    border-radius: 1px;
}

/* Progress Bar */
.progress-container {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
}

.progress-time {
    font-size: 11px;
    color: var(--text-muted);
    min-width: 35px;
}

.progress-time:last-child {
    text-align: right;
}

.progress-bar {
    flex: 1;
    height: 4px;
    background-color: var(--bg-card);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.progress-fill {
    height: 100%;
    background-color: var(--text-primary);
    border-radius: 2px;
    width: 35%;
    position: relative;
    transition: width 0.1s ease;
}

.progress-thumb {
    position: absolute;
    right: -6px;
    top: 50%;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    background-color: var(--text-primary);
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.2s;
}

.progress-bar:hover .progress-thumb {
    opacity: 1;
}

/* Volume Controls */
.volume-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 30%;
    justify-content: flex-end;
}

.volume-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 8px;
    transition: color 0.2s;
}

.volume-btn:hover {
    color: var(--text-primary);
}

.volume-btn svg {
    width: 20px;
    height: 20px;
}

.volume-bar {
    width: 100px;
    height: 4px;
    background-color: var(--bg-card);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.volume-fill {
    height: 100%;
    background-color: var(--text-primary);
    border-radius: 2px;
    width: 70%;
    position: relative;
    transition: width 0.1s ease;
}

.volume-thumb {
    position: absolute;
    right: -6px;
    top: 50%;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    background-color: var(--text-primary);
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.2s;
}

.volume-bar:hover .volume-thumb {
    opacity: 1;
}

.fullscreen-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 8px;
    transition: color 0.2s;
}

.fullscreen-btn:hover {
    color: var(--text-primary);
}

.fullscreen-btn svg {
    width: 18px;
    height: 18px;
}

/* ========================================
   RESPONSIVE
   ======================================== */
@media (max-width: 1024px) {
    .sidebar {
        width: 72px;
    }
    
    .sidebar-logo span,
    .nav-item span:not(.nav-item svg),
    .playlist-header,
    .liked-songs-btn span:not(.liked-songs-icon),
    .playlist-list {
        display: none;
    }
    
    .sidebar-logo {
        justify-content: center;
        padding: 24px 0;
    }
    
    .nav-item {
        justify-content: center;
        padding: 16px;
    }
    
    .nav-item svg {
        margin: 0;
    }
    
    .liked-songs-btn {
        justify-content: center;
        width: 48px;
        margin: 0 auto;
        padding: 12px;
    }
    
    .main-content {
        margin-left: 72px;
    }
    
    .library-stats {
        grid-template-columns: repeat(2, 1fr);
    }
}

.np-fullscreen {
    position: fixed;
    inset: 0;
    z-index: 10000;
    color: white;
    padding: 24px;
    display: flex;
    flex-direction: column;
    background: #000;
}

.np-close-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    background: none;
    border: none;
    color: white;
    font-size: 22px;
    cursor: pointer;
}

.np-fs-content {
    max-width: 420px;
    width: 100%;
    margin: auto;
    display: flex;
    flex-direction: column;
    gap: 24px;
}

.np-fs-cover {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: 16px;
    overflow: hidden;
    background: #111;
}

.np-fs-info {
    text-align: center;
}

.np-fs-title {
    font-size: 20px;
    font-weight: 600;
}

.np-fs-artist {
    opacity: 0.7;
    font-size: 14px;
}

.np-fs-controls {
    display: flex;
    justify-content: space-between;
}

.np-fs-controls button {
    background: rgba(255,255,255,0.1);
    border: none;
    color: white;
    padding: 10px 12px;
    border-radius: 10px;
    cursor: pointer;
}

.np-lyrics-box {
    height: 160px;
    background: rgba(0,0,0,0.4);
    border-radius: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    opacity: 0.8;
}

@media (max-width: 768px) {
    .sidebar {
        display: none;
    }
    
    .main-content {
        margin-left: 0;
    }
    
    .top-header {
        padding: 12px 16px;
    }
    
    .content-area {
        padding: 16px;
    }
    
    .featured-section {
        padding: 24px;
    }
    
    .featured-title {
        font-size: 48px;
    }
    
    .featured-bg {
        opacity: 0.2;
        width: 100%;
    }
    
    .section-title {
        font-size: 24px;
    }
    
    .album-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }
    
    .now-playing-info {
        width: auto;
        min-width: 0;
    }
    
    .now-playing-cover {
        width: 48px;
        height: 48px;
    }
    
    .now-playing-details {
        display: none;
    }
    
    .player-controls {
        width: auto;
        flex: 1;
    }
    
    .volume-controls {
        width: auto;
    }
    
    .volume-bar {
        display: none;
    }
    
    .library-stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .tabs {
        padding: 0 16px;
    }
    
    .search-hero-title {
        font-size: 48px;
    }
    
    .library-title {
        font-size: 36px;
    }
}

@media (max-width: 480px) {
    .album-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
    }
    
    .album-card {
        padding: 8px;
    }
    
    .artists-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
    }
    
    .genre-grid {
        grid-template-columns: 1fr;
    }
    
    .header-controls .btn span:last-child {
        display: none;
    }
}
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MusicC - Music Streaming & Discovery</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-logo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 2v3M12 19v3M2 12h3M19 12h3"/>
                </svg>
                <span>MusicC</span>
            </div>

            <nav class="sidebar-nav">
                <button class="nav-item active" onclick="showTab('discover')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9 22 9 12 15 12 15 22"/>
                    </svg>
                    Discover
                </button>
                <button class="nav-item" onclick="showTab('library')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="M21 21l-4.35-4.35"/>
                    </svg>
                    Library
                </button>
                <button class="nav-item" onclick="showTab('downloaded')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Downloads
                </button>
            </nav>

            <div class="sidebar-divider"></div>

            <div class="playlist-header">
                <span>Playlists</span>
                <button onclick="showCreatePlaylistModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 8v8M8 12h8"/>
                    </svg>
                </button>
            </div>

            <button class="liked-songs-btn" onclick="showTab('liked')">
                <div class="liked-songs-icon">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </div>
                Liked Songs
                <span class="liked-count" id="sidebarLikedCount">0</span>
            </button>

            <div class="playlist-list" id="playlistList">
                <!-- Playlists will be loaded here -->
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="top-header">
                <div class="header-left">
                    <div class="logo-section">
                        <div class="header-subtitle" id="headerSubtitle">Music Discovery</div>
                    </div>
                </div>
                <div class="header-controls">
                    <button class="btn" onclick="showImportMusicModal()" id="importBtn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                        Import Music
                    </button>
                    <button class="btn" onclick="showSettings()" id="settingsBtn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                        </svg>
                        Settings
                    </button>
                    <button class="notification-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                            <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                        </svg>
                        <span class="notification-dot"></span>
                    </button>
                    <button class="profile-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                            <circle cx="12" cy="7" r="4"/>
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Settings Panel -->
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-header">
                    <div class="settings-title">Settings</div>
                    <button class="close-settings" onclick="hideSettings()"></button>
                </div>
                
                <div class="settings-group">
                    <div class="settings-group-title">Format Options</div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <div>Download as MP3</div>
                            <div class="setting-description">Convert all downloads to MP3 format (requires FFmpeg)</div>
                        </div>
                        <div class="setting-control">
                            <label class="toggle-switch">
                                <input type="checkbox" id="downloadAsMp3" onchange="updateSetting('download_as_mp3', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <div>MP3 Quality</div>
                            <div class="setting-description">Quality: 0 (best) to 9 (worst)</div>
                        </div>
                        <div class="setting-control">
                            <select class="select-control" id="mp3Quality" onchange="updateSetting('mp3_quality', this.value)">
                                <option value="0">0 - Best</option>
                                <option value="2">2</option>
                                <option value="4" selected>4</option>
                                <option value="6">6</option>
                                <option value="9">9 - Worst</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <div class="settings-group-title">Cover Art Options</div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <div>Embed Thumbnail</div>
                            <div class="setting-description">Embed album art into audio files (requires FFmpeg)</div>
                        </div>
                        <div class="setting-control">
                            <label class="toggle-switch">
                                <input type="checkbox" id="embedThumbnail" onchange="updateSetting('embed_thumbnail', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <div>Save Cover Separately</div>
                            <div class="setting-description">Save album art as separate JPG files</div>
                        </div>
                        <div class="setting-control">
                            <label class="toggle-switch">
                                <input type="checkbox" id="saveCoverSeparately" onchange="updateSetting('save_cover_separately', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <div class="settings-group-title">Storage</div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <div>Output Directory</div>
                            <div class="setting-description">Where downloaded files are saved</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="input-control" id="outputDir" 
                                   value="downloaded_music" 
                                   onchange="updateSetting('output_dir', this.value)">
                        </div>
                    </div>
                </div>
                
                <div class="settings-actions">
                    <button class="btn" onclick="hideSettings()">Close</button>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Ready to import music</span>
                </div>
                <div class="track-count" id="trackCount">
                    TOTAL: <span id="totalTracks">0</span> | LOADED: <span id="loadedTracks">0</span>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="tabs" id="mainTabs">
                <button class="tab-btn active" onclick="showTab('discover')" id="discoverTab">
                    Discover Music
                </button>
                <button class="tab-btn" onclick="showTab('library')" id="libraryTab">
                    Library
                </button>
                <button class="tab-btn" onclick="showTab('downloaded')" id="downloadedTab">
                    Downloaded (<span id="downloadedCount">0</span>)
                </button>
                <button class="tab-btn" onclick="showTab('playlists')" id="playlistsTab">
                    Playlists
                </button>
                <button class="tab-btn" onclick="showTab('liked')" id="likedTab">
                    Liked Songs (<span id="likedCount">0</span>)
                </button>
            </div>

            <!-- DISCOVER TAB CONTENT -->
            <div class="content-area" id="discoverTabContent">
                <!-- Music Discovery Search -->
                <div class="discover-section">
                    <div class="section-title">Discover New Music</div>
                    <div class="search-description" style="color: var(--text-secondary); margin-bottom: 15px; font-size: 14px;">
                        Search for any song, artist, or genre to find new music
                    </div>
                    
                    <div class="search-container" style="margin-bottom: 30px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <input type="text" id="discoverSearchInput" class="input-control" 
                                   placeholder="e.g., 'lofi hip hop', 'Taylor Swift', 'new jazz 2024'..." 
                                   style="flex: 1;" onkeyup="handleDiscoverSearchKeyup(event)">
                            <button class="btn btn-primary" onclick="performDiscoverSearch()" id="discoverSearchBtn">
                                <span></span> Search Music
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Popular Artists Section -->
                <section class="section">
                    <div class="section-header">
                        <h2 class="section-title">POPULAR ARTISTS</h2>
                        <button class="section-link" onclick="refreshPopularArtists()">Refresh</button>
                    </div>
                    <div class="artists-grid" id="popularArtistsGrid">
                        <div class="loading" style="grid-column: 1 / -1; padding: 40px;">
                            <div class="loading-spinner"></div>
                            <span>Loading artists...</span>
                        </div>
                    </div>
                </section>
                
                <!-- Search Results -->
                <div class="search-results-section" id="discoverResultsSection" style="display: none;">
                    <div class="section-header">
                        <div class="section-title">
                            Search Results for "<span id="discoverSearchQuery"></span>"
                            <span class="result-count" id="discoverResultCount">0 results</span>
                        </div>
                        <button class="btn-small" onclick="clearDiscoverResults()">
                            <span></span> Clear
                        </button>
                    </div>
                    
                    <div class="loading" id="discoverLoading" style="display: none; padding: 30px;">
                        <div class="loading-spinner"></div>
                        <span>Searching for music...</span>
                    </div>
                    
                    <div class="discover-grid" id="discoverResultsGrid">
                        <!-- Discovered tracks will appear here -->
                    </div>
                </div>
            
                <!-- Browse Genres -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">BROWSE GENRES</h2>
                    </div>
                    <div class="genre-grid" id="genreGrid"></div>
                </div>
            </div>

            <!-- LIBRARY TAB CONTENT -->
            <div class="content-area" id="libraryTabContent" style="display: none;">
                <!-- Library Header -->
                <div class="library-header">
                    <h1 class="library-title">YOUR LIBRARY</h1>
                    <p class="library-subtitle">All your imported music in one place</p>
                </div>

                <!-- Library Stats -->
                <div class="library-stats">
                    <div class="stat-card">
                        <div class="stat-number" id="totalTracksCount">0</div>
                        <div class="stat-label">Tracks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalPlaylistsCount">0</div>
                        <div class="stat-label">Playlists</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalArtistsCount">0</div>
                        <div class="stat-label">Artists</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="listeningHours">0</div>
                        <div class="stat-label">Hours</div>
                    </div>
                </div>

                <!-- Controls Section -->
                <div class="controls-section">
                    <div class="section-title">Controls</div>
                    <div class="control-buttons">
                        <button class="btn" onclick="loadTracks()" id="loadBtn">
                            <span></span> Load Tracks
                        </button>
                        <button class="btn" onclick="loadAllTracks()" id="loadAllBtn">
                            <span></span> Load All Tracks
                        </button>
                        <button class="btn" onclick="selectAll()" id="selectAllBtn">
                            <span></span> Select All
                        </button>
                        <button class="btn" onclick="deselectAll()" id="deselectAllBtn">
                            <span></span> Deselect All
                        </button>
                        <button class="btn btn-success" onclick="downloadSelected()" id="downloadBtn">
                            <span></span> Download Selected
                        </button>
                    </div>
                </div>

                <!-- Search Section -->
                <div class="controls-section" style="margin-top: 20px;">
                    <div class="section-title">Search & Find</div>
                    <div class="control-buttons">
                        <div style="flex: 1; display: flex; gap: 10px;">
                            <input type="text" id="searchInput" class="input-control" 
                                   placeholder="Search tracks by title, artist, or album..." 
                                   style="flex: 1;" onkeyup="handleSearchInput(event)">
                            <button class="btn" onclick="clearSearch()" id="clearSearchBtn" style="display: none;">
                                <span></span> Clear
                            </button>
                        </div>
                        <button class="btn" onclick="openSimilarTracksModal()" id="findSimilarBtn">
                            <span></span> Find Similar
                        </button>
                    </div>
                </div>

                <!-- Track Grid -->
                <div class="track-grid" id="trackGrid">
                    <div class="loading" id="loadingTracks" style="display: none;">
                        <div class="loading-spinner"></div>
                        <span>Loading tracks...</span>
                    </div>
                    <div class="no-tracks" id="noTracks" style="grid-column: 1 / -1; text-align: center; padding: 50px; color: var(--text-muted);">
                        No tracks loaded. Click "Load Tracks" or "Import Music" to start.
                    </div>
                </div>

                <!-- Load More Button -->
                <div class="load-more-container" id="loadMoreContainer" style="display: none;">
                    <button class="load-more-btn" onclick="loadMoreTracks()" id="loadMoreBtn">
                        <span></span> Load More Tracks
                    </button>
                </div>
            </div>

            <!-- Recommendations Section -->
            <div style="margin-bottom: 48px; padding: 0 32px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
                    <h2 style="font-size: 32px; font-family: 'Bebas Neue', sans-serif;">RECOMMENDED FOR YOU</h2>
                    <button onclick="refreshRecommendations()" style="background: none; border: none; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); cursor: pointer; font-family: inherit; transition: color 0.2s;">
                        Refresh
                    </button>
                </div>
                <div class="album-grid" id="recommendationsGrid">
                    <!-- Recommendations will appear here -->
                </div>
            </div>

                  <!-- Most Played -->
      <div class="section-card" id="mostPlayedSection" style="margin-bottom: 30px;">
        <div class="section-header">
          <div class="section-title">Your Most Played</div>
          <button class="btn-small" onclick="refreshMostPlayed()">
            <span></span> Refresh
          </button>
        </div>
        <div class="track-grid-horizontal" id="mostPlayedGrid">
          <!-- Most played tracks will appear here -->
        </div>
      </div>

      <section class="section tracks-section">
        <div class="section-header">
            <h2 class="section-title">TOP TRACKS</h2>
            <button class="section-link">See All</button>
        </div>
        <div class="tracks-table">
            <div class="tracks-header">
                <span>#</span>
                <span>Title</span>
                <span class="col-album">Album</span>
                <span class="col-plays">Plays</span>
                <span class="col-duration">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                </span>
            </div>
            <div id="tracksList">
                <!-- Dynamic tracks will be loaded here -->
                <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                    <div class="loading-spinner" style="margin: 0 auto 15px;"></div>
                    <div>Loading top tracks...</div>
                </div>
            </div>
        </div>
    </section>

            <!-- DOWNLOADED TAB CONTENT -->
            <div class="content-area" id="downloadedTabContent" style="display: none;">
                <div class="downloaded-header">
                    <div class="section-title">Downloaded Music</div>
                    <button class="refresh-btn" onclick="refreshDownloaded()">
                        <span></span> Refresh
                    </button>
                </div>
                
                <div class="track-grid" id="downloadedGrid">
                    <div class="no-tracks" id="noDownloadedTracks" style="grid-column: 1 / -1; text-align: center; padding: 50px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div>No downloaded tracks found</div>
                        <div style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                            Download tracks from your library to listen offline
                        </div>
                    </div>
                </div>
            </div>

            <!-- PLAYLISTS TAB CONTENT -->
            <div class="content-area" id="playlistsTabContent" style="display: none;">
                <div class="controls-section">
                    <div class="section-title">Playlists</div>
                    <div class="control-buttons">
                        <button class="btn btn-success" onclick="showCreatePlaylistModal()">
                            <span></span> Create New Playlist
                        </button>
                        <button class="btn" onclick="refreshPlaylists()">
                            <span></span> Refresh Playlists
                        </button>
                    </div>
                </div>
                
                <div class="playlist-grid" id="playlistsGrid">
                    <div class="no-tracks" id="noPlaylists" style="grid-column: 1 / -1; text-align: center; padding: 50px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div>No playlists found</div>
                        <div style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                            Create your first playlist to organize your music
                        </div>
                    </div>
                </div>
            </div>

            <!-- LIKED SONGS TAB CONTENT -->
            <div class="content-area" id="likedTabContent" style="display: none;">
                <div class="downloaded-header">
                    <div class="section-title">Liked Songs</div>
                    <button class="refresh-btn" onclick="refreshLikedSongs()">
                        <span></span> Refresh
                    </button>
                </div>
                
                <div class="track-grid" id="likedGrid">
                    <div class="no-tracks" id="noLikedTracks" style="grid-column: 1 / -1; text-align: center; padding: 50px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div>No liked songs yet</div>
                        <div style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                            Click the heart icon on any track to add it here
                        </div>
                    </div>
                </div>
            </div>

            <!-- Floating Progress Button -->
            <button id="progressFab" class="progress-fab" title="Download Progress">
                
            </button>
            
            <!-- Progress Modal -->
            <div id="progressModal" class="progress-modal hidden">
                <div class="progress-modal-backdrop" onclick="closeProgressModal()"></div>
            
                <div class="progress-modal-content">
                    <button class="progress-modal-close" onclick="closeProgressModal()"></button>
            
                    <!-- YOUR EXACT SECTION (UNCHANGED) -->
                    <div class="progress-section">
                        <div class="progress-header">
                            <div class="section-title">Download Progress</div>
                            <div class="progress-stats" id="progressStats">Idle</div>
                        </div>
            
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="mainProgressBar"></div>
                        </div>
            
                        <div class="progress-log" id="progressLog">
                            <div class="log-entry info">Ready to start downloads...</div>
                        </div>
                    </div>
                </div>
            </div>            

        <!-- Now Playing Bar -->
        <div class="now-playing-bar">
            <div class="now-playing-info">
                <div class="now-playing-cover">
                    <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;"></div>
                </div>
                <div class="now-playing-details">
                    <div class="now-playing-title" id="playerTrackTitle">No track selected</div>
                    <div class="now-playing-artist" id="playerTrackArtist">Select a track to play</div>
                </div>
                <button class="like-btn" id="likeBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </button>
            </div>

            <!-- Player Controls Section -->
            <div class="player-controls">
                <div class="control-buttons">
                    <button class="control-btn" onclick="toggleShuffle()" title="Shuffle">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="16 3 21 3 21 8"/>
                            <line x1="4" y1="20" x2="21" y2="3"/>
                            <polyline points="21 16 21 21 16 21"/>
                            <line x1="15" y1="15" x2="21" y2="21"/>
                            <line x1="4" y1="4" x2="9" y2="9"/>
                        </svg>
                    </button>
                    <button class="control-btn skip" onclick="skipBackward()" title="Previous">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="19 20 9 12 19 4 19 20"/>
                            <rect x="5" y="4" width="2" height="16"/>
                        </svg>
                    </button>
                    <button class="play-pause-btn" id="playPauseBtn" onclick="playPause()" title="Play">
                        <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        <div class="pause-icon">
                            <span class="pause-bar"></span>
                            <span class="pause-bar"></span>
                        </div>
                    </button>
                    <button class="control-btn skip" onclick="skipForward()" title="Next">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5 4 15 12 5 20 5 4"/>
                            <rect x="17" y="4" width="2" height="16"/>
                        </svg>
                    </button>
                    <button class="control-btn" onclick="toggleRepeat()" title="Repeat">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="17 1 21 5 17 9"/>
                            <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                            <polyline points="7 23 3 19 7 15"/>
                            <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                        </svg>
                    </button>
                </div>
            
                <!-- CORRECTED PROGRESS CONTAINER -->
                <div class="progress-container">
                    <span class="progress-time" id="currentTime">0:00</span>
                    <div class="progress-bar" id="progressBar" onclick="handleNowPlayingProgressClick(event)">
                        <div class="progress-fill" id="progressFill"></div>
                        <!-- Thumb is now directly inside progress-bar, not progress-fill -->
                        <div class="progress-thumb"></div>
                    </div>
                    <span class="progress-time" id="totalTime">0:00</span>
                </div>
            </div>

            <div class="volume-controls">
                <button class="volume-btn" id="volumeBtn" onclick="toggleMute()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                    </svg>
                </button>
                <div class="volume-bar" id="volumeBar" onclick="handleVolumeBarClick(event)" onmousedown="startVolumeDrag(event)">
                    <div class="volume-fill" id="volumeFill">
                        <div class="volume-thumb"></div>
                    </div>
                </div>
                <button class="fullscreen-btn" title="Fullscreen" onclick="toggleNowPlayingFullscreen()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 3 21 3 21 9"/>
                        <polyline points="9 21 3 21 3 15"/>
                        <line x1="21" y1="3" x2="14" y2="10"/>
                        <line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
            </div>

            <div id="nowPlayingFullscreenRoot"></div>

            <!-- UPDATED Import Music Modal -->
            <div id="importMusicModal" class="modal-overlay" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">Connect to Spotify</div>
                        <button onclick="closeImportMusicModal()" class="close-modal-btn"></button>
                    </div>
                    
                    <div class="modal-body">
                        <div style="text-align: center; padding: 30px 20px; color: var(--text-secondary);">
                            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 80px; height: 80px; margin-bottom: 20px; color: #1DB954;">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M8 14.5c2.5-1 5.5-1 8 0M8.5 11c3-1.5 6.5-1.5 9.5 0M9 7.5c3.5-1.5 7-1.5 10.5 0" stroke="white" stroke-width="1.5" fill="none"/>
                            </svg>
                            <h3 style="margin-bottom: 15px; color: var(--text-primary); font-size: 24px;" id="modalConnectionTitle">Bring Your Music from Spotify</h3>
                            <p style="margin-bottom: 25px; line-height: 1.6; max-width: 400px; margin-left: auto; margin-right: auto;" id="modalConnectionDesc">
                                Connect your Spotify account to browse and download your favorite tracks. Your library will be synced and ready to explore.
                            </p>
                            
                            <!-- Connection Status (hidden by default, shown when connected) -->
                            <div id="connectionStatusBox" style="display: none; background: rgba(29, 185, 84, 0.1); border: 1px solid #1DB954; border-radius: 8px; padding: 15px; margin-bottom: 25px;">
                                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; color: #1DB954; font-weight: 600;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                    <span>Connected to Spotify</span>
                                </div>
                                <div style="margin-top: 8px; font-size: 14px; color: var(--text-secondary);">
                                    <span id="connectionTrackCount">0</span> tracks available in your library
                                </div>
                            </div>
                            
                            <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; margin-bottom: 25px; text-align: left;">
                                <div style="font-weight: 600; margin-bottom: 12px; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px; color: #1DB954;">
                                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                    </svg>
                                    What you'll get:
                                </div>
                                <ul style="list-style: none; padding: 0; margin: 0;">
                                    <li style="padding: 8px 0; color: var(--text-secondary); display: flex; align-items: center; gap: 8px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; color: #1DB954; flex-shrink: 0;">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                        Access to your saved tracks
                                    </li>
                                    <li style="padding: 8px 0; color: var(--text-secondary); display: flex; align-items: center; gap: 8px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; color: #1DB954; flex-shrink: 0;">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                        Browse your playlists
                                    </li>
                                    <li style="padding: 8px 0; color: var(--text-secondary); display: flex; align-items: center; gap: 8px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; color: #1DB954; flex-shrink: 0;">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                        Stream 30-second previews
                                    </li>
                                    <li style="padding: 8px 0; color: var(--text-secondary); display: flex; align-items: center; gap: 8px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; color: #1DB954; flex-shrink: 0;">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                        Download tracks from YouTube
                                    </li>
                                </ul>
                            </div>
                            
                            <div style="font-size: 12px; color: var(--text-muted); margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                </svg>
                                Your credentials are stored securely and only used for this app
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-actions">
                        <button class="btn" onclick="closeImportMusicModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="connectSpotifyOnly()" id="connectSpotifyBtn" style="background: #1DB954; border-color: #1DB954;">
                            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; margin-right: 5px;">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M8 14.5c2.5-1 5.5-1 8 0M8.5 11c3-1.5 6.5-1.5 9.5 0M9 7.5c3.5-1.5 7-1.5 10.5 0" stroke="white" stroke-width="1.5" fill="none"/>
                            </svg>
                            <span id="connectSpotifyBtnText">Connect to Spotify</span>
                        </button>
                    </div>
                </div>
            </div>

    <!-- Create Playlist Modal -->
    <div id="createPlaylistModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Create New Playlist</div>
                <button onclick="closeCreatePlaylistModal()" class="close-modal-btn"></button>
            </div>
            
            <div class="modal-body">
                <div class="form-group">
                    <label>Playlist Name</label>
                    <input type="text" id="newPlaylistName" class="input-control" placeholder="Enter playlist name...">
                </div>
                
                <div class="form-group">
                    <label>Description (optional)</label>
                    <textarea id="newPlaylistDescription" class="input-control textarea-control" placeholder="Describe your playlist..."></textarea>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeCreatePlaylistModal()">Cancel</button>
                <button class="btn btn-primary" onclick="createPlaylist()">
                    <span></span> Create Playlist
                </button>
            </div>
        </div>
    </div>

    <!-- Similar Tracks Modal -->
    <div id="similarTracksModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Alternative Tracks Found</div>
                <button onclick="closeSimilarTracksModal()" class="close-modal-btn"></button>
            </div>
            
            <div class="modal-body">
                <div id="similarTracksOriginalInfo" style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid var(--border-color);">
                    <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);" id="originalTrackTitle"></div>
                    <div style="color: var(--text-secondary); font-size: 14px;" id="originalTrackArtist"></div>
                </div>
                
                <div id="similarTracksLoading" style="text-align: center; padding: 40px; display: none;">
                    <div class="loading-spinner" style="margin: 0 auto 15px;"></div>
                    <div>Searching for alternative tracks...</div>
                </div>
                
                <div id="similarTracksError" style="text-align: center; padding: 40px; color: var(--error); display: none;">
                     No alternative tracks found
                </div>
                
                <div id="similarTracksList" style="max-height: 500px; overflow-y: auto; display: none;">
                    <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 14px;">
                        Found <span id="similarTracksCount">0</span> alternative tracks:
                    </div>
                    <div id="similarTracksContainer"></div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeSimilarTracksModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Discover Track Preview Modal -->
    <div id="discoverPreviewModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <button onclick="closeDiscoverPreview()" class="close-modal-btn" style="position: absolute; top: 15px; right: 15px; z-index: 10;"></button>
            
            <div id="discoverPreviewContent">
                <!-- Preview content will be loaded here -->
            </div>
        </div>
    </div>
    
    <script>
        // ========================================
// SOUNDWAVE - Music Streaming App
// Pure JavaScript - No Frameworks
// ========================================

// GLOBAL PLAYER STATE - MUST RUN FIRST
window.appState = window.appState || {};
window.appState.currentPlayingTrack = window.appState.currentPlayingTrack || null;
window.appState.isPlaying = window.appState.isPlaying || false;
window.appState.isPaused = window.appState.isPaused || false;
window.appState.playbackDuration = window.appState.playbackDuration || 0;
window.appState.playbackPosition = window.appState.playbackPosition || 0;
window.appState.playlists = window.appState.playlists || {};
window.appState.downloadedTracks = window.appState.downloadedTracks || [];

// GLOBAL QUEUE
window.queueState = window.queueState || {
    tracks: [],
    index: 0,
    source: null,
    repeat: false,
    shuffle: false
};

// AUDIO ELEMENTS
window.audioElement = window.audioElement || document.getElementById('audioPlayer') || new Audio();
window.spotifyAudio = window.spotifyAudio || new Audio();

// Data
const albums = [
    { title: "Random Access Memories", artist: "Daft Punk", image: "https://images.unsplash.com/photo-1614613535308-eb5fbd3d2c17?w=300&h=300&fit=crop" },
    { title: "In Rainbows", artist: "Radiohead", image: "https://images.unsplash.com/photo-1598387993441-a364f854c3e1?w=300&h=300&fit=crop" },
    { title: "Mezzanine", artist: "Massive Attack", image: "https://images.unsplash.com/photo-1571330735066-03aaa9429d89?w=300&h=300&fit=crop" },
    { title: "Dummy", artist: "Portishead", image: "https://images.unsplash.com/photo-1504898770365-14faca6a7320?w=300&h=300&fit=crop" },
    { title: "Selected Ambient Works", artist: "Aphex Twin", image: "https://images.unsplash.com/photo-1557672172-298e090bd0f1?w=300&h=300&fit=crop" }
];

const tracks = [
    { title: "Get Lucky", artist: "Daft Punk", album: "Random Access Memories", duration: "4:08", plays: "1.2B" },
    { title: "Karma Police", artist: "Radiohead", album: "OK Computer", duration: "4:21", plays: "892M" },
    { title: "Teardrop", artist: "Massive Attack", album: "Mezzanine", duration: "5:31", plays: "654M" },
    { title: "Glory Box", artist: "Portishead", album: "Dummy", duration: "5:06", plays: "445M" },
    { title: "Windowlicker", artist: "Aphex Twin", album: "Windowlicker", duration: "6:07", plays: "234M" }
];

const artists = [
    { name: "Daft Punk", image: "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=200&h=200&fit=crop", followers: "24.5M" },
    { name: "Radiohead", image: "https://images.unsplash.com/photo-1511671782779-c97d3d27a1d4?w=200&h=200&fit=crop", followers: "18.2M" },
    { name: "Massive Attack", image: "https://images.unsplash.com/photo-1470225620780-dba8ba36b745?w=200&h=200&fit=crop", followers: "12.8M" },
    { name: "Portishead", image: "https://images.unsplash.com/photo-1459749411175-04bf5292ceea?w=200&h=200&fit=crop", followers: "8.4M" }
];

const genres = [
    { name: "Hip-Hop", count: "2.5M tracks", image: "https://images.unsplash.com/photo-1571609803939-54f463c5ce1c?w=400&h=225&fit=crop" },
    { name: "Jazz", count: "1.8M tracks", image: "https://images.unsplash.com/photo-1415201364774-f6f0bb35f28f?w=400&h=225&fit=crop" },
    { name: "Classical", count: "1.2M tracks", image: "https://images.unsplash.com/photo-1507838153414-b4b713384a76?w=400&h=225&fit=crop" },
    { name: "Phonk", count: "890K tracks", image: "https://images.unsplash.com/photo-1614149162883-504ce4d13909?w=400&h=225&fit=crop" },
    { name: "Jumpstyle", count: "450K tracks", image: "https://images.unsplash.com/photo-1574169208507-84376144848b?w=400&h=225&fit=crop" },
    { name: "Electronic", count: "3.2M tracks", image: "https://images.unsplash.com/photo-1571266028243-e4733b0f0bb0?w=400&h=225&fit=crop" },
    { name: "Rock", count: "4.1M tracks", image: "https://images.unsplash.com/photo-1498038432885-c6f3f1b912ee?w=400&h=225&fit=crop" },
    { name: "R&B", count: "2.1M tracks", image: "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=225&fit=crop" }
];

const recommendedSongs = [
    { title: "Blinding Lights", artist: "The Weeknd", image: "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=300&h=300&fit=crop" },
    { title: "Levitating", artist: "Dua Lipa", image: "https://images.unsplash.com/photo-1514320291840-2e0a9bf2a9ae?w=300&h=300&fit=crop" },
    { title: "Stay", artist: "The Kid LAROI", image: "https://images.unsplash.com/photo-1571330735066-03aaa9429d89?w=300&h=300&fit=crop" },
    { title: "Heat Waves", artist: "Glass Animals", image: "https://images.unsplash.com/photo-1598387993441-a364f854c3e1?w=300&h=300&fit=crop" },
    { title: "Good 4 U", artist: "Olivia Rodrigo", image: "https://images.unsplash.com/photo-1504898770365-14faca6a7320?w=300&h=300&fit=crop" }
];

const popularSongs = [
    { title: "Anti-Hero", artist: "Taylor Swift", image: "https://images.unsplash.com/photo-1516450360452-9312f5e86fc7?w=300&h=300&fit=crop" },
    { title: "As It Was", artist: "Harry Styles", image: "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=300&h=300&fit=crop" },
    { title: "Bad Habit", artist: "Steve Lacy", image: "https://images.unsplash.com/photo-1598387993441-a364f854c3e1?w=300&h=300&fit=crop" },
    { title: "Unholy", artist: "Sam Smith", image: "https://images.unsplash.com/photo-1571330735066-03aaa9429d89?w=300&h=300&fit=crop" },
    { title: "About Damn Time", artist: "Lizzo", image: "https://images.unsplash.com/photo-1504898770365-14faca6a7320?w=300&h=300&fit=crop" }
];

const playlists = [
    { name: "Chill Vibes", trackCount: 42, icon: "" },
    { name: "Workout Mix", trackCount: 28, icon: "" },
    { name: "Late Night", trackCount: 35, icon: "" },
    { name: "Focus Flow", trackCount: 50, icon: "" }
];

// Application state
let appState = {
    tracks: [],
    selectedTracks: new Set(),
    downloadedTracks: [],
    playlists: {},
    isDownloading: false,
    currentTab: 'spotify',
    previousVolume: 0.7, // Store previous volume for mute/unmute
    hasMoreTracks: false,
    currentOffset: 0,
    spotifyTotalTracks: 0,
    settings: {},
    currentPlayingTrack: null,
    isPlaying: false,
    isPaused: false,
    volume: 0.7,
    playbackPosition: 0,
    playbackDuration: 0,
    playbackUpdateInterval: null,
    isLiked: false,
    currentProgress: 35,
    isPlaying: false,
    currentPlayingTrack: null,
    spotifyConnected: false, // ADD THIS LINE
    currentVolume: 70
};

// Search state
let currentSearchResults = [];
let currentSimilarTrackIndex = null;

// Discover state
let discoverSearchResults = [];
let currentDiscoverQuery = '';

// Streaming state
let streamAudio = null;
let streamTrackInfo = null;
let streamProgressInterval = null;
let currentDiscoverStream = null;

// Additional state arrays
let likedSongs = [];
let downloadedSongs = [];

// DOM elements
const trackGrid = document.getElementById('trackGrid');
const downloadedGrid = document.getElementById('downloadedGrid');
const playlistsGrid = document.getElementById('playlistsGrid');
const noTracks = document.getElementById('noTracks');
const noDownloadedTracks = document.getElementById('noDownloadedTracks');
const noPlaylists = document.getElementById('noPlaylists');
const loadingTracks = document.getElementById('loadingTracks');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const totalTracks = document.getElementById('totalTracks');
const loadedTracks = document.getElementById('loadedTracks');
const downloadedCount = document.getElementById('downloadedCount');
const progressStats = document.getElementById('progressStats');
const mainProgressBar = document.getElementById('mainProgressBar');
const progressLog = document.getElementById('progressLog');
const ffmpegWarning = document.getElementById('ffmpegWarning');
const loadMoreContainer = document.getElementById('loadMoreContainer');
const loadMoreBtn = document.getElementById('loadMoreBtn');
const settingsPanel = document.getElementById('settingsPanel');
const loadAllBtn = document.getElementById('loadAllBtn');

// Player elements
const mediaPlayer = document.getElementById('mediaPlayer');
const playerAlbumArt = document.getElementById('playerAlbumArt');
const playerTrackTitle = document.getElementById('playerTrackTitle');
const playerTrackArtist = document.getElementById('playerTrackArtist');
const playPauseBtn = document.getElementById('playPauseBtn');
const currentTime = document.getElementById('currentTime');
const totalTime = document.getElementById('totalTime');
const progressSlider = document.getElementById('progressSlider');
const progressFill = document.getElementById('progressFill');
const progressHandle = document.getElementById('progressHandle');
const volumeIcon = document.getElementById('volumeIcon');
const volumeSlider = document.getElementById('volumeSlider');
const volumeFill = document.getElementById('volumeFill');
const volumeHandle = document.getElementById('volumeHandle');

// Search elements
const searchInput = document.getElementById('searchInput');
const clearSearchBtn = document.getElementById('clearSearchBtn');
const findSimilarBtn = document.getElementById('findSimilarBtn');

// Discover elements
const discoverSearchInput = document.getElementById('discoverSearchInput');
const discoverSearchBtn = document.getElementById('discoverSearchBtn');
const discoverResultsSection = document.getElementById('discoverResultsSection');
const discoverResultsGrid = document.getElementById('discoverResultsGrid');
const discoverLoading = document.getElementById('discoverLoading');
const discoverSearchQuery = document.getElementById('discoverSearchQuery');
const discoverResultCount = document.getElementById('discoverResultCount');

// ========================================
// SILENT AUTO-NAVIGATION FIX
// ========================================

document.addEventListener('DOMContentLoaded', async () => {
    console.log('[BOOT] App initializing');

    /* ===============================
       CORE APP INIT (UNCHANGED)
    =============================== */
    updateStatus('ready', 'Ready to connect');

    setTimeout(() => {
        loadSettings();
        checkFFmpeg();
        loadDownloadedTracks();
        startPlaybackUpdate();
        loadDiscoverPage();
        loadLikedSongsCount();
    }, 100);

    setTimeout(() => {
        console.log('[RENDER] Rendering all content');

        renderAlbums();
        renderTracks();
        renderArtists();
        renderGenres();
        renderRecommended();
        renderPopular();
        renderPlaylists();
        renderLibraryRecent();

        if (trackGrid && appState.tracks.length === 0 && noTracks) {
            noTracks.style.display = 'block';
            trackGrid.innerHTML = '';
            trackGrid.appendChild(noTracks);
        }

        if (downloadedGrid && appState.downloadedTracks.length === 0) {
            renderDownloadedTracks();
        }

        setupPlayerControls();
        setupProgressBar();
        setupVolumeBar();
        setupNavigation();
        updateCounts();

        console.log('[RENDER] Complete');
    }, 200);

    setTimeout(() => {
        console.log('[NAV] Silent navigation start');
        simulateTabNavigation();

        setTimeout(async () => {
            console.log('[SPOTIFY] Auto-connect');
            await ensureSpotifyConnected();
            setTimeout(() => loadTracks(true), 500);
        }, 1000);
    }, 500);

    /* ===============================
        NUCLEAR PROGRESS MODAL INIT
    =============================== */

    console.log('[MODAL] Initializing progress modal');

    const fab = document.getElementById('progressFab');
    const modal = document.getElementById('progressModal');

    if (!fab) {
        console.error('[MODAL] progressFab NOT FOUND');
    }
    if (!modal) {
        console.error('[MODAL] progressModal NOT FOUND');
    }

    if (fab && modal) {
        console.log('[MODAL] Elements found, binding click');

        // HARD RESET any previous listeners
        fab.onclick = null;

        fab.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('[MODAL] FAB CLICK');

            modal.classList.toggle('hidden');

            console.log(
                '[MODAL] Visible:',
                !modal.classList.contains('hidden')
            );
        });

        // Click outside to close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                console.log('[MODAL] Outside click  close');
                modal.classList.add('hidden');
            }
        });
    }

    /* ===============================
       GLOBAL CLICK PROBE (DEBUG)
    =============================== */
    document.addEventListener('click', (e) => {
        if (e.target?.id === 'progressFab') {
            console.log('[GLOBAL] FAB click detected');
        }
    });

    console.log('[BOOT] DOMContentLoaded finished');
});

// ========================================
// SIMULATE USER NAVIGATION
// ========================================

function simulateTabNavigation() {
    console.log(' Simulating user navigation...');
    
    // Force show home tab first
    showMainTab('home');
    
    // Navigate through all main tabs quickly
    const tabs = ['home', 'search', 'library'];
    let tabIndex = 0;
    
    const navigateTabs = setInterval(() => {
        if (tabIndex < tabs.length) {
            const tab = tabs[tabIndex];
            console.log(` Simulating click on ${tab} tab`);
            
            // Update active state in nav
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(nav => {
                nav.classList.remove('active');
                if (nav.getAttribute('data-tab') === tab) {
                    nav.classList.add('active');
                }
            });
            
            // Show the tab content
            showMainTab(tab);
            
            // If library tab, also navigate through its sub-tabs
            if (tab === 'library') {
                setTimeout(() => {
                    simulateLibraryTabs();
                }, 100);
            }
            
            tabIndex++;
        } else {
            clearInterval(navigateTabs);
            
            // Return to home tab
            setTimeout(() => {
                console.log(' Returning to home tab');
                showMainTab('home');
                
                const homeNav = document.querySelector('.nav-item[data-tab="home"]');
                if (homeNav) homeNav.classList.add('active');
                
                // Final render to ensure everything is visible
                setTimeout(() => {
                    console.log(' Final render pass...');
                    renderTracks();
                    renderDownloadedTracks();
                    renderPlaylists();
                    updateCounts();
                    
                    // Force show the player if hidden
                    const player = document.getElementById('player');
                    if (player) {
                        player.style.display = 'flex';
                    }
                    
                    console.log(' Silent navigation complete - app should be fully loaded');
                }, 300);
            }, 200);
        }
    }, 300);
}

function simulateLibraryTabs() {
    console.log(' Simulating library sub-tabs...');
    
    const libraryTabs = ['discover', 'playlists', 'liked', 'downloaded'];
    let libTabIndex = 0;
    
    const navigateLibrary = setInterval(() => {
        if (libTabIndex < libraryTabs.length) {
            const tab = libraryTabs[libTabIndex];
            console.log(`    Showing ${tab} tab`);
            
            // Update tab buttons
            const tabBtns = document.querySelectorAll('.tab-btn');
            tabBtns.forEach(btn => {
                const btnTab = btn.id.replace('Tab', '').toLowerCase();
                if (btnTab === tab) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Show the tab content
            showTab(tab);
            
            libTabIndex++;
        } else {
            clearInterval(navigateLibrary);
            
            // Return to discover tab
            setTimeout(() => {
                console.log('    Returning to discover tab');
                showTab('discover');
                
                const discoverBtn = document.getElementById('discoverTab');
                if (discoverBtn) discoverBtn.classList.add('active');
            }, 100);
        }
    }, 250);
}

// Render Albums
function renderAlbums() {
    const albumGrid = document.getElementById('albumGrid');
    if (!albumGrid) return;
    
    albumGrid.innerHTML = albums.map(album => `
        <div class="album-card">
            <div class="album-cover">
                <img src="${album.image}" alt="${album.title}">
                <button class="play-btn-overlay" onclick="playAlbum('${album.title}')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </button>
            </div>
            <div class="album-title">${album.title}</div>
            <div class="album-artist">${album.artist}</div>
        </div>
    `).join('');
}

// Render Tracks
function renderTracks() {
    const tracksList = document.getElementById('tracksList');
    if (!tracksList) return;
    
    tracksList.innerHTML = tracks.map((track, index) => `
        <div class="track-row">
            <div>
                <span class="track-number">${index + 1}</span>
                <button class="track-play-btn" onclick="playTrack('${track.title}')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </button>
            </div>
            <div class="track-info">
                <div class="track-thumb">
                    <img src="https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=80&h=80&fit=crop" alt="">
                </div>
                <div class="track-details">
                    <div class="track-title">${track.title}</div>
                    <div class="track-artist">${track.artist}</div>
                </div>
            </div>
            <div class="track-album">${track.album}</div>
            <div class="track-plays">${track.plays}</div>
            <div class="track-duration-col">
                <span class="track-duration">${track.duration}</span>
                <button class="track-more-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="1"/>
                        <circle cx="19" cy="12" r="1"/>
                        <circle cx="5" cy="12" r="1"/>
                    </svg>
                </button>
            </div>
        </div>
    `).join('');
}

// Render Artists
function renderArtists() {
    const artistsGrid = document.getElementById('artistsGrid');
    if (!artistsGrid) return;
    
    artistsGrid.innerHTML = artists.map(artist => `
        <div class="artist-card">
            <div class="artist-avatar">
                <img src="${artist.image}" alt="${artist.name}">
                <div class="artist-play-overlay">
                    <button class="artist-play-btn" onclick="playArtist('${artist.name}')">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="artist-name">${artist.name}</div>
            <div class="artist-followers">${artist.followers} followers</div>
        </div>
    `).join('');
}

// Render Genres
function renderGenres() {
    const genreGrid = document.getElementById('genreGrid');
    if (!genreGrid) return;
    
    genreGrid.innerHTML = genres.map(genre => `
        <div class="genre-card" onclick="setDiscoverSearch('${genre.name.toLowerCase()}')">
            <div class="genre-card-bg" style="background-image: url('${genre.image}')"></div>
            <div class="genre-card-overlay"></div>
            <div class="genre-card-content">
                <div class="genre-card-title">${genre.name}</div>
                <div class="genre-card-count">${genre.count}</div>
            </div>
        </div>
    `).join('');
}

// Render Popular
function renderPopular() {
    const popularGrid = document.getElementById('popularGrid');
    if (!popularGrid) return;
    
    popularGrid.innerHTML = popularSongs.map(song => `
        <div class="album-card">
            <div class="album-cover">
                <img src="${song.image}" alt="${song.title}">
                <button class="play-btn-overlay" onclick="playTrack('${song.title}')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </button>
            </div>
            <div class="album-title">${song.title}</div>
            <div class="album-artist">${song.artist}</div>
        </div>
    `).join('');
}

// Render Library Recent
function renderLibraryRecent() {
    const libraryRecentGrid = document.getElementById('libraryRecentGrid');
    if (!libraryRecentGrid) return;
    
    libraryRecentGrid.innerHTML = albums.map(album => `
        <div class="album-card">
            <div class="album-cover">
                <img src="${album.image}" alt="${album.title}">
                <button class="play-btn-overlay" onclick="playAlbum('${album.title}')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </button>
            </div>
            <div class="album-title">${album.title}</div>
            <div class="album-artist">${album.artist}</div>
        </div>
    `).join('');
}

// ========================================
// SHOW TRACK OPTIONS MODAL
// ========================================
function showTrackOptions(playlistName, trackIndex) {
    const modal = document.createElement('div');
    modal.className = 'track-options-modal';
    
    const content = document.createElement('div');
    content.className = 'track-options-content';
    
    let track;
    let source;
    
    if (playlistName) {
        // Track in playlist
        track = appState.playlists[playlistName].tracks[trackIndex];
        source = 'playlist';
    } else {
        // Downloaded track
        track = appState.downloadedTracks[trackIndex];
        source = 'downloaded';
    }
    
    content.innerHTML = `
        <h3 style="margin: 0 0 16px 0; font-size: 16px;">Track Options</h3>
        <div class="track-options-list">
            ${track.filepath ? `
                <div class="track-option-item" onclick="playTrackFromSource('${source}', ${trackIndex}); this.closest('.track-options-modal').remove()">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="8 5 19 12 8 19 8 5"/>
                    </svg>
                    Play Track
                </div>
            ` : ''}
            
            <div class="track-option-item" onclick="addToQueue('${source}', ${trackIndex}); this.closest('.track-options-modal').remove()">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="11 5 22 5 22 7 11 7 6 12 11 17 11 12 22 12 22 14 11 14 11 17 4 12 11 7 11 5"/>
                </svg>
                Add to Queue
            </div>
            
            <div class="track-option-item" onclick="addTrackToPlaylist('${source}', ${trackIndex}); this.closest('.track-options-modal').remove()">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 5v14M5 12h14"/>
                </svg>
                Add to Playlist
            </div>
            
            <div class="track-option-item" onclick="showTrackInfo('${source}', ${trackIndex}); this.closest('.track-options-modal').remove()">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 16v-4M12 8h.01"/>
                </svg>
                Track Info
            </div>
            
            ${playlistName ? `
                <div class="track-option-item danger-option" onclick="removeFromPlaylist('${playlistName}', ${trackIndex}); this.closest('.track-options-modal').remove()">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Remove from Playlist
                </div>
            ` : ''}
            
            ${source === 'downloaded' ? `
                <div class="track-option-item danger-option" onclick="deleteDownloadedTrack(${trackIndex}); this.closest('.track-options-modal').remove()">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Delete File
                </div>
            ` : ''}
        </div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Close modal when clicking outside
    modal.onclick = (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    };
}

// ========================================
// RENDER TRACKS GRID (MAIN LIBRARY) - FIXED
// ========================================
// First, let's update the renderTracks function to ensure proper click handlers

// Update the track card creation in renderTracks function
async function renderTracks() {
    if (!trackGrid) return;
    
    if (appState.tracks.length === 0) {
        if (noTracks) {
            noTracks.style.display = 'block';
            trackGrid.innerHTML = '';
            trackGrid.appendChild(noTracks);
        }
        if (loadingTracks) loadingTracks.style.display = 'none';
        return;
    }
    
    if (noTracks) noTracks.style.display = 'none';
    if (loadingTracks) loadingTracks.style.display = 'none';
    
    trackGrid.innerHTML = '';
    trackGrid.style.display = 'grid';
    trackGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
    trackGrid.style.gap = '16px';
    
    for (let i = 0; i < appState.tracks.length; i++) {
        const track = appState.tracks[i];
        const isDownloaded = track.downloaded || false;
        const isSelected = appState.selectedTracks.has(i);
        
        // Check if THIS SPECIFIC track is currently playing
        const isPlaying = appState.currentPlayingTrack && 
                         appState.currentPlayingTrack.spotify_id === track.spotify_id &&
                         appState.isPlaying;
        
        // Check if track is liked
        let isLiked = false;
        try {
            const likeCheck = await window.pywebview.api.is_track_liked(track.artist, track.title);
            if (likeCheck.success && likeCheck.is_liked) {
                isLiked = true;
            }
        } catch (e) {}
        
        const trackCard = document.createElement('div');
        trackCard.className = 'track-card';
        if (isPlaying) trackCard.classList.add('playing');
        trackCard.dataset.trackIndex = i;
        trackCard.dataset.source = 'spotify';
        trackCard.dataset.trackId = track.spotify_id || '';
        trackCard.style.cssText = `
            background: var(--bg-card);
            border: 1px solid ${isPlaying ? 'var(--accent-color)' : 'var(--border-color)'};
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: ${isPlaying ? '0 0 0 2px var(--accent-color)' : 'none'};
        `;
        
        // Create proper click handler
        trackCard.onclick = (e) => {
            // Don't trigger if clicking on buttons
            if (e.target.closest('button') || e.target.closest('.checkbox-overlay')) {
                return;
            }
            playTrackFromGrid(i, 'spotify');
        };
        
        // Cover with play button overlay
        const coverHtml = `
            <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: var(--bg-secondary); margin-bottom: 12px;">
                ${track.thumbnail ? 
                  `<img src="${track.thumbnail}" alt="${track.title}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                }
                <div class="equalizer ${isPlaying ? 'playing' : ''}" style="position: absolute; bottom: 8px; left: 8px; width: 20px; height: 20px; z-index: 10;">
                    <svg viewBox="0 0 24 24" fill="white">
                        <rect class="eq-bar eq-bar--1" x="4" y="4" width="3.7" height="8"/>
                        <rect class="eq-bar eq-bar--2" x="10.2" y="4" width="3.7" height="16"/>
                        <rect class="eq-bar eq-bar--3" x="16.3" y="4" width="3.7" height="11"/>
                    </svg>
                </div>
                <div class="play-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: ${isPlaying ? '1' : '0'}; transition: opacity 0.2s;">
                    <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                        <polygon points="8 5 19 12 8 19 8 5"/>
                    </svg>
                </div>
                ${!isDownloaded ? `
                    <div class="checkbox-overlay" style="position: absolute; top: 8px; right: 8px; width: 20px; height: 20px; background: ${isSelected ? 'var(--accent-color)' : 'var(--bg-card)'}; border: 2px solid ${isSelected ? 'var(--accent-color)' : 'var(--border-color)'}; border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10;"
                         onclick="event.stopPropagation(); toggleTrackSelect(${i})">
                        ${isSelected ? '<svg viewBox="0 0 24 24" fill="white" style="width: 12px; height: 12px;"><polygon points="20 6 9 17 4 12"/></svg>' : ''}
                    </div>
                ` : ''}
            </div>
        `;
        
        // Track info and actions...
        const infoHtml = `
            <div style="margin-bottom: 12px;">
                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.title}
                </div>
                <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.artist}
                </div>
            </div>
        `;
        
        const actionsHtml = `
        <div style="display: flex; gap: 8px; justify-content: center;">
            <button class="like-btn" data-track-index="${i}" data-source="spotify" 
                    style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid ${isLiked ? 'var(--error-color)' : 'var(--border-color)'}; background: ${isLiked ? 'var(--error-color)' : 'var(--bg-secondary)'}; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); toggleLikeTrack(${i}, this, 'spotify')" title="${isLiked ? 'Unlike' : 'Like'}">
                <svg viewBox="0 0 24 24" fill="${isLiked ? 'white' : 'none'}" stroke="${isLiked ? 'white' : 'currentColor'}" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
            </button>
            <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); showAddToPlaylistModalForTrack(${i}, 'spotify')" title="Add to Playlist">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 5v14M5 12h14"/>
                </svg>
            </button>
            <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); downloadSpotifyTrack(${i})" title="Download">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px; color: var(--text-primary);">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            </button>
        </div>
    `;
        
        trackCard.innerHTML = coverHtml + infoHtml + actionsHtml;
        
        // Hover effects (only if not playing)
        if (!isPlaying) {
            const playOverlay = trackCard.querySelector('.play-overlay');
            trackCard.addEventListener('mouseenter', () => {
                trackCard.style.transform = 'translateY(-2px)';
                trackCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                if (playOverlay) playOverlay.style.opacity = '1';
            });
            
            trackCard.addEventListener('mouseleave', () => {
                trackCard.style.transform = 'translateY(0)';
                trackCard.style.boxShadow = 'none';
                if (playOverlay) playOverlay.style.opacity = '0';
            });
        }
        
        trackGrid.appendChild(trackCard);
    }
}

// New function to play track from grid
async function playTrackFromGrid(index, source) {
    console.log(` Playing track from grid: index=${index}, source=${source}`);
    
    if (source === 'spotify') {
        if (index < 0 || index >= appState.tracks.length) {
            console.error('Invalid track index');
            return;
        }
        
        const track = appState.tracks[index];
        console.log('Selected track:', track);
        
        // Check if track is downloaded
        if (track.downloaded) {
            // Find in downloaded tracks and play
            const downloadedIndex = appState.downloadedTracks.findIndex(t => 
                t.artist === track.artist && t.title === track.title
            );
            if (downloadedIndex !== -1) {
                await playDownloadedTrack(downloadedIndex);
                return;
            }
        }
        
        // Not downloaded, try to stream
        await previewSpotifyTrackFromLibrary(index);
        
    } else if (source === 'downloaded') {
        await playDownloadedTrack(index);
    }
}

// Updated previewSpotifyTrackFromLibrary function
async function previewSpotifyTrackFromLibrary(index) {
    if (index < 0 || index >= appState.tracks.length) return;
    
    const track = appState.tracks[index];
    console.log('Library Spotify track:', track);
    
    // Update now playing bar immediately
    appState.currentPlayingTrack = track;
    appState.isPlaying = true;
    appState.playbackDuration = track.duration || 0;
    appState.playbackPosition = 0;
    
    updateNowPlayingPlayerInfo(track);
    updatePlayingStateVisuals();
    
    // Try Spotify preview first
    if (track.preview_url && track.preview_url !== 'None' && track.preview_url !== null) {
        console.log('Playing Spotify preview from library');
        playSpotifyPreview(track);
    } else {
        // Fallback to YouTube search
        console.log('No Spotify preview, searching YouTube');
        addLog(` Searching YouTube for: ${track.artist} - ${track.title}`, 'info');
        
        try {
            const searchQuery = `${track.artist} ${track.title} official audio`;
            const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 1);
            
            if (youtubeResults && youtubeResults.length > 0) {
                const ytTrack = youtubeResults[0];
                
                // Get streaming URL
                const streamResult = await window.pywebview.api.get_discover_streaming_url(ytTrack.youtube_url);
                
                if (streamResult && streamResult.success) {
                    // Create combined track object
                    const streamTrack = {
                        title: track.title,
                        artist: track.artist,
                        album: track.album || 'Unknown Album',
                        thumbnail: track.thumbnail || ytTrack.thumbnail,
                        youtube_url: ytTrack.youtube_url,
                        duration: ytTrack.duration || track.duration,
                        duration_str: ytTrack.duration_str || formatDuration(track.duration),
                        source: 'Spotify Library  YouTube'
                    };
                    
                    // Show streaming controls
                    showStreamControlsForDiscover(streamTrack, streamResult);
                    
                    // Auto-play
                    setTimeout(() => {
                        const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
                        if (playBtn) playBtn.click();
                    }, 300);
                    
                    addLog(` Streaming from YouTube: ${track.artist} - ${track.title}`, 'success');
                } else {
                    addLog(` Could not stream: ${track.artist} - ${track.title}`, 'error');
                    alert('Could not stream this track from YouTube');
                }
            } else {
                addLog(` Not found on YouTube: ${track.artist} - ${track.title}`, 'error');
                alert('Could not find this track on YouTube for streaming');
            }
        } catch (error) {
            console.error('Error streaming from YouTube:', error);
            addLog(` Streaming error: ${error.message}`, 'error');
            alert(`Error streaming track: ${error.message}`);
        }
    }
}

// Update the playSpotifyPreview function to work with library tracks
function playSpotifyPreview(track) {
    console.log('Playing Spotify 30-second preview from library');
    
    // Stop any existing audio
    if (streamAudio) {
        streamAudio.pause();
        streamAudio = null;
    }
    
    // Validate preview URL
    if (!track.preview_url || track.preview_url === 'None' || track.preview_url === null) {
        console.error('Invalid preview URL');
        return false; // Return false to indicate no preview available
    }
    
    // Create audio element for Spotify preview (30 seconds)
    streamAudio = new Audio(track.preview_url);
    streamAudio.volume = appState.volume || 0.7;
    
    streamTrackInfo = {
        title: track.title,
        artist: track.artist,
        duration: 30, // Spotify previews are 30 seconds
        duration_str: '0:30',
        thumbnail: track.thumbnail,
        source: 'Spotify Preview'
    };
    
    // Set up event listeners
    streamAudio.addEventListener('loadedmetadata', () => {
        addLog(` Playing Spotify preview: ${track.artist} - ${track.title}`, 'success');
        updateStreamDuration();
    });
    
    streamAudio.addEventListener('playing', () => {
        startStreamProgressUpdate();
    });
    
    streamAudio.addEventListener('ended', () => {
        addLog(' Preview ended', 'info');
        stopStream();
    });
    
    streamAudio.addEventListener('error', (e) => {
        console.error('Spotify preview error:', e);
        addLog(` Preview playback error`, 'error');
        stopStream();
    });
    
    // Show controls with note about 30-second preview
    const trackWithNote = {
        title: track.title + ' (30s Preview)',
        artist: track.artist,
        thumbnail: track.thumbnail,
        youtube_url: null
    };
    
    showStreamControlsForDiscover(trackWithNote, {
        stream_url: track.preview_url,
        title: track.title,
        artist: track.artist,
        thumbnail: track.thumbnail,
        duration: 30,
        duration_str: '0:30'
    });
    
    // Auto-play after a short delay
    setTimeout(() => {
        const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
        if (playBtn) {
            playBtn.click();
        }
    }, 300);
    
    return true;
}

// Update the existing previewSpotifyTrack function for discover tab
async function previewSpotifyTrack(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const result = discoverSearchResults[index];
    if (result.type !== 'spotify_track') return;
    
    const track = result.track;
    console.log('Discover tab Spotify track:', track);
    
    // Update now playing bar
    appState.currentPlayingTrack = track;
    appState.isPlaying = true;
    appState.playbackDuration = track.duration || 0;
    appState.playbackPosition = 0;
    
    updateNowPlayingPlayerInfo(track);
    updatePlayingStateVisuals();
    
    // If Spotify has a preview URL, play it
    if (track.preview_url && track.preview_url !== 'None' && track.preview_url !== null) {
        console.log('Playing Spotify preview from discover');
        const success = playSpotifyPreview(track);
        if (success) return;
    }
    
    // No preview available - search YouTube for this track
    console.log('No Spotify preview available in discover, searching YouTube...');
    addLog(` No Spotify preview - Searching YouTube for: ${track.artist} - ${track.title}`, 'info');
    
    try {
        // Search YouTube for this exact track
        const searchQuery = `${track.artist} ${track.title} official audio`;
        console.log('YouTube search query:', searchQuery);
        
        const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 1);
        
        console.log('YouTube results:', youtubeResults);
        
        if (youtubeResults && youtubeResults.length > 0) {
            // Use the first result (best match)
            const ytTrack = youtubeResults[0];
            
            // Keep Spotify metadata but use YouTube URL
            const combinedTrack = {
                title: track.title,
                artist: track.artist,
                album: track.album,
                thumbnail: track.thumbnail || ytTrack.thumbnail,
                youtube_url: ytTrack.youtube_url,
                duration: ytTrack.duration || track.duration,
                duration_str: ytTrack.duration_str || track.duration_str,
                source: 'YouTube (via Spotify Discover)'
            };
            
            console.log('Playing YouTube version from discover:', combinedTrack);
            addLog(` Found on YouTube: ${track.artist} - ${track.title}`, 'success');
            
            await previewYouTubeTrack(combinedTrack);
        } else {
            addLog(` Could not find preview for: ${track.artist} - ${track.title}`, 'error');
            alert(`Could not find preview for:\n${track.artist} - ${track.title}\n\nTry downloading instead!`);
        }
    } catch (error) {
        console.error('Error finding YouTube version in discover:', error);
        addLog(` Preview error: ${error.message}`, 'error');
        alert(`Preview error: ${error.message}\n\nTry downloading the track instead.`);
    }
}

// ============================================
// POPULAR ARTISTS SECTION
// ============================================

async function loadPopularArtists() {
    const grid = document.getElementById('popularArtistsGrid');
    if (!grid) return;
    
    try {
        // Show loading
        grid.innerHTML = `
            <div class="loading" style="grid-column: 1 / -1; padding: 40px;">
                <div class="loading-spinner"></div>
                <span>Loading artists...</span>
            </div>
        `;
        
        // Silently ensure Spotify is connected
        await ensureSpotifyConnected();
        
        // Get popular artists (only 5)
        const artists = await window.pywebview.api.get_popular_artists(5);
        
        if (!artists || artists.length === 0) {
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <div>No artists found</div>
                    <button class="btn" onclick="loadPopularArtists()" style="margin-top: 20px;">
                        Try Again
                    </button>
                </div>
            `;
            return;
        }
        
        // Render artists (will be 5 or fewer)
        renderPopularArtists(artists);
        
    } catch (error) {
        console.error('Error loading popular artists:', error);
        grid.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--error);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <div>Failed to load artists</div>
                <button class="btn" onclick="loadPopularArtists()" style="margin-top: 20px;">
                    Try Again
                </button>
            </div>
        `;
    }
}

function renderPopularArtists(artists) {
    const grid = document.getElementById('popularArtistsGrid');
    if (!grid) return;
    
    grid.innerHTML = artists.map(artist => `
        <div class="artist-card" onclick="showArtistProfile(${JSON.stringify(artist).replace(/"/g, '&quot;')})">
            <div class="artist-avatar">
                ${artist.image ? 
                  `<img src="${artist.image}" alt="${artist.name}" style="width: 100%; height: 100%; object-fit: cover;">` :
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;color:var(--text-muted);background:var(--bg-secondary);"></div>'
                }
                <div class="artist-play-overlay">
                    <button class="artist-play-btn" onclick="event.stopPropagation(); showArtistProfile(${JSON.stringify(artist).replace(/"/g, '&quot;')})">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="artist-name">${artist.name}</div>
            <div class="artist-followers">${formatFollowers(artist.followers)}</div>
        </div>
    `).join('');
}

function formatFollowers(count) {
    if (count >= 1000000) {
        return (count / 1000000).toFixed(1) + 'M followers';
    } else if (count >= 1000) {
        return (count / 1000).toFixed(1) + 'K followers';
    }
    return count + ' followers';
}

async function refreshPopularArtists() {
    addLog(' Refreshing popular artists...', 'info');
    await loadPopularArtists();
    addLog(' Artists refreshed', 'success');
}

// ============================================
// AUTO SPOTIFY CONNECTION
// ============================================

let spotifyConnectionAttempted = false;

async function ensureSpotifyConnected() {
    // If already connected, return
    if (appState.spotifyConnected) {
        return true;
    }
    
    // If already attempted and failed, don't retry
    if (spotifyConnectionAttempted) {
        return false;
    }
    
    try {
        spotifyConnectionAttempted = true;
        
        console.log(' Connecting to Spotify...');
        const result = await window.pywebview.api.connect_spotify();
        
        if (result && result.success) {
            appState.spotifyConnected = true;
            console.log(' Spotify connected');
            return true;
        } else {
            console.log(' Spotify connection failed');
            return false;
        }
    } catch (error) {
        console.error('Error connecting to Spotify:', error);
        return false;
    }
}

// Update searchAndShowArtists to use silent connection
async function searchAndShowArtists(query) {
    try {
        // Silently ensure Spotify is connected
        await ensureSpotifyConnected();
        
        addLog(` Searching for artist: ${query}`, 'info');
        
        const artists = await window.pywebview.api.search_spotify_artists(query, 10);
        
        if (!artists || artists.length === 0) {
            addLog(` Artist not found: ${query}`, 'error');
            alert(`Artist "${query}" not found. Try a different name.`);
            return;
        }
        
        addLog(` Found ${artists.length} artists`, 'success');
        showArtistProfile(artists[0]);
        
    } catch (error) {
        console.error('Error searching artist:', error);
        addLog(` Error: ${error.message}`, 'error');
        
        // If it's a connection error, show helpful message
        if (error.message.includes('connect') || error.message.includes('auth')) {
            alert('Please connect to Spotify first from the settings.');
        } else {
            alert(`Error searching for artist: ${error.message}`);
        }
    }
}

// Replace the showArtistProfile function with this updated version:

async function showArtistProfile(artist) {
    try {
        addLog(` Loading artist: ${artist.name}`, 'info');
        
        const [albums, topTracks] = await Promise.all([
            window.pywebview.api.get_artist_albums(artist.id, 20),
            window.pywebview.api.get_artist_top_tracks(artist.id)
        ]);

        window.currentArtistTracks = topTracks;
        
        // Create modal
        const modal = document.createElement('div');
        modal.id = 'artistProfileModal';
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
                <button onclick="closeArtistProfile()" class="close-modal-btn" style="position: absolute; top: 15px; right: 15px; z-index: 10;"></button>
                
                <!-- Artist Header -->
                <div style="display: flex; gap: 30px; margin-bottom: 30px; padding: 20px;">
                    <div style="width: 200px; height: 200px; border-radius: 50%; overflow: hidden; flex-shrink: 0; background: var(--bg-secondary);">
                        ${artist.image ? 
                          `<img src="${artist.image}" style="width: 100%; height: 100%; object-fit: cover;">` :
                          '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:64px;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:80px;height:80px;color:var(--text-muted);"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg></div>'
                        }
                    </div>
                    <div style="flex: 1;">
                        <h2 style="margin: 0 0 10px 0; font-size: 48px;">${artist.name}</h2>
                        <div style="color: var(--text-secondary); margin-bottom: 15px; display: flex; align-items: center; gap: 15px;">
                            <span style="display: flex; align-items: center; gap: 5px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="9" cy="7" r="4"></circle>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                                </svg>
                                ${(artist.followers / 1000000).toFixed(1)}M followers
                            </span>
                            <span style="display: flex; align-items: center; gap: 5px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                                </svg>
                                ${artist.popularity}/100 popularity
                            </span>
                        </div>
                        ${artist.genres && artist.genres.length > 0 ? `
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
                                ${artist.genres.slice(0, 5).map(genre => `
                                    <span style="background: var(--bg-secondary); padding: 4px 12px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 5px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                            <path d="M9 18V5l12-2v13"></path>
                                            <circle cx="6" cy="18" r="3"></circle>
                                            <circle cx="18" cy="16" r="3"></circle>
                                        </svg>
                                        ${genre}
                                    </span>
                                `).join('')}
                            </div>
                        ` : ''}
                        <button class="btn btn-primary" onclick="window.open('${artist.external_url}', '_blank')" style="display: flex; align-items: center; gap: 8px;">
                            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px;">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M8 14.5c2.5-1 5.5-1 8 0M8.5 11c3-1.5 6.5-1.5 9.5 0M9 7.5c3.5-1.5 7-1.5 10.5 0" stroke="white" stroke-width="1.5" fill="none"/>
                            </svg>
                            Open in Spotify
                        </button>
                    </div>
                </div>
                
                <!-- Top Tracks -->
                <div style="margin-bottom: 30px; padding: 0 20px;">
                    <h3 style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                        </svg>
                        Popular Tracks
                    </h3>
                    <div style="display: grid; gap: 10px;">
                        ${topTracks.slice(0, 5).map((track, idx) => `
                            <div style="display: flex; align-items: center; gap: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 8px; transition: all 0.2s;" onmouseenter="this.style.background='var(--bg-hover)'" onmouseleave="this.style.background='var(--bg-secondary)'">
                                <div style="font-weight: 600; color: var(--text-muted); width: 20px;">${idx + 1}</div>
                                <div style="width: 50px; height: 50px; border-radius: 4px; overflow: hidden; flex-shrink: 0;">
                                    ${track.thumbnail ? 
                                      `<img src="${track.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                      '<div style="width:100%;height:100%;background:var(--bg-primary);display:flex;align-items:center;justify-content:center;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg></div>'
                                    }
                                </div>
                                <div style="flex: 1; min-width: 0;">
                                    <div style="font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${track.title}</div>
                                    <div style="font-size: 14px; color: var(--text-secondary);">${track.duration_str}</div>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn-small" onclick="event.stopPropagation(); previewArtistTrack('${track.id}', '${artist.name}')" style="display: flex; align-items: center; gap: 4px;">
                                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 12px; height: 12px;">
                                            <polygon points="5 3 19 12 5 21 5 3"/>
                                        </svg>
                                        Preview
                                    </button>
                                    <button class="btn-small btn-success" onclick="event.stopPropagation(); downloadArtistTrack('${artist.name}', '${track.title}', '${track.duration}', '${track.thumbnail}', '${track.album}')" style="display: flex; align-items: center; gap: 4px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                            <polyline points="7 10 12 15 17 10"/>
                                            <line x1="12" y1="15" x2="12" y2="3"/>
                                        </svg>
                                        Download
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <!-- Albums -->
                <div style="padding: 0 20px;">
                    <h3 style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        Albums & Singles
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;">
                        ${albums.map(album => `
                            <div onclick="showAlbumTracks('${album.id}', '${album.name}')" style="cursor: pointer; transition: transform 0.2s;" onmouseenter="this.style.transform='translateY(-4px)'" onmouseleave="this.style.transform='translateY(0)'">
                                <div style="width: 100%; aspect-ratio: 1; border-radius: 8px; overflow: hidden; margin-bottom: 10px; background: var(--bg-secondary);">
                                    ${album.image ? 
                                      `<img src="${album.image}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:60px;height:60px;color:var(--text-muted);"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg></div>'
                                    }
                                </div>
                                <div style="font-weight: 600; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${album.name}</div>
                                <div style="font-size: 12px; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                                    <span style="display: flex; align-items: center; gap: 3px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                            <line x1="16" y1="2" x2="16" y2="6"></line>
                                            <line x1="8" y1="2" x2="8" y2="6"></line>
                                            <line x1="3" y1="10" x2="21" y2="10"></line>
                                        </svg>
                                        ${album.release_date.split('-')[0]}
                                    </span>
                                    <span style="display: flex; align-items: center; gap: 3px;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                            <path d="M9 18V5l12-2v13"></path>
                                            <circle cx="6" cy="18" r="3"></circle>
                                            <circle cx="18" cy="16" r="3"></circle>
                                        </svg>
                                        ${album.total_tracks}
                                    </span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        addLog(` Error loading artist profile: ${error.message}`, 'error');
    }
}

// Update showAlbumTracks function with icons and stream button:
async function showAlbumTracks(albumId, albumName) {
    try {
        addLog(` Loading album: ${albumName}`, 'info');
        
        const tracks = await window.pywebview.api.get_album_tracks(albumId);
        
        const modal = document.createElement('div');
        modal.id = 'albumTracksModal';
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.style.zIndex = '3000';
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <div class="modal-title" style="display: flex; align-items: center; gap: 10px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        ${albumName}
                    </div>
                    <button onclick="closeAlbumTracks()" class="close-modal-btn"></button>
                </div>
                
                <div class="modal-body" style="max-height: 500px; overflow-y: auto;">
                    ${tracks.map((track, idx) => `
                        <div style="display: flex; align-items: center; gap: 15px; padding: 12px; border-bottom: 1px solid var(--border-color);">
                            <div style="font-weight: 600; color: var(--text-muted); width: 25px;">${track.track_number}</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${track.title}</div>
                                <div style="font-size: 14px; color: var(--text-secondary); display: flex; align-items: center; gap: 5px;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <polyline points="12 6 12 12 16 14"></polyline>
                                    </svg>
                                    ${track.duration_str}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-small" onclick="streamAlbumTrack('${track.artist}', '${track.title}', '${track.thumbnail}', '${track.album}')" style="display: flex; align-items: center; gap: 4px;">
                                    <svg viewBox="0 0 24 24" fill="currentColor" style="width: 12px; height: 12px;">
                                        <polygon points="5 3 19 12 5 21 5 3"/>
                                    </svg>
                                    Stream
                                </button>
                                <button class="btn-small btn-success" onclick="downloadArtistTrack('${track.artist}', '${track.title}', '${track.duration}', '${track.thumbnail}', '${track.album}')" style="display: flex; align-items: center; gap: 4px;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="7 10 12 15 17 10"/>
                                        <line x1="12" y1="15" x2="12" y2="3"/>
                                    </svg>
                                    Download
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        addLog(` Error loading album tracks: ${error.message}`, 'error');
    }
}

// Add new function to stream album track:
async function streamAlbumTrack(artist, title, thumbnail, album) {
    try {
        addLog(` Searching YouTube for: ${artist} - ${title}`, 'info');
        
        const youtubeResults = await window.pywebview.api.search_youtube_music(
            `${artist} ${title} official audio`, 1
        );
        
        if (!youtubeResults || youtubeResults.length === 0) {
            addLog(` Could not find on YouTube: ${artist} - ${title}`, 'error');
            alert('Could not find this track on YouTube for streaming');
            return;
        }
        
        const ytTrack = youtubeResults[0];
        
        // Get streaming URL
        const streamResult = await window.pywebview.api.get_discover_streaming_url(ytTrack.youtube_url);
        
        if (streamResult && streamResult.success) {
            const trackData = {
                title: title,
                artist: artist,
                album: album || 'Unknown Album',
                thumbnail: thumbnail || ytTrack.thumbnail,
                youtube_url: ytTrack.youtube_url,
                duration: ytTrack.duration || 0,
                duration_str: ytTrack.duration_str || '0:00',
                source: 'Album Preview'
            };
            
            showStreamControlsForDiscover(trackData, streamResult);
            
            setTimeout(() => {
                const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (playBtn) playBtn.click();
            }, 300);
            
            addLog(` Streaming: ${artist} - ${title}`, 'success');
        } else {
            addLog(` Could not stream: ${artist} - ${title}`, 'error');
            alert('Could not stream this track from YouTube');
        }
    } catch (error) {
        console.error('Error streaming album track:', error);
        addLog(` Streaming error: ${error.message}`, 'error');
        alert(`Error streaming track: ${error.message}`);
    }
}

function closeArtistProfile() {
    const modal = document.getElementById('artistProfileModal');
    if (modal) modal.remove();
}

function closeAlbumTracks() {
    const modal = document.getElementById('albumTracksModal');
    if (modal) modal.remove();
}

async function previewArtistTrack(trackId) {
    // 1. Get the track data from the stored artist list
    if (!window.currentArtistTracks) {
        alert('Artist data not loaded. Please try opening the artist profile again.');
        return;
    }

    const track = window.currentArtistTracks.find(t => t.id === trackId);
    if (!track) {
        console.error('Track not found with ID:', trackId);
        return;
    }

    console.log(`Attempting to play: ${track.artist} - ${track.title}`);

    // 2. Check for Spotify Preview
    const hasSpotifyPreview = track.preview_url && 
                              track.preview_url !== 'None' && 
                              track.preview_url !== null;

    if (hasSpotifyPreview) {
        // Attempt to play Spotify preview directly
        try {
            // Stop any existing audio
            if (streamAudio) {
                streamAudio.pause();
                streamAudio = null;
            }

            // Setup Audio
            streamAudio = new Audio(track.preview_url);
            streamAudio.volume = 0.7;

            // Store info for UI
            streamTrackInfo = {
                title: track.title,
                artist: track.artist,
                duration: 30, // Spotify previews are 30s
                duration_str: '0:30',
                thumbnail: track.thumbnail
            };

            // Try to play
            await streamAudio.play();

            // Success: Show controls
            addLog(` Playing Spotify preview: ${track.artist} - ${track.title}`, 'success');
            showStreamControlsForDiscover(track, {
                stream_url: track.preview_url,
                title: track.title,
                artist: track.artist,
                thumbnail: track.thumbnail
            });

            // Auto-play button in UI
            setTimeout(() => {
                const btn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (btn) btn.click();
            }, 300);
            
            return; // Stop here, Spotify worked!

        } catch (error) {
            // Spotify link might be expired or blocked
            console.warn('Spotify preview failed, falling back to YouTube:', error);
            // Fall through to YouTube logic below
        }
    }

    // 3. FALLBACK: If no Spotify preview OR Spotify failed, search YouTube
    addLog(` No/Fail Spotify preview - Searching YouTube for: ${track.artist} - ${track.title}`, 'info');

    try {
        const searchQuery = `${track.artist} ${track.title} official audio`;
        const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 1);

        if (!youtubeResults || youtubeResults.length === 0) {
            alert(`Could not find "${track.title}" by ${track.artist} on YouTube.`);
            return;
        }

        const ytTrack = youtubeResults[0];
        
        // Get streaming URL from backend
        const streamResult = await window.pywebview.api.get_discover_streaming_url(ytTrack.youtube_url);

        if (streamResult && streamResult.success) {
            // Create a combined track object (Spotify Metadata + YouTube Stream)
            const streamTrack = {
                title: track.title,
                artist: track.artist,
                album: track.album || 'Unknown Album',
                thumbnail: track.thumbnail || ytTrack.thumbnail,
                youtube_url: ytTrack.youtube_url,
                duration: ytTrack.duration || track.duration,
                duration_str: ytTrack.duration_str || track.duration_str,
                source: 'YouTube (via Artist)'
            };

            // Show controls and play
            showStreamControlsForDiscover(streamTrack, streamResult);
            
            setTimeout(() => {
                const btn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (btn) btn.click();
            }, 500);
        } else {
            alert('Could not load stream from YouTube.');
        }

    } catch (error) {
        console.error('Error streaming from YouTube:', error);
        alert('Error loading preview: ' + error.message);
    }
}

/**
 * Play Track (Universal)
 * Handles playing tracks from lists like "Most Played" or "Top Tracks"
 * Logic:
 * 1. Check if track exists in local downloads -> Play File
 * 2. If not downloaded, search Spotify library -> Stream Spotify
 * 3. If not in Spotify, search YouTube -> Stream YouTube
 */
async function playTrack(title) {
    // 1. Prepare search term (case insensitive, trimmed)
    const searchTitle = title ? title.toString().trim().toLowerCase() : '';
    
    if (!searchTitle) {
        console.error('playTrack called with empty title');
        addLog(' PlayTrack: No title provided', 'warning');
        return;
    }

    console.log(` playTrack requested: "${title}"`);

    // 2. CHECK LOCAL DOWNLOADS (Priority #1)
    const downloadedIndex = appState.downloadedTracks.findIndex(track => {
        const tTitle = track.title ? track.title.trim().toLowerCase() : '';
        return tTitle === searchTitle;
    });

    if (downloadedIndex !== -1) {
        console.log(' Found in local downloads, playing file.');
        addLog(` Playing local file: ${appState.downloadedTracks[downloadedIndex].title}`, 'success');
        
        // Play the downloaded file
        await playDownloadedTrack(downloadedIndex);
        return;
    }

    // 3. CHECK SPOTIFY LIBRARY (Priority #2)
    const spotifyIndex = appState.tracks.findIndex(track => {
        const tTitle = track.title ? track.title.trim().toLowerCase() : '';
        return tTitle === searchTitle;
    });

    if (spotifyIndex !== -1) {
        console.log(' Found in Spotify library, streaming preview.');
        addLog(` Streaming Spotify preview: ${appState.tracks[spotifyIndex].title}`, 'info');
        
        // Try to play Spotify preview (handles fallback to YouTube internally in existing code)
        await previewSpotifyTrack(spotifyIndex);
        return;
    }

    // 4. FALLBACK: SEARCH YOUTUBE (Priority #3)
    console.log(' Not in library, searching YouTube to stream...');
    addLog(` Searching YouTube for: "${title}"`, 'info');

    try {
        const searchQuery = `${title} official audio`; // Clean query
        const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 1);

        if (!youtubeResults || youtubeResults.length === 0) {
            console.error('YouTube search returned no results.');
            addLog(` Could not find "${title}" on YouTube to play.`, 'error');
            alert(`Could not find this track for playback:\n\n${title}\n\nTry adding it to your library or downloading it first.`);
            return;
        }

        const ytTrack = youtubeResults[0];
        console.log(` Found on YouTube: ${ytTrack.title}`);
        
        // Preview the YouTube track (uses your existing preview logic)
        await previewYouTubeTrack(ytTrack);

    } catch (error) {
        console.error('Error playing track:', error);
        addLog(` Error playing track: ${error.message}`, 'error');
        alert(`Error playing track: ${error.message}`);
    }
}

async function downloadArtistTrack(artist, title, duration, thumbnail, album) {
    try {
        addLog(` Downloading: ${artist} - ${title}`, 'info');
        
        const trackInfo = {
            title: title,
            artist: artist,
            duration: parseInt(duration),
            thumbnail: thumbnail,
            album: album || 'Unknown Album'
        };
        
        // Search YouTube for the track
        const youtubeResults = await window.pywebview.api.search_youtube_music(
            `${artist} ${title} official audio`, 1
        );
        
        if (youtubeResults && youtubeResults.length > 0) {
            trackInfo.youtube_url = youtubeResults[0].youtube_url;
            
            const result = await window.pywebview.api.download_track_from_youtube(trackInfo);
            
            if (result && result.success) {
                addLog(` Downloaded: ${artist} - ${title}`, 'success');
            } else {
                addLog(` Download failed: ${artist} - ${title}`, 'error');
            }
        } else {
            addLog(` Could not find on YouTube: ${artist} - ${title}`, 'error');
        }
    } catch (error) {
        addLog(` Error: ${error.message}`, 'error');
    }
}

async function renderDownloadedTracks() {
    if (!downloadedGrid) return;
    
    if (appState.downloadedTracks.length === 0) {
        if (noDownloadedTracks) {
            noDownloadedTracks.style.display = 'block';
            downloadedGrid.innerHTML = '';
            downloadedGrid.appendChild(noDownloadedTracks);
        }
        return;
    }
    
    if (noDownloadedTracks) noDownloadedTracks.style.display = 'none';
    
    downloadedGrid.innerHTML = '';
    downloadedGrid.style.display = 'grid';
    downloadedGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
    downloadedGrid.style.gap = '16px';
    
    for (let i = 0; i < appState.downloadedTracks.length; i++) {
        const track = appState.downloadedTracks[i];
        const isPlaying = appState.currentPlayingTrack && 
                         appState.currentPlayingTrack.filepath === track.filepath;
        
        // Check if track is liked
        let isLiked = false;
        try {
            const likeCheck = await window.pywebview.api.is_track_liked(track.artist, track.title);
            if (likeCheck.success && likeCheck.is_liked) {
                isLiked = true;
            }
        } catch (e) {}
        
        const trackCard = document.createElement('div');
        trackCard.className = 'track-card';
        trackCard.dataset.trackIndex = i;
        trackCard.dataset.source = 'downloaded';
        trackCard.style.cssText = `
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        `;
        
        if (isPlaying) {
            trackCard.style.borderColor = 'var(--accent-color)';
            trackCard.style.boxShadow = '0 0 0 2px var(--accent-color)';
        }
        
        // Entire card plays the track
        trackCard.onclick = () => playDownloadedTrack(i);
        
        // Cover with play button or equalizer
        const coverHtml = `
            <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: var(--bg-secondary); margin-bottom: 12px;">
                ${track.thumbnail ? 
                  `<img src="${track.thumbnail}" alt="${track.title}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                }
                ${isPlaying ? `
                    <div class="equalizer playing" style="position: absolute; bottom: 8px; left: 8px; width: 20px; height: 20px; z-index: 10;">
                        <svg viewBox="0 0 24 24" fill="white">
                            <rect class="eq-bar eq-bar--1" x="4" y="4" width="3.7" height="8"/>
                            <rect class="eq-bar eq-bar--2" x="10.2" y="4" width="3.7" height="16"/>
                            <rect class="eq-bar eq-bar--3" x="16.3" y="4" width="3.7" height="11"/>
                        </svg>
                    </div>
                ` : ''}
                <div class="play-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;">
                    <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                        <polygon points="8 5 19 12 8 19 8 5"/>
                    </svg>
                </div>
            </div>
        `;
        
        // Track info
        const infoHtml = `
            <div style="margin-bottom: 12px;">
                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.title}
                </div>
                <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.artist}
                </div>
            </div>
        `;
        
        const actionsHtml = `
        <div style="display: flex; gap: 8px; justify-content: center;">
            <button class="like-btn" data-track-index="${i}" data-source="downloaded" 
                    style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid ${isLiked ? 'var(--error-color)' : 'var(--border-color)'}; background: ${isLiked ? 'var(--error-color)' : 'var(--bg-secondary)'}; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); toggleLikeTrack(${i}, this, 'downloaded')" title="Like">
                <svg viewBox="0 0 24 24" fill="${isLiked ? 'white' : 'none'}" stroke="${isLiked ? 'white' : 'currentColor'}" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
            </button>
            <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); showAddToPlaylistModalForTrack(${i}, 'downloaded')" title="Add to Playlist">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 5v14M5 12h14"/>
                </svg>
            </button>
            <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                    onclick="event.stopPropagation(); showTrackOptions(null, ${i})" title="More Options">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px; color: var(--text-primary);">
                    <circle cx="12" cy="6" r="2"/>
                    <circle cx="12" cy="12" r="2"/>
                    <circle cx="12" cy="18" r="2"/>
                </svg>
            </button>
        </div>
    `;
        
        trackCard.innerHTML = coverHtml + infoHtml + actionsHtml;
        
        // Hover effects (only if not playing)
        if (!isPlaying) {
            const playOverlay = trackCard.querySelector('.play-overlay');
            trackCard.addEventListener('mouseenter', () => {
                trackCard.style.transform = 'translateY(-2px)';
                trackCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                if (playOverlay) playOverlay.style.opacity = '1';
            });
            
            trackCard.addEventListener('mouseleave', () => {
                trackCard.style.transform = 'translateY(0)';
                trackCard.style.boxShadow = 'none';
                if (playOverlay) playOverlay.style.opacity = '0';
            });
        }
        
        downloadedGrid.appendChild(trackCard);
    }
}

// ========================================
// RENDER LIKED TRACKS - FIXED
// ========================================
function renderLikedTracks() {
    const likedGrid = document.getElementById('likedGrid');
    if (!likedGrid || !appState.likedTracks) return;
    
    if (appState.likedTracks.length === 0) {
        const noLikedTracks = document.getElementById('noLikedTracks');
        if (noLikedTracks) {
            likedGrid.innerHTML = '';
            likedGrid.appendChild(noLikedTracks);
        }
        return;
    }
    
    const noLikedTracks = document.getElementById('noLikedTracks');
    if (noLikedTracks) noLikedTracks.style.display = 'none';
    
    likedGrid.innerHTML = '';
    likedGrid.style.display = 'grid';
    likedGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
    likedGrid.style.gap = '16px';
    
    appState.likedTracks.forEach((track, index) => {
        const trackCard = document.createElement('div');
        trackCard.style.cssText = `
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        `;
        
        if (track.filepath) {
            trackCard.onclick = () => playLikedTrack(index);
        }
        
        // Cover with play button overlay
        const coverHtml = `
            <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: var(--bg-secondary); margin-bottom: 12px;">
                ${track.thumbnail ? 
                  `<img src="${track.thumbnail}" alt="${track.title}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                }
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;">
                    <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                        <polygon points="8 5 19 12 8 19 8 5"/>
                    </svg>
                </div>
            </div>
        `;
        
        // Track info
        const infoHtml = `
            <div style="margin-bottom: 12px;">
                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.title}
                </div>
                <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${track.artist}
                </div>
            </div>
        `;
        
        // Action buttons (small circular icons)
        const actionsHtml = `
            <div style="display: flex; gap: 8px;">
                <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                        onclick="event.stopPropagation(); unlikeLikedTrack('${track.track_id}', this)">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </button>
            </div>
        `;
        
        trackCard.innerHTML = coverHtml + infoHtml + actionsHtml;
        
        // Hover effects
        trackCard.addEventListener('mouseenter', () => {
            trackCard.style.transform = 'translateY(-2px)';
            trackCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
            trackCard.querySelector('div[style*="opacity: 0"]').style.opacity = '1';
        });
        
        trackCard.addEventListener('mouseleave', () => {
            trackCard.style.transform = 'translateY(0)';
            trackCard.style.boxShadow = 'none';
            trackCard.querySelector('div[style*="opacity: 1"]').style.opacity = '0';
        });
        
        likedGrid.appendChild(trackCard);
    });
}

// ========================================
// RENDER PLAYLISTS - FIXED
// ========================================
function renderPlaylists() {
    if (!playlistsGrid) return;
    
    const playlists = appState.playlists;

    // ADD THIS CHECK:
    if (!playlists || Object.keys(playlists).length === 0) {
        if (noPlaylists) {
            noPlaylists.style.display = 'block';
            playlistsGrid.innerHTML = '';
            playlistsGrid.appendChild(noPlaylists);
        }
        return;
    }

    const playlistKeys = Object.keys(playlists);
    
    if (playlistKeys.length === 0) {
        if (noPlaylists) {
            noPlaylists.style.display = 'block';
            playlistsGrid.innerHTML = '';
            playlistsGrid.appendChild(noPlaylists);
        }
        return;
    }
    
    if (noPlaylists) noPlaylists.style.display = 'none';
    
    playlistsGrid.innerHTML = '';
    playlistsGrid.style.display = 'grid';
    playlistsGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
    playlistsGrid.style.gap = '16px';
    
    playlistKeys.forEach(key => {
        const playlist = playlists[key];
        const isSystem = playlist.type === 'system' || key === 'Downloads' || key === 'Favorites';
        const trackCount = Array.isArray(playlist.tracks) ? playlist.tracks.length : 0;
        
        const playlistCard = document.createElement('div');
        playlistCard.style.cssText = `
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        `;
        
        playlistCard.onclick = () => openPlaylist(key);
        
        // Cover with folder icon
        const coverHtml = `
            <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%); margin-bottom: 12px; display: flex; align-items: center; justify-content: center;">
                <div style="font-size: 48px;">
                    ${isSystem ? '' : ''}
                </div>
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;">
                    <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                        <polygon points="8 5 19 12 8 19 8 5"/>
                    </svg>
                </div>
            </div>
        `;
        
        // Playlist info
        const infoHtml = `
            <div style="margin-bottom: 12px;">
                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${playlist.name || key}
                </div>
                <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${trackCount} track${trackCount !== 1 ? 's' : ''}
                </div>
            </div>
        `;
        
        // Action buttons (small circular icons)
        const actionsHtml = !isSystem ? `
            <div style="display: flex; gap: 8px;">
                <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                        onclick="event.stopPropagation(); editPlaylist('${key}')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                </button>
                <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                        onclick="event.stopPropagation(); deletePlaylist('${key}')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                </button>
            </div>
        ` : '';
        
        playlistCard.innerHTML = coverHtml + infoHtml + actionsHtml;
        
        // Hover effects
        playlistCard.addEventListener('mouseenter', () => {
            playlistCard.style.transform = 'translateY(-2px)';
            playlistCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
            playlistCard.querySelector('div[style*="opacity: 0"]').style.opacity = '1';
        });
        
        playlistCard.addEventListener('mouseleave', () => {
            playlistCard.style.transform = 'translateY(0)';
            playlistCard.style.boxShadow = 'none';
            playlistCard.querySelector('div[style*="opacity: 1"]').style.opacity = '0';
        });
        
        playlistsGrid.appendChild(playlistCard);
    });
}

// ========================================
// OPEN PLAYLIST MODAL (FIXED)
// ========================================
async function openPlaylist(playlistName) {
    const playlist = appState.playlists[playlistName];
    if (!playlist) return;
    
    const modal = document.createElement('div');
    modal.id = 'playlistTracksModal';
    modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:2000;';
    
    const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = 'background:var(--bg-card);border-radius:12px;padding:25px;width:800px;max-width:90%;max-height:80vh;overflow-y:auto;position:relative;';
    
    modalContent.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:25px;">
            <div>
                <h2 style="margin:0 0 5px 0;">${playlist.name}</h2>
                <div style="color:var(--text-secondary);font-size:14px;">
                    ${playlist.description || ''}  ${tracks.length} track${tracks.length !== 1 ? 's' : ''}
                </div>
            </div>
            <button onclick="closePlaylistTracksModal()" style="background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:24px;padding:5px;"></button>
        </div>
        
        <div id="playlistTracksContainer">
            ${tracks.length > 0 ? 
              tracks.map((track, index) => `
                <div style="display:flex;align-items:center;padding:12px;border-bottom:1px solid var(--border);gap:15px;">
                    <div style="width:50px;height:50px;background:var(--bg-secondary);border-radius:8px;overflow:hidden;flex-shrink:0;">
                        ${track.thumbnail ? 
                          `<img src="${track.thumbnail}" style="width:100%;height:100%;object-fit:cover;">` :
                          '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:20px;"></div>'
                        }
                    </div>
                    <div style="flex:1;min-width:0;">
                        <div style="font-weight:600;margin-bottom:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${track.title}</div>
                        <div style="color:var(--text-secondary);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${track.artist}</div>
                    </div>
                    <div style="color:var(--text-muted);font-size:12px;margin-right:10px;">${track.duration_str || '0:00'}</div>
                    <div style="display:flex;gap:8px;">
                        ${track.filepath ? 
                          `<button class="btn-small" onclick="event.stopPropagation();playPlaylistTrack(${index})" style="display:flex;align-items:center;gap:4px;">
                              <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                          </button>` : 
                          ''
                        }
                        <button class="btn-small" onclick="event.stopPropagation();removeFromPlaylist('${playlistName}',${index})" style="display:flex;align-items:center;gap:4px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
              `).join('') :
              '<div style="text-align:center;padding:40px;color:var(--text-muted);">No tracks in this playlist yet</div>'
            }
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    // Store playlist name for track actions
    window.currentOpenPlaylist = playlistName;
}

// ========================================
// CLOSE PLAYLIST MODAL
// ========================================
function closePlaylistTracksModal() {
    const modal = document.getElementById('playlistTracksModal');
    if (modal) modal.remove();
    document.body.style.overflow = 'auto';
    window.currentOpenPlaylist = null;
}

// ========================================
// PLAY PLAYLIST TRACK (FIXED)
// ========================================
async function playPlaylistTrack(trackIndex) {
    const playlistName = window.currentOpenPlaylist;
    if (!playlistName) return;
    
    const playlist = appState.playlists[playlistName];
    if (!playlist || !playlist.tracks || trackIndex >= playlist.tracks.length) return;
    
    const track = playlist.tracks[trackIndex];
    
    if (track.filepath) {
        // Find in downloaded tracks and play
        const downloadedIndex = appState.downloadedTracks.findIndex(t => t.filepath === track.filepath);
        if (downloadedIndex !== -1) {
            await playDownloadedTrack(downloadedIndex);
        } else {
            alert('Track file not found');
        }
    } else {
        alert('This track has no file to play');
    }
}

// ========================================
// DISPLAY SIMILAR TRACKS
// ========================================
function displaySimilarTracks(tracks) {
    const container = document.getElementById('similarTracksContainer');
    const countSpan = document.getElementById('similarTracksCount');
    const similarTracksList = document.getElementById('similarTracksList');
    
    if (!container || !countSpan || !similarTracksList) return;
    
    countSpan.textContent = tracks.length;
    container.innerHTML = '';
    
    tracks.forEach((track, index) => {
        const trackCard = document.createElement('div');
        trackCard.className = 'album-card';
        
        let thumbnailUrl = null;
        if (track.url) {
            try {
                const urlObj = new URL(track.url);
                const videoId = urlObj.searchParams.get('v') || urlObj.pathname.split('/').pop();
                if (videoId) {
                    thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                }
            } catch (e) {}
        }
        
        trackCard.innerHTML = `
            <div class="album-cover">
                ${thumbnailUrl ? 
                  `<img src="${thumbnailUrl}" alt="${track.title}">` : 
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;color:var(--text-muted);"></div>'
                }
            </div>
            <div class="album-title">${track.title}</div>
            <div class="album-artist">${track.uploader}</div>
            <div class="album-artist">${track.duration_str}</div>
            <div style="display: flex; gap: 8px; margin-top: 12px;">
                <button class="btn-small" onclick="playSimilarTrackPreview(${index})" style="flex: 1;">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg> Stream
                </button>
                <button class="btn-small" onclick="downloadSimilarTrack(${index})" style="flex: 1;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg> Download
                </button>
            </div>
        `;
        
        container.appendChild(trackCard);
    });
    
    similarTracksList.style.display = 'block';
}

// Setup Volume Bar - COMPLETE VERSION
function setupVolumeBar() {
    console.log(' Setting up volume controls...');
    
    const volumeBar = document.getElementById('volumeBar');
    const volumeFill = document.getElementById('volumeFill');
    const volumeBtn = document.getElementById('volumeBtn');
    
    console.log('Volume elements:', { volumeBar, volumeFill, volumeBtn });
    
    if (!volumeBar || !volumeFill) {
        console.error(' Volume bar elements not found!');
        return;
    }
    
    let isDragging = false;
    
    // Click to set volume
    volumeBar.addEventListener('click', function(e) {
        console.log(' Volume bar clicked');
        e.stopPropagation();
        const rect = volumeBar.getBoundingClientRect();
        const percentage = (e.clientX - rect.left) / rect.width;
        console.log('Setting volume to:', percentage);
        setVolume(percentage);
    });
    
    // Mouse down - start dragging
    volumeBar.addEventListener('mousedown', function(e) {
        console.log(' Volume drag started');
        e.preventDefault();
        isDragging = true;
        const rect = volumeBar.getBoundingClientRect();
        const percentage = (e.clientX - rect.left) / rect.width;
        setVolume(percentage);
    });
    
    // Mouse move - drag
    document.addEventListener('mousemove', function(e) {
        if (isDragging && volumeBar) {
            const rect = volumeBar.getBoundingClientRect();
            const percentage = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            setVolume(percentage);
        }
    });
    
    // Mouse up - stop dragging
    document.addEventListener('mouseup', function() {
        if (isDragging) {
            console.log(' Volume drag ended');
            isDragging = false;
        }
    });
    
    // Mute/unmute button
    if (volumeBtn) {
        volumeBtn.addEventListener('click', function(e) {
            console.log(' Mute button clicked');
            e.stopPropagation();
            if (appState.volume > 0) {
                appState.previousVolume = appState.volume;
                setVolume(0);
            } else {
                setVolume(appState.previousVolume || 0.7);
            }
        });
    }
    
    // Initialize volume display
    setVolume(appState.volume);
    
    console.log(' Volume controls setup complete');
}

// Set volume helper
async function setVolume(percentage) {
    percentage = Math.max(0, Math.min(1, percentage));
    appState.volume = percentage;
    
    console.log(' Setting volume to:', Math.round(percentage * 100) + '%');
    
    const volumeFill = document.getElementById('volumeFill');
    if (volumeFill) {
        volumeFill.style.width = (percentage * 100) + '%';
        console.log('Volume fill width:', volumeFill.style.width);
    }
    
    // Update icon
    updateVolumeIcon(percentage);
    
    // Update backend volume
    try {
        if (window.pywebview && window.pywebview.api) {
            await window.pywebview.api.set_volume(percentage);
        }
    } catch (error) {
        console.error('Error setting volume:', error);
    }
}

// Setup Navigation
function setupNavigation() {
    const navItems = document.querySelectorAll('.nav-item');
    
    navItems.forEach(item => {
        item.addEventListener('click', function() {
            const tab = this.getAttribute('data-tab');
            
            // Update nav active state
            navItems.forEach(nav => nav.classList.remove('active'));
            this.classList.add('active');
            
            // Show/hide content
            showMainTab(tab);
        });
    });
}

// Show Main Tab (Home/Search/Library)
function showMainTab(tab) {
    currentTab = tab;
    
    const homeContent = document.getElementById('homeTabContent');
    const searchContent = document.getElementById('searchTabContent');
    const libraryContent = document.getElementById('libraryTabContent');
    const mainTabs = document.getElementById('mainTabs');
    
    // Hide all
    if (homeContent) homeContent.style.display = 'none';
    if (searchContent) searchContent.style.display = 'none';
    if (libraryContent) libraryContent.style.display = 'none';
    
    // Show selected
    if (tab === 'home') {
        if (homeContent) homeContent.style.display = 'block';
        if (mainTabs) mainTabs.style.display = 'none';
    } else if (tab === 'search') {
        if (searchContent) searchContent.style.display = 'block';
        if (mainTabs) mainTabs.style.display = 'none';
    } else if (tab === 'library') {
        if (libraryContent) libraryContent.style.display = 'block';
        if (mainTabs) mainTabs.style.display = 'flex';
        showTab('discover');
    }
    
    // Update header subtitle
    const headerSubtitle = document.getElementById('headerSubtitle');
    if (headerSubtitle) {
        if (tab === 'home') headerSubtitle.textContent = 'Music Discovery';
        else if (tab === 'search') headerSubtitle.textContent = 'Search & Discover';
        else if (tab === 'library') headerSubtitle.textContent = 'Your Library';
    }
}

// Update Time Display
function updateTimeDisplay() {
    const currentTimeEl = document.getElementById('currentTime');
    const totalSeconds = 242; // 4:02 in seconds
    const currentSeconds = Math.floor((currentProgress / 100) * totalSeconds);
    const minutes = Math.floor(currentSeconds / 60);
    const seconds = currentSeconds % 60;
    
    if (currentTimeEl) {
        currentTimeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Update Counts
function updateCounts() {
    const likedCountEl = document.getElementById('likedCount');
    const sidebarLikedCountEl = document.getElementById('sidebarLikedCount');
    const downloadedCountEl = document.getElementById('downloadedCount');
    const totalTracksEl = document.getElementById('totalTracksCount');
    const totalArtistsEl = document.getElementById('totalArtistsCount');
    
    if (likedCountEl) likedCountEl.textContent = (appState.likedTracks && appState.likedTracks.length) ? appState.likedTracks.length : 0;
    if (sidebarLikedCountEl) sidebarLikedCountEl.textContent = likedSongs.length;
    if (downloadedCountEl) downloadedCountEl.textContent = downloadedSongs.length;
    if (totalTracksEl) totalTracksEl.textContent = albums.length + tracks.length;
    if (totalArtistsEl) totalArtistsEl.textContent = artists.length;
}

async function loadLikedSongsCount() {
  try {
      const likedTracks = await window.pywebview.api.get_liked_tracks_list();
      if (Array.isArray(likedTracks)) {
          const likedCountElement = document.getElementById('likedCount');
          if (likedCountElement) {
              likedCountElement.textContent = likedTracks.length;
          }
      }
  } catch (error) {
      console.error('Error loading liked songs count:', error);
  }
}

// ============================================
// SETTINGS FUNCTIONS
// ============================================

function showSettings() {
    settingsPanel.classList.add('active');
}

function hideSettings() {
    settingsPanel.classList.remove('active');
}

async function loadSettings() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const settings = await window.pywebview.api.get_settings();
            appState.settings = settings;
            appState.volume = settings.volume || 0.7;
            updateSettingsUI(settings);
            updateVolumeDisplay();
        }
    } catch (e) {
        console.log('Could not load settings:', e);
        addLog(' Could not load settings', 'warning');
    }
}

function updateSettingsUI(settings) {
    const downloadAsMp3 = document.getElementById('downloadAsMp3');
    const embedThumbnail = document.getElementById('embedThumbnail');
    const saveCoverSeparately = document.getElementById('saveCoverSeparately');
    const mp3Quality = document.getElementById('mp3Quality');
    const outputDir = document.getElementById('outputDir');
    const defaultVolume = document.getElementById('defaultVolume');
    const volumeValue = document.getElementById('volumeValue');
    
    if (downloadAsMp3) downloadAsMp3.checked = settings.download_as_mp3 || false;
    if (embedThumbnail) embedThumbnail.checked = settings.embed_thumbnail || false;
    if (saveCoverSeparately) saveCoverSeparately.checked = settings.save_cover_separately || false;
    if (mp3Quality) mp3Quality.value = settings.mp3_quality || '2';
    if (outputDir) outputDir.value = settings.output_dir || 'downloaded_music';
    if (defaultVolume) defaultVolume.value = Math.round((settings.volume || 0.7) * 100);
    if (volumeValue) volumeValue.textContent = Math.round((settings.volume || 0.7) * 100) + '%';
}

async function updateSetting(key, value) {
    appState.settings[key] = value;
    if (key === 'volume') {
        appState.volume = value;
        updateVolumeDisplay();
    }
}

async function saveSettings() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const success = await window.pywebview.api.update_settings(appState.settings);
            if (success) {
                addLog(' Settings saved successfully', 'success');
                hideSettings();
            } else {
                addLog(' Failed to save settings', 'error');
            }
        } else {
            addLog(' API not available', 'error');
        }
    } catch (e) {
        console.log('Could not save settings:', e);
        addLog(` Error saving settings: ${e.message}`, 'error');
    }
}

function loadCurrentSettings() {
    updateSettingsUI(appState.settings);
}

// Check FFmpeg
async function checkFFmpeg() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const hasFfmpeg = await window.pywebview.api.check_ffmpeg();
            if (!hasFfmpeg) {
                ffmpegWarning.style.display = 'block';
                
                const downloadAsMp3 = document.getElementById('downloadAsMp3');
                const embedThumbnail = document.getElementById('embedThumbnail');
                const mp3Quality = document.getElementById('mp3Quality');
                
                if (downloadAsMp3) downloadAsMp3.disabled = true;
                if (embedThumbnail) embedThumbnail.disabled = true;
                if (mp3Quality) mp3Quality.disabled = true;
                
                document.querySelectorAll('.setting-item').forEach(item => {
                    const label = item.querySelector('.setting-label');
                    if (label && (label.textContent.includes('MP3') || label.textContent.includes('Embed'))) {
                        item.style.opacity = '0.6';
                        item.style.cursor = 'not-allowed';
                    }
                });
            }
        }
    } catch (e) {
        console.log('Could not check FFmpeg:', e);
        addLog(' Could not check FFmpeg installation', 'warning');
    }
}

// Update status display
function updateStatus(type, message) {
    if (!statusDot || !statusText) return;
    
    statusDot.className = 'status-dot';
    statusText.textContent = message;
    
    switch(type) {
        case 'connected':
            statusDot.classList.add('connected');
            break;
        case 'loading':
            statusDot.classList.add('loading');
            break;
        case 'error':
            statusDot.style.background = 'var(--error)';
            break;
        default:
            statusDot.style.background = 'var(--text-muted)';
    }
}

function updateTrackCount() {
    if (totalTracks) totalTracks.textContent = appState.spotifyTotalTracks;
    if (loadedTracks) loadedTracks.textContent = appState.tracks.length;
    if (downloadedCount) downloadedCount.textContent = appState.downloadedTracks.length;
}

function showTab(tabName) {
    appState.currentTab = tabName;
    
    // Update tab buttons - more reliable approach
    const tabBtns = document.querySelectorAll('.tab-btn');
    tabBtns.forEach(btn => {
        const btnTab = btn.id.replace('Tab', '').toLowerCase();
        if (btnTab === tabName) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Hide all tab contents
    const allTabContents = document.querySelectorAll('[id$="TabContent"]');
    allTabContents.forEach(content => {
        content.style.display = 'none';
    });
    
    // Show selected tab content
    const selectedContent = document.getElementById(tabName + 'TabContent');
    if (selectedContent) {
        selectedContent.style.display = 'block';
    }
    
    // Load data when tab is shown
    if (tabName === 'discover') {
        loadDiscoverPage();
    }
    
    if (tabName === 'playlists') {
        loadPlaylists();
    }
    
    if (tabName === 'liked') {
        loadLikedSongs();
    }
    
    if (tabName === 'downloaded') {
        loadDownloadedTracks();
    }
}

// ============================================
// SPOTIFY FUNCTIONS
// ============================================

// Connect to Spotify
async function connectSpotify() {
    const btn = document.getElementById('connectBtn');
    if (!btn) return;
    
    btn.disabled = true;
    updateStatus('loading', 'Connecting to Spotify...');
    addLog(' Connecting to Spotify...', 'info');
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.connect_spotify();
            if (result && result.success) {
                updateStatus('connected', 'Connected to Spotify');
                appState.spotifyTotalTracks = result.total_tracks || 0;
                updateTrackCount();
                addLog(' Successfully connected to Spotify', 'success');
                btn.innerHTML = '<span></span> Connected';
            } else {
                updateStatus('error', 'Failed to connect');
                addLog(' Failed to connect to Spotify', 'error');
                btn.disabled = false;
                btn.innerHTML = '<span></span> Connect';
            }
        } else {
            updateStatus('error', 'API not available');
            addLog(' API not available', 'error');
            btn.disabled = false;
            btn.innerHTML = '<span></span> Connect';
        }
    } catch (error) {
        console.error('Error connecting to Spotify:', error);
        updateStatus('error', 'Connection error');
        addLog(` Error: ${error.message}`, 'error');
        btn.disabled = false;
        btn.innerHTML = '<span></span> Connect';
    }
}

// Load tracks from Spotify (paginated)
async function loadTracks(reset = true) {
    const loadBtn = document.getElementById('loadBtn');
    const loadAllBtn = document.getElementById('loadAllBtn');
    
    if (!loadBtn || !loadAllBtn) return;
    
    loadBtn.disabled = true;
    loadAllBtn.disabled = true;
    updateStatus('loading', 'Loading tracks...');
    addLog(' Loading tracks from Spotify...', 'info');
    
    if (loadingTracks) loadingTracks.style.display = 'flex';
    if (noTracks) noTracks.style.display = 'none';
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.load_tracks(appState.currentOffset, false);
            if (result && result.tracks && result.tracks.length > 0) {
                if (reset) {
                    appState.tracks = result.tracks;
                    appState.currentOffset = result.tracks.length;
                    appState.selectedTracks.clear();
                    clearSearch();
                } else {
                    appState.tracks = [...appState.tracks, ...result.tracks];
                    appState.currentOffset = appState.tracks.length;
                }
                
                appState.spotifyTotalTracks = result.total_tracks || appState.spotifyTotalTracks;
                appState.hasMoreTracks = appState.tracks.length < appState.spotifyTotalTracks;
                
                renderTracks();
                updateStatus('connected', `${appState.tracks.length} tracks loaded`);
                updateTrackCount();
                addLog(` Loaded ${result.tracks.length} tracks (Total: ${appState.tracks.length})`, 'success');
                
                if (loadMoreContainer) {
                    if (appState.hasMoreTracks && appState.tracks.length < 500) {
                        loadMoreContainer.style.display = 'flex';
                        if (loadMoreBtn) {
                            loadMoreBtn.textContent = ` Load More (${appState.tracks.length}/${appState.spotifyTotalTracks})`;
                        }
                    } else {
                        loadMoreContainer.style.display = 'none';
                        if (appState.tracks.length >= 500) {
                            addLog(' Maximum of 500 tracks loaded', 'info');
                        }
                    }
                }
            } else {
                updateStatus('ready', 'No tracks found');
                addLog(' No tracks found in your library', 'info');
                if (noTracks) noTracks.style.display = 'block';
                if (loadingTracks) loadingTracks.style.display = 'none';
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
            }
        } else {
            updateStatus('error', 'API not available');
            addLog(' API not available', 'error');
            if (noTracks) noTracks.style.display = 'block';
            if (loadingTracks) loadingTracks.style.display = 'none';
        }
    } catch (error) {
        console.error('Error loading tracks:', error);
        updateStatus('error', 'Failed to load tracks');
        addLog(` Error loading tracks: ${error.message}`, 'error');
        if (noTracks) noTracks.style.display = 'block';
        if (loadingTracks) loadingTracks.style.display = 'none';
        if (loadMoreContainer) loadMoreContainer.style.display = 'none';
    } finally {
        if (loadBtn) loadBtn.disabled = false;
        if (loadAllBtn) loadAllBtn.disabled = false;
    }
}

// Load ALL tracks from Spotify at once
async function loadAllTracks() {
    const loadBtn = document.getElementById('loadBtn');
    const loadAllBtn = document.getElementById('loadAllBtn');
    
    if (!loadBtn || !loadAllBtn) return;
    
    loadBtn.disabled = true;
    loadAllBtn.disabled = true;
    loadAllBtn.innerHTML = '<span></span> Loading All...';
    updateStatus('loading', 'Loading ALL tracks...');
    addLog(' Loading ALL tracks from Spotify (this may take a moment)...', 'info');
    
    if (loadingTracks) loadingTracks.style.display = 'flex';
    if (noTracks) noTracks.style.display = 'none';
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.load_tracks(0, true);
            if (result && result.tracks && result.tracks.length > 0) {
                appState.tracks = result.tracks;
                appState.currentOffset = appState.tracks.length;
                appState.spotifyTotalTracks = result.total_tracks || appState.spotifyTotalTracks;
                appState.hasMoreTracks = false;
                appState.selectedTracks.clear();
                
                renderTracks();
                updateStatus('connected', `Loaded ${appState.tracks.length} tracks`);
                updateTrackCount();
                addLog(` Loaded ALL ${result.tracks.length} tracks`, 'success');
                
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
                
                if (appState.tracks.length >= 500) {
                    addLog(' Loaded maximum of 500 tracks', 'info');
                }
            } else {
                updateStatus('ready', 'No tracks found');
                addLog(' No tracks found in your library', 'info');
                if (noTracks) noTracks.style.display = 'block';
                if (loadingTracks) loadingTracks.style.display = 'none';
            }
        } else {
            updateStatus('error', 'API not available');
            addLog(' API not available', 'error');
            if (noTracks) noTracks.style.display = 'block';
            if (loadingTracks) loadingTracks.style.display = 'none';
        }
    } catch (error) {
        console.error('Error loading all tracks:', error);
        updateStatus('error', 'Failed to load all tracks');
        addLog(` Error loading all tracks: ${error.message}`, 'error');
        if (noTracks) noTracks.style.display = 'block';
        if (loadingTracks) loadingTracks.style.display = 'none';
    } finally {
        if (loadBtn) loadBtn.disabled = false;
        if (loadAllBtn) {
            loadAllBtn.disabled = false;
            loadAllBtn.innerHTML = '<span></span> Load All Tracks';
        }
    }
}

async function loadMoreTracks() {
    if (!loadMoreBtn || !appState.hasMoreTracks) return;
    
    loadMoreBtn.disabled = true;
    loadMoreBtn.textContent = 'Loading...';
    
    try {
        // Use the current length as the offset for the next page
        const offset = appState.tracks.length;
        
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.load_tracks(offset, false);
            
            if (result && result.tracks && result.tracks.length > 0) {
                appState.tracks = [...appState.tracks, ...result.tracks];
                appState.currentOffset = appState.tracks.length;
                appState.hasMoreTracks = appState.tracks.length < (result.total_tracks || appState.spotifyTotalTracks);
                
                renderTracks();
                updateTrackCount();
                
                addLog(` Loaded ${result.tracks.length} more tracks (Total: ${appState.tracks.length})`, 'success');
                
                // Update load more button
                if (loadMoreBtn && appState.hasMoreTracks) {
                    loadMoreBtn.textContent = ` Load More (${appState.tracks.length}/${appState.spotifyTotalTracks})`;
                } else {
                    if (loadMoreContainer) loadMoreContainer.style.display = 'none';
                }
            } else {
                appState.hasMoreTracks = false;
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
            }
        }
    } catch (error) {
        console.error('Error loading more tracks:', error);
        addLog(` Error loading more tracks: ${error.message}`, 'error');
    } finally {
        if (loadMoreBtn) {
            loadMoreBtn.disabled = false;
            loadMoreBtn.textContent = ` Load More (${appState.tracks.length}/${appState.spotifyTotalTracks})`;
        }
    }
}

// ============================================
// UNIVERSAL LIKE/UNLIKE SYSTEM
// ============================================

async function toggleLikeTrack(trackIndex, element = null, source = 'spotify') {
    try {
        let track;
        
        // Get track based on source
        if (source === 'spotify') {
            track = appState.tracks[trackIndex];
        } else if (source === 'downloaded') {
            track = appState.downloadedTracks[trackIndex];
        } else if (source === 'liked') {
            track = appState.likedTracks[trackIndex];
        } else if (source === 'recommendation') {
            track = appState.recommendations[trackIndex];
        } else if (source === 'discover') {
            track = appState.discoverSearchResults[trackIndex];
        } else if (source === 'streaming') {
            track = window.currentStreamingTrack;
        }
        
        if (!track || !track.title || !track.artist) {
            addLog(' Cannot like: Invalid track data', 'warning');
            return;
        }
        
        // Check current like status
        const checkResult = await window.pywebview.api.is_track_liked(track.artist, track.title);
        
        if (checkResult.success && checkResult.is_liked) {
            // UNLIKE the track
            const unlikeResult = await window.pywebview.api.unlike_track(checkResult.track.track_id);
            if (unlikeResult.success) {
                updateLikeButton(element, false);
                addLog(` Unliked: ${track.artist} - ${track.title}`, 'info');
                await loadLikedSongs(); // Refresh liked songs list
            }
        } else {
            // LIKE the track
            const likeResult = await window.pywebview.api.like_track({
                title: track.title,
                artist: track.artist,
                album: track.album || 'Unknown Album',
                duration: track.duration || 0,
                thumbnail: track.thumbnail,
                source: source,
                youtube_url: track.youtube_url,
                id: track.id || '',
                filepath: track.filepath
            });
            
            if (likeResult.success) {
                updateLikeButton(element, true);
                addLog(` ${likeResult.message}`, 'success');
                await loadLikedSongs(); // Refresh liked songs list
            }
        }
        
        // Refresh recommendations based on new likes
        await refreshRecommendations();
        
    } catch (error) {
        console.error('Error toggling like:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

function updateLikeButton(button, isLiked) {
    if (!button) return;
    
    const svg = button.querySelector('svg');
    if (!svg) return;
    
    if (isLiked) {
        button.style.borderColor = 'var(--error-color)';
        button.style.background = 'var(--error-color)';
        svg.setAttribute('fill', 'white');
        svg.setAttribute('stroke', 'white');
    } else {
        button.style.borderColor = 'var(--border-color)';
        button.style.background = 'var(--bg-secondary)';
        svg.setAttribute('fill', 'none');
        svg.setAttribute('stroke', 'currentColor');
    }
}

// ============================================
// LIKED SONGS FUNCTIONS
// ============================================

async function loadLikedSongs() {
    try {
        // Fetch list
        const likedTracks = await window.pywebview.api.get_liked_tracks_list();
        
        if (Array.isArray(likedTracks)) {
            appState.likedTracks = likedTracks;
            
            // --- UPDATE SIDEBAR COUNT ---
            updateSidebarLikedCount(likedTracks.length);
            // -------------------------------
            
            // Update tab count
            const likedCountEl = document.getElementById('likedCount');
            if (likedCountEl) {
                likedCountEl.textContent = likedTracks.length;
            }
            
            // Render the liked tracks grid (if you have one)
            if (appState.currentTab === 'liked') {
                renderLikedTracks();
            }
            
        } else {
            // Handle empty state
            updateSidebarLikedCount(0);
            
            const likedCountEl = document.getElementById('likedCount');
            if (likedCountEl) {
                likedCountEl.textContent = '0';
            }
            
            // Clear grid if on liked tab
            if (appState.currentTab === 'liked') {
                const likedGrid = document.getElementById('likedGrid');
                if (likedGrid) {
                    likedGrid.innerHTML = '<div class="no-content"><div class="no-content-icon"></div><div class="no-content-text">No liked songs yet</div></div>';
                }
            }
        }
    } catch (error) {
        console.error('Error loading liked songs:', error);
        addLog(` Error loading liked tracks: ${error.message}`, 'error');
    }
}

// Function to update sidebar liked count
function updateSidebarLikedCount(count) {
    const sidebarLikedCountEl = document.getElementById('sidebarLikedCount');
    if (sidebarLikedCountEl) {
        sidebarLikedCountEl.textContent = count;
        
        // Optional: Add animation for count changes
        sidebarLikedCountEl.style.transform = 'scale(1.2)';
        setTimeout(() => {
            sidebarLikedCountEl.style.transform = 'scale(1)';
        }, 200);
    }
}

async function refreshLikedSongs() {
  addLog(' Refreshing liked songs...', 'info');
  await loadLikedSongs();
  addLog(' Liked songs refreshed', 'success');
}

async function unlikeLikedTrack(trackId, element) {
    try {
        const result = await window.pywebview.api.unlike_track(trackId);
        if (result.success) {
            // Remove the track card
            const trackCard = element.closest('.track-card');
            if (trackCard) {
                trackCard.style.opacity = '0.5';
                setTimeout(() => trackCard.remove(), 300);
            }
            
            addLog(` ${result.message}`, 'info');
            await loadLikedSongs(); // Refresh the list
            await refreshRecommendations();
        }
    } catch (error) {
        console.error('Error unliking track:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

async function playLikedTrack(index) {
    try {
        if (index < 0 || index >= appState.likedTracks.length) return;
        
        const track = appState.likedTracks[index];
        
        // If track has a filepath, try to play it
        if (track.filepath) {
            // Find in downloaded tracks
            const downloadedIndex = appState.downloadedTracks.findIndex(
                t => t.filepath === track.filepath
            );
            
            if (downloadedIndex !== -1) {
                await playDownloadedTrack(downloadedIndex);
            } else {
                alert('Track file not found in downloads');
            }
        } else {
            alert('This track cannot be played (no file available)');
        }
    } catch (error) {
        console.error('Error playing liked track:', error);
        addLog(` Error playing track: ${error.message}`, 'error');
    }
}

// ============================================
// QUICK LIKE FUNCTION FOR ANY TRACK
// ============================================

function quickLikeTrack(trackData, source = 'unknown') {
    if (!trackData || !trackData.title || !trackData.artist) return;
    
    // Show a quick notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--error);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
    `;
    
    notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 20px;"></span>
            <div>
                <div style="font-weight: 600;">Liked Track</div>
                <div style="font-size: 12px; opacity: 0.9;">${trackData.artist} - ${trackData.title}</div>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove notification
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
    
    // Actually like the track
    toggleLikeTrack(0, null, source);
}

// Add this CSS for notifications
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(style);

// ============================================
// DOWNLOADED TRACKS FUNCTIONS
// ============================================

// Load downloaded tracks
async function loadDownloadedTracks() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const downloaded = await window.pywebview.api.get_downloaded_tracks();
            appState.downloadedTracks = downloaded || [];
            renderDownloadedTracks();
            updateTrackCount();
        }
    } catch (error) {
        console.error('Error loading downloaded tracks:', error);
        addLog(` Error loading downloaded tracks: ${error.message}`, 'error');
    }
}

// ============================================
// UPDATE OTHER RENDER FUNCTIONS WITH LIKE BUTTONS
// ============================================

// Refresh downloaded tracks
async function refreshDownloaded() {
    addLog(' Refreshing downloaded tracks...', 'info');
    await loadDownloadedTracks();
    addLog(` Found ${appState.downloadedTracks.length} downloaded tracks`, 'success');
}

// ============================================
// TRACK SELECTION FUNCTIONS
// ============================================

function toggleTrackSelect(index) {
    if (index < 0 || index >= appState.tracks.length) return;
    
    const track = appState.tracks[index];
    if (track.downloaded) {
        addLog(` Track "${track.title}" is already downloaded`, 'warning');
        return;
    }
    
    if (appState.selectedTracks.has(index)) {
        appState.selectedTracks.delete(index);
    } else {
        appState.selectedTracks.add(index);
    }
    renderTracks();
}

function selectAll() {
    let selectedCount = 0;
    for (let i = 0; i < appState.tracks.length; i++) {
        if (!appState.tracks[i].downloaded) {
            appState.selectedTracks.add(i);
            selectedCount++;
        }
    }
    renderTracks();
    addLog(` Selected ${selectedCount} tracks (skipped ${appState.tracks.length - selectedCount} already downloaded)`, 'success');
}

function deselectAll() {
    appState.selectedTracks.clear();
    renderTracks();
    addLog(' Deselected all tracks', 'info');
}

// ============================================
// DOWNLOAD FUNCTIONS
// ============================================

// Download selected tracks
async function downloadSelected() {
    const validSelectedIndices = Array.from(appState.selectedTracks).filter(index => 
        !appState.tracks[index].downloaded
    );
    
    if (validSelectedIndices.length === 0) {
        addLog(' No downloadable tracks selected (all selected tracks are already downloaded)', 'warning');
        return;
    }
    
    if (appState.isDownloading) {
        addLog(' Download already in progress', 'warning');
        return;
    }
    
    const total = validSelectedIndices.length;
    const outputDir = appState.settings.output_dir || 'downloaded_music';
    
    const mp3Status = appState.settings.download_as_mp3 ? 'MP3' : 'Original format';
    const embedStatus = appState.settings.embed_thumbnail ? 'with embedded cover' : 'without cover';
    const separateStatus = appState.settings.save_cover_separately ? '+ separate cover files' : '';
    
    const confirmed = confirm(
        `Download ${total} selected tracks?\n\n` +
        `Format: ${mp3Status} ${embedStatus}\n` +
        `Options: ${separateStatus}\n` +
        `Output: ${outputDir}/\n\n` +
        `Start download?`
    );
    
    if (!confirmed) return;
    
    appState.isDownloading = true;
    
    // Disable buttons
    document.querySelectorAll('.btn:not(#loadMoreBtn)').forEach(btn => {
        btn.disabled = true;
    });
    
    updateStatus('loading', `Downloading... (0/${total})`);
    if (mainProgressBar) mainProgressBar.style.width = '0%';
    if (progressStats) progressStats.textContent = `0/${total} |  0 |  0`;
    addLog(` Starting download of ${total} tracks...`, 'info');
    addLog(` Settings: ${mp3Status}, ${embedStatus} ${separateStatus}`, 'info');
    
    let completed = 0;
    let failed = 0;
    
    for (let i = 0; i < validSelectedIndices.length; i++) {
        const trackIndex = validSelectedIndices[i];
        const track = appState.tracks[trackIndex];
        
        addLog(` Downloading: ${track.artist} - ${track.title}...`, 'info');
        
        try {
            if (window.pywebview && window.pywebview.api) {
                const result = await window.pywebview.api.download_track(trackIndex);
                if (result && result.success) {
                    completed++;
                    addLog(` ${result.message || 'Downloaded'}: ${track.artist} - ${track.title}`, 'success');
                    
                    appState.tracks[trackIndex].downloaded = true;
                    appState.selectedTracks.delete(trackIndex);
                } else {
                    failed++;
                    addLog(` ${result?.message || 'Failed'}: ${track.artist} - ${track.title}`, 'error');
                }
            } else {
                failed++;
                addLog(` API not available: ${track.artist} - ${track.title}`, 'error');
            }
        } catch (error) {
            failed++;
            addLog(` Error: ${track.artist} - ${track.title} (${error.message})`, 'error');
        }
        
        const progress = ((i + 1) / total) * 100;
        if (mainProgressBar) mainProgressBar.style.width = `${progress}%`;
        if (progressStats) progressStats.textContent = `${i + 1}/${total} |  ${completed} |  ${failed}`;
        updateStatus('loading', `Downloading... (${i + 1}/${total})`);
        
        if (i < validSelectedIndices.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }
    
    // Re-enable buttons
    document.querySelectorAll('.btn:not(#loadMoreBtn)').forEach(btn => {
        btn.disabled = false;
    });
    
    appState.isDownloading = false;
    updateStatus('connected', 'Download complete');
    addLog(` Download complete!  ${completed} successful,  ${failed} failed`, 'success');
    
    renderTracks();
    await loadDownloadedTracks();
    appState.selectedTracks.clear();
}

// ============================================
// DISCOVER SEARCH FUNCTIONS
// ============================================

function setDiscoverSearch(query) {
    if (discoverSearchInput) {
        discoverSearchInput.value = query;
    }
    performDiscoverSearch();
}

function handleDiscoverSearchKeyup(event) {
    if (event.key === 'Enter') {
        performDiscoverSearch();
    }
}

async function performDiscoverSearch() {
  if (!discoverSearchInput) return;
  
  const query = discoverSearchInput.value.trim();
  if (!query) {
      alert('Please enter a search term');
      return;
  }
  
  const searchBtn = document.getElementById('discoverSearchBtn');
  if (!searchBtn) return;
  
  // Show loading
  searchBtn.disabled = true;
  searchBtn.innerHTML = '<span></span> Searching...';
  if (discoverLoading) discoverLoading.style.display = 'flex';
  if (discoverResultsGrid) discoverResultsGrid.innerHTML = '';
  if (discoverResultsSection) discoverResultsSection.style.display = 'block';
  
  // Scroll to results
  if (discoverResultsSection) {
      discoverResultsSection.scrollIntoView({ behavior: 'smooth' });
  }
  
  try {
      if (window.pywebview && window.pywebview.api) {
          // Use combined search (Spotify + YouTube)
          const result = await window.pywebview.api.combined_music_search(query, 30);
          
          if (result.success) {
              discoverSearchResults = result.results || [];
              currentDiscoverQuery = query;
              
              // Update UI with detailed counts
              if (discoverSearchQuery) discoverSearchQuery.textContent = query;
              if (discoverResultCount) {
                  const spotifyCount = result.spotify_count || 0;
                  const youtubeCount = result.youtube_count || 0;
                  discoverResultCount.textContent = 
                      `${result.count || 0} results (${spotifyCount} Spotify, ${youtubeCount} YouTube)`;
              }
              
              // Render results
              renderEnhancedDiscoverResults(discoverSearchResults);
              
              addLog(` Found ${result.count || 0} tracks: ${result.spotify_count || 0} from Spotify, ${result.youtube_count || 0} from YouTube`, 'success');
          } else {
              if (discoverResultsGrid) {
                  discoverResultsGrid.innerHTML = `
                      <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                          <div style="font-size: 48px; margin-bottom: 20px;"></div>
                          <div style="font-size: 16px; margin-bottom: 10px;">No results found</div>
                          <div style="font-size: 14px; color: var(--text-secondary);">Try different keywords</div>
                          <div style="margin-top: 20px; font-size: 12px; color: var(--error);">${result.error || ''}</div>
                      </div>
                  `;
              }
              
              addLog(` Search failed: ${result.error || 'Unknown error'}`, 'error');
          }
      } else {
          if (discoverResultsGrid) {
              discoverResultsGrid.innerHTML = `
                  <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--error);">
                      <div style="font-size: 48px; margin-bottom: 20px;"></div>
                      <div style="font-size: 16px;">API not available</div>
                  </div>
              `;
          }
          addLog(' API not available', 'error');
      }
  } catch (error) {
      console.error('Error in discover search:', error);
      if (discoverResultsGrid) {
          discoverResultsGrid.innerHTML = `
              <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--error);">
                  <div style="font-size: 48px; margin-bottom: 20px;"></div>
                  <div style="font-size: 16px;">Search Error</div>
                  <div style="font-size: 14px; margin-top: 10px;">${error.message}</div>
              </div>
          `;
      }
      
      addLog(` Search error: ${error.message}`, 'error');
  } finally {
      searchBtn.disabled = false;
      searchBtn.innerHTML = '<span></span> Search Music';
      if (discoverLoading) discoverLoading.style.display = 'none';
  }
}

async function previewYouTubeTrack(track) {
    addLog(` Loading YouTube preview...`, 'info');
    
    try {
        const result = await window.pywebview.api.get_discover_streaming_url(track.youtube_url);
        
        if (result.success) {
            showStreamControlsForDiscover(track, result);
            
            // Auto-play
            setTimeout(() => {
                const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (playBtn) playBtn.click();
            }, 500);
        } else {
            alert('Could not load preview');
        }
    } catch (error) {
        console.error('Error previewing YouTube track:', error);
        alert('Preview error: ' + error.message);
    }
}

async function downloadSpotifyTrack(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const result = discoverSearchResults[index];
    if (result.source !== 'Spotify') return;
    
    const track = result.track;
    
    if (!confirm(`Download "${track.title}" by ${track.artist}?\n\nThis will search YouTube and download the track.`)) {
        return;
    }
    
    addLog(` Searching YouTube to download: ${track.artist} - ${track.title}`, 'info');
    
    try {
        // First find the track on YouTube
        const youtubeResults = await window.pywebview.api.search_youtube_music(
            `${track.artist} ${track.title} official audio`, 3
        );
        
        if (!youtubeResults || youtubeResults.length === 0) {
            alert('Could not find this track on YouTube for download');
            return;
        }
        
        // Use the first result (best match)
        const ytTrack = youtubeResults[0];
        
        // Download it
        const trackInfo = {
            title: track.title,
            artist: track.artist,
            album: track.album,
            duration: track.duration,
            thumbnail: track.thumbnail,
            youtube_url: ytTrack.youtube_url
        };
        
        addLog(` Downloading from YouTube: ${track.artist} - ${track.title}`, 'info');
        
        // Use the existing download function
        const downloadResult = await window.pywebview.api.download_track_from_youtube(trackInfo);
        
        if (downloadResult && downloadResult.success) {
            addLog(` Downloaded: ${track.artist} - ${track.title}`, 'success');
            await loadDownloadedTracks();
            alert(`Successfully downloaded:\n${track.artist} - ${track.title}`);
        } else {
            addLog(` Download failed: ${downloadResult?.error || 'Unknown error'}`, 'error');
            alert(`Download failed:\n${downloadResult?.error || 'Please try again'}`);
        }
        
    } catch (error) {
        console.error('Error downloading Spotify track:', error);
        addLog(` Download error: ${error.message}`, 'error');
        alert(`Download error: ${error.message}`);
    }
}

async function openSpotifyPlaylist(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const result = discoverSearchResults[index];
    if (result.type !== 'spotify_playlist') return;
    
    const playlist = result.playlist;
    
    addLog(` Loading playlist: ${playlist.name}`, 'info');
    
    // Show loading modal
    const modal = document.createElement('div');
    modal.id = 'playlistModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    `;
    
    modal.innerHTML = `
        <div style="background: var(--bg-card); border-radius: 12px; padding: 30px; width: 900px; max-width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 30px;">
                <div style="width: 120px; height: 120px; background: var(--bg-secondary); border-radius: 12px; overflow: hidden; flex-shrink: 0;">
                    ${playlist.thumbnail ? 
                      `<img src="${playlist.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` :
                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;"></div>'
                    }
                </div>
                <div style="flex: 1;">
                    <h2 style="margin: 0 0 10px 0;">${playlist.name}</h2>
                    <div style="color: var(--text-secondary); margin-bottom: 10px;">by ${playlist.owner}</div>
                    <div style="color: var(--text-muted); font-size: 14px;">${playlist.total_tracks} tracks</div>
                    ${playlist.description ? `<div style="color: var(--text-secondary); font-size: 13px; margin-top: 10px;">${playlist.description}</div>` : ''}
                </div>
                <button onclick="closePlaylistModal()" style="position: absolute; top: 15px; right: 15px; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 24px; padding: 5px;">
                    
                </button>
            </div>
            
            <div style="text-align: center; padding: 40px;">
                <div class="loading-spinner" style="margin: 0 auto 15px;"></div>
                <div>Loading tracks...</div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    try {
        // Get playlist tracks
        const tracks = await window.pywebview.api.get_playlist_tracks(playlist.id, 100);
        
        if (!tracks || tracks.length === 0) {
            modal.querySelector('div[style*="text-align: center"]').innerHTML = `
                <div style="color: var(--error);">Could not load playlist tracks</div>
            `;
            return;
        }
        
        // Render tracks
        const tracksHtml = tracks.map((track, trackIndex) => `
            <div style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(--border); gap: 15px;">
                <div style="width: 50px; height: 50px; background: var(--bg-secondary); border-radius: 8px; overflow: hidden; flex-shrink: 0;">
                    ${track.thumbnail ? 
                      `<img src="${track.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` :
                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:20px;"></div>'
                    }
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${track.title}</div>
                    <div style="color: var(--text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${track.artist}</div>
                </div>
                <div style="color: var(--text-muted); font-size: 12px; margin-right: 10px;">
                    ${track.duration_str}
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-small btn-info" onclick='playPlaylistTrack(${trackIndex})'>
                        
                    </button>
                    <button class="btn btn-small btn-success" onclick='downloadPlaylistTrack(${trackIndex})'>
                        
                    </button>
                </div>
            </div>
        `).join('');
        
        modal.querySelector('div[style*="text-align: center"]').outerHTML = `
            <div style="margin-bottom: 20px;">
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-success" onclick="downloadAllPlaylistTracks()">
                        <span></span> Download All ${tracks.length} Tracks
                    </button>
                </div>
            </div>
            <div id="playlistTracksContainer" style="max-height: 400px; overflow-y: auto;">
                ${tracksHtml}
            </div>
        `;
        
        // Store tracks globally
        window.currentPlaylistTracks = tracks;
        window.currentPlaylistId = playlist.id;
        
        addLog(` Loaded ${tracks.length} tracks from playlist`, 'success');
        
    } catch (error) {
        console.error('Error loading playlist tracks:', error);
        modal.querySelector('div[style*="text-align: center"]').innerHTML = `
            <div style="color: var(--error);">Error: ${error.message}</div>
        `;
    }
}

function closePlaylistModal() {
    const modal = document.getElementById('playlistModal');
    if (modal) modal.remove();
    document.body.style.overflow = 'auto';
    window.currentPlaylistTracks = null;
    window.currentPlaylistId = null;
}

async function playPlaylistTrack(trackIndex) {
    if (!window.currentPlaylistTracks || trackIndex >= window.currentPlaylistTracks.length) return;
    
    const track = window.currentPlaylistTracks[trackIndex];
    
    // Create temporary result
    const tempResult = {
        type: 'spotify_track',
        track: track,
        source: 'Spotify'
    };
    
    const tempIndex = discoverSearchResults.length;
    discoverSearchResults.push(tempResult);
    
    await previewSpotifyTrack(tempIndex);
}

async function downloadPlaylistTrack(trackIndex) {
    if (!window.currentPlaylistTracks || trackIndex >= window.currentPlaylistTracks.length) return;
    
    const track = window.currentPlaylistTracks[trackIndex];
    
    const tempResult = {
        type: 'spotify_track',
        track: track,
        source: 'Spotify'
    };
    
    const tempIndex = discoverSearchResults.length;
    discoverSearchResults.push(tempResult);
    
    await downloadSpotifyTrack(tempIndex);
}

async function downloadAllPlaylistTracks() {
    if (!window.currentPlaylistTracks || window.currentPlaylistTracks.length === 0) {
        alert('No tracks to download');
        return;
    }
    
    const tracks = window.currentPlaylistTracks;
    
    if (!confirm(`Download all ${tracks.length} tracks from this playlist?\n\nThis may take a while.`)) {
        return;
    }
    
    closePlaylistModal();
    
    addLog(` Starting download of ${tracks.length} playlist tracks...`, 'info');
    
    let downloaded = 0;
    let failed = 0;
    
    for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        addLog(` [${i+1}/${tracks.length}] Downloading: ${track.artist} - ${track.title}`, 'info');
        
        try {
            const youtubeResults = await window.pywebview.api.search_youtube_music(
                `${track.artist} ${track.title} official audio`, 1
            );
            
            if (youtubeResults && youtubeResults.length > 0) {
                const trackInfo = {
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration,
                    thumbnail: track.thumbnail,
                    youtube_url: youtubeResults[0].youtube_url
                };
                
                const result = await window.pywebview.api.download_track_from_youtube(trackInfo);
                
                if (result && result.success) {
                    downloaded++;
                    addLog(` [${i+1}/${tracks.length}] ${track.artist} - ${track.title}`, 'success');
                } else {
                    failed++;
                    addLog(` [${i+1}/${tracks.length}] Failed: ${track.artist} - ${track.title}`, 'error');
                }
            } else {
                failed++;
                addLog(` [${i+1}/${tracks.length}] Not found: ${track.artist} - ${track.title}`, 'error');
            }
        } catch (error) {
            failed++;
            addLog(` [${i+1}/${tracks.length}] Error: ${track.artist} - ${track.title}`, 'error');
        }
        
        const progress = ((i + 1) / tracks.length) * 100;
        if (mainProgressBar) mainProgressBar.style.width = `${progress}%`;
        if (progressStats) progressStats.textContent = `${i + 1}/${tracks.length} |  ${downloaded} |  ${failed}`;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    addLog(` Playlist download complete!  ${downloaded} successful,  ${failed} failed`, 'success');
    await loadDownloadedTracks();
}

function playAllPlaylistTracks() {
    alert('Play all feature - coming soon! Use individual track play buttons for now.');
}

function renderDiscoverResults(results) {
    const container = document.getElementById('discoverResultsGrid');
    if (!container) return;
    
    if (!results || results.length === 0) {
        container.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                No results to display
            </div>
        `;
        return;
    }
    
    container.innerHTML = results.map((track, index) => {
        const viewCount = track.view_count ? formatViewCount(track.view_count) : '';
        const uploader = track.uploader ? track.uploader.substring(0, 20) : 'YouTube';
        
        return `
        <div class="discover-track-card">
            <div class="discover-track-badge">YouTube</div>
            
            <div class="discover-track-thumbnail">
                ${track.thumbnail ? 
                  `<img src="${track.thumbnail}" alt="${track.title}" onerror="this.onerror=null; this.src='';">` :
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;color:var(--text-muted);"></div>'
                }
            </div>
            
            <div class="discover-track-info">
                <div class="discover-track-title" title="${track.title}">${track.title}</div>
                <div class="discover-track-artist" title="${track.artist}">${track.artist}</div>
            </div>
            
            <div class="discover-track-meta">
                <div>
                    <span title="Duration"> ${track.duration_str || '0:00'}</span>
                    ${viewCount ? 
                      `<span style="margin-left: 10px;" title="Views"> ${viewCount}</span>` : 
                      ''
                    }
                </div>
                <div>${uploader}</div>
            </div>
            
            <div class="discover-track-actions">
                <button class="btn btn-info" onclick="previewDiscoveredTrack(${index})">
                    <span></span> Preview
                </button>
                <button class="btn btn-success" onclick="downloadDiscoveredTrack(${index})">
                    <span></span> Download
                </button>
            </div>
        </div>
        `;
    }).join('');
}

function formatViewCount(views) {
    if (views >= 1000000) {
        return (views / 1000000).toFixed(1) + 'M';
    } else if (views >= 1000) {
        return (views / 1000).toFixed(1) + 'K';
    }
    return views.toString();
}

// ============================================
// DISCOVER STREAMING FUNCTIONS
// ============================================

async function previewDiscoveredTrack(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const result = discoverSearchResults[index];
    
    // Handle the new structure from combined_music_search
    let track;
    if (result.type === 'youtube' && result.track) {
        // New structure: { type: 'youtube', track: {...}, source: 'YouTube' }
        track = result.track;
    } else if (result.track) {
        // Also handle Spotify structure
        track = result.track;
    } else {
        // Old structure: track data directly in result
        track = result;
    }
    
    console.log('Preview track:', track);
    
    if (!track.youtube_url) {
        console.error('No YouTube URL found:', track);
        alert('Cannot preview: No YouTube URL available');
        return;
    }
    
    addLog(` Loading preview for: ${track.artist} - ${track.title}`, 'info');
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const streamResult = await window.pywebview.api.get_discover_streaming_url(track.youtube_url);
            
            if (streamResult && streamResult.success) {
                showStreamControlsForDiscover(track, streamResult);
            } else {
                showDiscoverPreview(track, streamResult);
            }
        } else {
            showDiscoverPreview(track, {});
        }
    } catch (error) {
        console.error('Error previewing discovered track:', error);
        addLog(` Preview error: ${error.message}`, 'error');
        showDiscoverPreview(track, { error: error.message });
    }
}

// Find this function in your code and replace it:

function renderEnhancedDiscoverResults(results) {
    const container = document.getElementById('discoverResultsGrid');
    if (!container) return;
    
    if (!results || results.length === 0) {
        container.innerHTML = '<div class="no-content"><div class="no-content-icon"></div><div class="no-content-text">No results found</div></div>';
        return;
    }
    
    container.innerHTML = '';
    container.style.display = 'grid';
    container.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
    container.style.gap = '16px';
    
    results.forEach((result, index) => {
        const type = result.type;
        
        if (type === 'spotify_playlist') {
            const playlist = result.playlist;
            const playlistCard = document.createElement('div');
            playlistCard.style.cssText = `
                background: var(--bg-card);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 12px;
                transition: all 0.2s ease;
                cursor: pointer;
                position: relative;
            `;
            
            playlistCard.onclick = () => openSpotifyPlaylist(index);
            
            playlistCard.innerHTML = `
                <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: var(--bg-secondary); margin-bottom: 12px;">
                    ${playlist.thumbnail ? 
                      `<img src="${playlist.thumbnail}" alt="${playlist.name}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                    }
                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;">
                        <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                            <polygon points="8 5 19 12 8 19 8 5"/>
                        </svg>
                    </div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${playlist.name}
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${playlist.total_tracks} tracks
                    </div>
                </div>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                            onclick="event.stopPropagation(); downloadSpotifyPlaylist(${index})">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px; color: var(--text-primary);">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    </button>
                </div>
            `;
            
            playlistCard.addEventListener('mouseenter', () => {
                playlistCard.style.transform = 'translateY(-2px)';
                playlistCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                playlistCard.querySelector('div[style*="opacity: 0"]').style.opacity = '1';
            });
            
            playlistCard.addEventListener('mouseleave', () => {
                playlistCard.style.transform = 'translateY(0)';
                playlistCard.style.boxShadow = 'none';
                playlistCard.querySelector('div[style*="opacity: 1"]').style.opacity = '0';
            });
            
            container.appendChild(playlistCard);
        } else {
            const track = result.track;
            const isSpotify = type === 'spotify_track';
            
            const trackCard = document.createElement('div');
            trackCard.style.cssText = `
                background: var(--bg-card);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 12px;
                transition: all 0.2s ease;
                cursor: pointer;
                position: relative;
            `;
            
            trackCard.onclick = () => {
                if (isSpotify) {
                    previewSpotifyTrack(index);
                } else {
                    previewDiscoveredTrack(index);
                }
            };
            
            trackCard.innerHTML = `
                <div style="width: 100%; aspect-ratio: 1; border-radius: 6px; overflow: hidden; position: relative; background: var(--bg-secondary); margin-bottom: 12px;">
                    ${track.thumbnail ? 
                      `<img src="${track.thumbnail}" alt="${track.title}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                    }
                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;">
                        <svg viewBox="0 0 24 24" fill="white" style="width: 32px; height: 32px;">
                            <polygon points="8 5 19 12 8 19 8 5"/>
                        </svg>
                    </div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${track.title}
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${track.artist}
                    </div>
                </div>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                            onclick="event.stopPropagation(); ${isSpotify ? 'downloadSpotifyTrack' : 'downloadDiscoveredTrack'}(${index})">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px; color: var(--text-primary);">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    </button>
                </div>
            `;
            
            trackCard.addEventListener('mouseenter', () => {
                trackCard.style.transform = 'translateY(-2px)';
                trackCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                trackCard.querySelector('div[style*="opacity: 0"]').style.opacity = '1';
            });
            
            trackCard.addEventListener('mouseleave', () => {
                trackCard.style.transform = 'translateY(0)';
                trackCard.style.boxShadow = 'none';
                trackCard.querySelector('div[style*="opacity: 1"]').style.opacity = '0';
            });
            
            container.appendChild(trackCard);
        }
    });
}

// ============================================
// UNIVERSAL DOWNLOAD FUNCTION - WORKS EVERYWHERE
// ============================================

/**
 * Universal download function that works for any streaming track
 * Can be called from:
 * - Stream controls
 * - Discover results
 * - Recommendations
 * - Playlists
 * - Artist pages
 * - Anywhere a track is playing
 */
async function downloadCurrentStreamingTrack() {
    try {
        // Get track from global streaming track variable
        const track = window.currentStreamingTrack;
        
        if (!track) {
            addLog(' No track is currently streaming', 'error');
            alert('No track is currently streaming. Please play a track first.');
            return;
        }
        
        // Validate track data
        if (!track.title || !track.artist) {
            addLog(' Invalid track data - missing title or artist', 'error');
            alert('Invalid track data. Please try playing the track again.');
            return;
        }
        
        // Confirm download
        if (!confirm(`Download "${track.title}" by ${track.artist}?\n\nThis will save the track to your downloads folder.`)) {
            return;
        }
        
        addLog(` Starting download: ${track.artist} - ${track.title}`, 'info');
        
        // Prepare track info for download
        const trackInfo = {
            title: track.title,
            artist: track.artist,
            album: track.album || 'Unknown Album',
            duration: track.duration || 0,
            thumbnail: track.thumbnail,
            youtube_url: track.youtube_url || track.url,
            source: track.source || 'stream'
        };
        
        // Validate YouTube URL
        if (!trackInfo.youtube_url) {
            addLog(' No YouTube URL found for this track', 'error');
            alert('Cannot download: No YouTube URL available for this track.');
            return;
        }
        
        // Call backend download function
        const result = await window.pywebview.api.download_track_from_youtube(trackInfo);
        
        if (result && result.success) {
            addLog(` Downloaded: ${track.artist} - ${track.title}`, 'success');
            
            // Refresh downloaded tracks
            if (typeof loadDownloadedTracks === 'function') {
                await loadDownloadedTracks();
            }
            
            // Show success notification
            showNotification(`Successfully downloaded: ${track.title}`, 'success');
        } else {
            const errorMsg = result?.error || 'Unknown error';
            addLog(` Download failed: ${errorMsg}`, 'error');
            alert(`Download failed:\n${errorMsg}`);
        }
        
    } catch (error) {
        console.error('Error downloading track:', error);
        addLog(` Download error: ${error.message}`, 'error');
        alert(`Download error: ${error.message}`);
    }
}

/**
 * Download track by providing track data directly
 * Useful when you have the track object but it's not currently streaming
 */
async function downloadTrackByData(trackData) {
    try {
        if (!trackData || !trackData.title || !trackData.artist) {
            addLog(' Invalid track data', 'error');
            alert('Invalid track data provided.');
            return;
        }
        
        if (!confirm(`Download "${trackData.title}" by ${trackData.artist}?`)) {
            return;
        }
        
        addLog(` Starting download: ${trackData.artist} - ${trackData.title}`, 'info');
        
        // Prepare track info
        const trackInfo = {
            title: trackData.title,
            artist: trackData.artist,
            album: trackData.album || 'Unknown Album',
            duration: trackData.duration || 0,
            thumbnail: trackData.thumbnail,
            youtube_url: trackData.youtube_url || trackData.url,
            source: trackData.source || 'direct'
        };
        
        // If no YouTube URL, search for it
        if (!trackInfo.youtube_url) {
            addLog(` Searching YouTube for: ${trackData.artist} - ${trackData.title}`, 'info');
            
            const searchQuery = `${trackData.artist} ${trackData.title} official audio`;
            const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 1);
            
            if (youtubeResults && youtubeResults.length > 0) {
                trackInfo.youtube_url = youtubeResults[0].youtube_url;
                addLog(` Found on YouTube`, 'success');
            } else {
                addLog(` Could not find on YouTube`, 'error');
                alert('Could not find this track on YouTube for download.');
                return;
            }
        }
        
        // Download
        const result = await window.pywebview.api.download_track_from_youtube(trackInfo);
        
        if (result && result.success) {
            addLog(` Downloaded: ${trackData.artist} - ${trackData.title}`, 'success');
            
            if (typeof loadDownloadedTracks === 'function') {
                await loadDownloadedTracks();
            }
            
            showNotification(`Successfully downloaded: ${trackData.title}`, 'success');
        } else {
            const errorMsg = result?.error || 'Unknown error';
            addLog(` Download failed: ${errorMsg}`, 'error');
            alert(`Download failed:\n${errorMsg}`);
        }
        
    } catch (error) {
        console.error('Error downloading track:', error);
        addLog(` Download error: ${error.message}`, 'error');
        alert(`Download error: ${error.message}`);
    }
}

/**
 * Legacy function - now redirects to universal function
 * Kept for backward compatibility
 */
async function downloadDiscoveredTrack(index) {
    try {
        // If we have a valid index and discover results, use them
        if (index >= 0 && discoverSearchResults && discoverSearchResults.length > index) {
            const result = discoverSearchResults[index];
            const track = result.track || result;
            return await downloadTrackByData(track);
        }
        
        // Otherwise, try to download current streaming track
        return await downloadCurrentStreamingTrack();
        
    } catch (error) {
        console.error('Error in downloadDiscoveredTrack:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

/**
 * Helper function to show success notifications
 */
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: ${type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--error)' : 'var(--bg-card)'};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        font-weight: 500;
        max-width: 300px;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// ============================================
// COMPLETE FIXED showStreamControlsForDiscover FUNCTION
// ============================================

function showStreamControlsForDiscover(track, streamInfo) {
    const existingControls = document.getElementById('streamControls');
    if (existingControls) {
        existingControls.remove();
    }
    
    // IMPORTANT: Set global streaming track for universal download
    window.currentStreamingTrack = track;
    
    const streamControls = document.createElement('div');
    streamControls.id = 'streamControls';
    streamControls.style.cssText = `
        position: fixed;
        bottom: 120px;
        right: 20px;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 20px;
        width: 380px;
        max-width: 90vw;
        z-index: 1001;
        box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        backdrop-filter: blur(10px);
    `;
    
    const thumbnail = streamInfo.thumbnail || track.thumbnail;
    
    streamControls.innerHTML = `
        <!-- Track Info -->
        <div style="display: flex; align-items: flex-start; gap: 15px; margin-bottom: 20px;">
            <div style="width: 64px; height: 64px; background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%); border-radius: 8px; overflow: hidden; flex-shrink: 0; position: relative;">
                ${thumbnail ? 
                  `<img src="${thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="Cover">` :
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>'
                }
            </div>
            <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 600; font-size: 15px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 5px;" id="streamTrackTitle">${track.title}</div>
                <div style="color: var(--text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 8px;" id="streamTrackArtist">${track.artist}</div>
                <div style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: var(--text-muted);">
                    <span id="streamCurrentTime">0:00</span>
                    <span>/</span>
                    <span id="streamTotalTime">${track.duration_str || '0:00'}</span>
                </div>
            </div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 20px;">
            <div style="position: relative; cursor: pointer; margin-bottom: 5px;" id="streamProgressBar" onclick="handleDiscoverProgressClick(event)">
                <div style="width: 100%; height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                    <div id="streamProgressFill" style="width: 0%; height: 100%; background: white; border-radius: 2px;"></div>
                </div>
                <div id="streamProgressHandle" style="position: absolute; top: 50%; left: 0%; transform: translate(-50%, -50%); width: 12px; height: 12px; background: white; border-radius: 50%; transition: all 0.2s; opacity: 0; box-shadow: 0 0 0 2px var(--bg-card);"></div>
            </div>
        </div>
        
        <!-- Playback Controls -->
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
            <button onclick="streamDiscoverPlayPause()" id="streamDiscoverPlayPauseBtn" 
                    style="width: 40px; height: 40px; border-radius: 50%; border: none; background: var(--accent-color); color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s;">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                    <polygon id="streamPlayIcon" points="8 5 19 12 8 19 8 5"/>
                    <g id="streamPauseIcon" style="display: none;">
                        <rect x="6" y="5" width="4" height="14"/>
                        <rect x="14" y="5" width="4" height="14"/>
                    </g>
                </svg>
            </button>
            
            <button onclick="stopDiscoverStream()" 
                    style="width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s;">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px;">
                    <rect x="4" y="4" width="16" height="16"/>
                </svg>
            </button>
            
            <button onclick="toggleStreamingLike(this)" id="streamLikeBtn" 
                    style="width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
            </button>
            
            <!-- Volume Control -->
            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; color: var(--text-secondary); flex-shrink: 0;">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
                <input type="range" min="0" max="100" value="70" oninput="setDiscoverStreamVolume(this.value / 100)" 
                       style="flex: 1; height: 4px; background: var(--border-color); border-radius: 2px; appearance: none; cursor: pointer;">
                <span id="streamVolumeValue" style="font-size: 12px; color: var(--text-secondary); min-width: 32px; flex-shrink: 0;">70%</span>
            </div>
        </div>
        
        <!-- Action Buttons (UPDATED) -->
        <div style="display: flex; gap: 10px;">
            <button onclick="downloadCurrentStreamingTrack()" 
                    style="flex: 1; padding: 10px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; transition: all 0.2s; font-size: 13px; font-weight: 500;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                Download
            </button>
            
            <!-- NEW FIND SIMILAR BUTTON -->
            <button onclick="openSimilarTracksModalFromStream()" 
                    style="flex: 1; padding: 10px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; transition: all 0.2s; font-size: 13px; font-weight: 500;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                Find Similar
            </button>

            <button onclick="closeDiscoverStreamControls()" 
                    style="flex: 1; padding: 10px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; transition: all 0.2s; font-size: 13px; font-weight: 500;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
                Close
            </button>
        </div>
        
        <!-- Close Button (Top Right) -->
        <button onclick="closeDiscoverStreamControls()" 
                style="position: absolute; top: 10px; right: 10px; width: 28px; height: 28px; border-radius: 50%; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px;">
                <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
        </button>
    `;
    
    document.body.appendChild(streamControls);
    
    // Check if this streaming track is already liked
    setTimeout(async () => {
        try {
            const likeCheck = await window.pywebview.api.is_track_liked(track.artist, track.title);
            const likeBtn = document.getElementById('streamLikeBtn');
            if (likeBtn) {
                if (likeCheck.success && likeCheck.is_liked) {
                    likeBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="var(--error-color)" style="width: 16px; height: 16px;">
                            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                        </svg>
                    `;
                    likeBtn.style.borderColor = 'var(--error-color)';
                    likeBtn.style.background = 'var(--error-color)';
                } else {
                    likeBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                        </svg>
                    `;
                }
            }
        } catch (e) {
            console.log('Error checking like status for stream:', e);
        }
    }, 100);
    
    // Initialize volume slider
    const volumeSlider = streamControls.querySelector('input[type="range"]');
    if (volumeSlider) {
        volumeSlider.style.background = `linear-gradient(to right, var(--accent-color) 70%, var(--border-color) 70%)`;
        volumeSlider.addEventListener('input', function() {
            this.style.background = `linear-gradient(to right, var(--accent-color) ${this.value}%, var(--border-color) ${this.value}%)`;
        });
        
        // Add hover effect
        volumeSlider.addEventListener('mouseenter', function() {
            this.style.height = '6px';
        });
        
        volumeSlider.addEventListener('mouseleave', function() {
            this.style.height = '4px';
        });
    }
    
    // Add hover effects to buttons
    const buttons = streamControls.querySelectorAll('button');
    buttons.forEach(btn => {
        btn.addEventListener('mouseenter', function() {
            if (!this.style.background.includes('var(--accent-color)') && !this.style.background.includes('var(--error-color)')) {
                this.style.background = 'var(--bg-hover)';
                this.style.borderColor = 'var(--text-muted)';
            }
        });
        
        btn.addEventListener('mouseleave', function() {
            if (!this.style.background.includes('var(--accent-color)') && !this.style.background.includes('var(--error-color)')) {
                this.style.background = 'var(--bg-secondary)';
                this.style.borderColor = 'var(--border-color)';
            }
        });
    });
    
    // Initialize progress bar hover
    const progressBar = document.getElementById('streamProgressBar');
    const progressHandle = document.getElementById('streamProgressHandle');
    
    if (progressBar && progressHandle) {
        progressBar.addEventListener('mouseenter', () => {
            progressHandle.style.opacity = '1';
            progressHandle.style.transform = 'translate(-50%, -50%) scale(1.2)';
        });
        
        progressBar.addEventListener('mouseleave', () => {
            progressHandle.style.opacity = '0';
            progressHandle.style.transform = 'translate(-50%, -50%) scale(1)';
        });
        
        // Add hover effect to progress bar
        progressBar.addEventListener('mouseenter', function() {
            this.querySelector('div[style*="background: var(--border-color)"]').style.height = '6px';
        });
        
        progressBar.addEventListener('mouseleave', function() {
            this.querySelector('div[style*="background: var(--border-color)"]').style.height = '4px';
        });
    }
    
    // Store track info for streaming
    currentDiscoverStream = {
        url: streamInfo.stream_url,
        title: track.title,
        artist: track.artist,
        duration: track.duration || 0,
        duration_str: track.duration_str || '0:00'
    };
    
    // Initialize audio
    if (streamInfo.stream_url) {
        streamAudio = new Audio();
        streamAudio.src = streamInfo.stream_url;
        streamAudio.volume = 0.7;
        
        // Set up event listeners
        streamAudio.addEventListener('loadedmetadata', () => {
            const duration = streamAudio.duration;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            const totalTimeEl = document.getElementById('streamTotalTime');
            if (totalTimeEl) {
                totalTimeEl.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            }
            currentDiscoverStream.duration = duration;
        });
        
        streamAudio.addEventListener('timeupdate', updateDiscoverStreamProgress);
        streamAudio.addEventListener('ended', stopDiscoverStream);
        
        // Start progress update interval
        if (streamProgressInterval) clearInterval(streamProgressInterval);
        streamProgressInterval = setInterval(updateDiscoverStreamProgress, 100);
    }
}
// NEW FUNCTION TO HANDLE FIND SIMILAR FROM STREAM CONTROLS
function openSimilarTracksModalFromStream() {
    // We use the track currently being streamed
    const track = window.currentStreamingTrack;
    
    if (!track) {
        console.error('No current streaming track found');
        return;
    }

    // Strategy: Since this track is from Search/Discover and might not be in Library,
    // we will perform a "Similarity Search" on YouTube.
    
    // Search Query: Artist + "Similar to [Song Name]"
    // This finds other songs by the artist or covers/remixes of the song.
    const searchQuery = `${track.artist} songs similar to ${track.title}`;
    
    console.log(`[Similar] Searching YouTube for: ${searchQuery}`);
    
    // Close stream controls first to avoid UI clutter
    closeDiscoverStreamControls();
    
    // Show loading indicator (reuse the professional one we built earlier)
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'audioLoadingIndicator';
    loadingDiv.className = 'active';
    loadingDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #000000;
        padding: 50px 60px;
        border-radius: 0px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 25px;
        text-align: center;
    `;

    loadingDiv.innerHTML = `
        <div style="width: 40px; height: 40px; border:3px solid rgba(255,255,255,0.2); border-top: 3px solid #ffffff; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
        <div style="font-size: 16px; font-weight: 700; color: #ffffff; text-transform: uppercase; letter-spacing: 2px;">Finding Similar Tracks</div>
        <div style="font-size: 13px; color: rgba(255,255,255,0.5); font-weight: 400;">Looking for alternatives</div>
        <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style>
    `;
    document.body.appendChild(loadingDiv);

    // Perform the search
    performDiscoverSearchWithQuery(searchQuery).then(() => {
        // Once search completes, remove loader
        const loader = document.getElementById('audioLoadingIndicator');
        if (loader) loader.remove();
    });
}

// Helper function to run search programmatically
async function performDiscoverSearchWithQuery(query) {
    // 1. Set input value
    if (discoverSearchInput) {
        discoverSearchInput.value = query;
    }
    
    // 2. Switch to Discover Tab
    showTab('discover');
    
    // 3. Wait for tab to render (small delay)
    await new Promise(r => setTimeout(r, 100));
    
    // 4. Trigger Search
    await performDiscoverSearch();
}

// Updated streaming functions with proper icons
function streamDiscoverPlayPause() {
    if (!streamAudio) return;
    
    const btn = document.getElementById('streamDiscoverPlayPauseBtn');
    const playIcon = document.getElementById('streamPlayIcon');
    const pauseIcon = document.getElementById('streamPauseIcon');
    
    if (!btn || !playIcon || !pauseIcon) return;
    
    if (streamAudio.paused) {
        streamAudio.play().then(() => {
            // Show pause icon
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
            btn.style.background = 'var(--accent-color)';
            
            addLog(` Streaming: ${currentDiscoverStream.artist} - ${currentDiscoverStream.title}`, 'success');
        }).catch(error => {
            console.error('Play error:', error);
            
            // If streaming fails, open YouTube in browser
            const track = discoverSearchResults.find(t => 
                t.title === currentDiscoverStream.title && 
                t.artist === currentDiscoverStream.artist
            );
            
            if (track && track.youtube_url) {
                if (confirm('Streaming failed. Open in YouTube instead?')) {
                    window.open(track.youtube_url, '_blank');
                }
            }
        });
    } else {
        streamAudio.pause();
        // Show play icon
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        btn.style.background = 'var(--accent-color)';
    }
}

// Updated toggle streaming like function
async function toggleStreamingLike(element) {
    if (!window.currentStreamingTrack) return;
    
    try {
        const track = window.currentStreamingTrack;
        
        if (!track.title || !track.artist) {
            addLog(' Cannot like: Invalid track data', 'warning');
            return;
        }
        
        // Check current like status
        const checkResult = await window.pywebview.api.is_track_liked(track.artist, track.title);
        
        if (checkResult.success && checkResult.is_liked) {
            // UNLIKE the track
            const unlikeResult = await window.pywebview.api.unlike_track(checkResult.track.track_id);
            if (unlikeResult.success) {
                // Update button
                element.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                `;
                element.style.borderColor = 'var(--border-color)';
                element.style.background = 'var(--bg-secondary)';
                element.style.color = 'var(--text-primary)';
                addLog(` Unliked: ${track.artist} - ${track.title}`, 'info');
                await loadLikedSongs();
            }
        } else {
            // LIKE the track
            const likeResult = await window.pywebview.api.like_track({
                title: track.title,
                artist: track.artist,
                album: track.album || 'Unknown Album',
                duration: track.duration || 0,
                thumbnail: track.thumbnail,
                source: 'discover',
                youtube_url: track.youtube_url,
                id: track.id || '',
                filepath: track.filepath
            });
            
            if (likeResult.success) {
                // Update button
                element.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="var(--error-color)" style="width: 16px; height: 16px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                `;
                element.style.borderColor = 'var(--error-color)';
                element.style.background = 'var(--error-color)';
                addLog(` ${likeResult.message}`, 'success');
                await loadLikedSongs();
            }
        }
        
        await refreshRecommendations();
        
    } catch (error) {
        console.error('Error toggling like:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

// Add hover effect to streaming controls
streamControls.addEventListener('mouseenter', () => {
    streamControls.style.boxShadow = '0 15px 50px rgba(0,0,0,0.2)';
    streamControls.style.transform = 'translateY(-2px)';
});

streamControls.addEventListener('mouseleave', () => {
    streamControls.style.boxShadow = '0 10px 40px rgba(0,0,0,0.15)';
    streamControls.style.transform = 'translateY(0)';
});

function setDiscoverStreamVolume(volume) {
    if (streamAudio) {
        volume = Math.max(0, Math.min(1, volume));
        streamAudio.volume = volume;
        
        const volumeValue = document.getElementById('streamVolumeValue');
        if (volumeValue) {
            volumeValue.textContent = `${Math.round(volume * 100)}%`;
        }
        
        const volumeSlider = document.querySelector('#streamControls input[type="range"]');
        if (volumeSlider) {
            volumeSlider.value = volume * 100;
            volumeSlider.style.background = `linear-gradient(to right, var(--success) ${volume * 100}%, var(--border) ${volume * 100}%)`;
        }
    }
}

function handleDiscoverProgressClick(event) {
    if (!streamAudio || isNaN(streamAudio.duration)) return;
    
    const progressBar = document.getElementById('streamProgressBar');
    if (!progressBar) return;
    
    const rect = progressBar.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const percentage = Math.min(1, Math.max(0, clickX / rect.width));
    const newTime = percentage * streamAudio.duration;
    
    streamAudio.currentTime = newTime;
    updateDiscoverStreamProgress();
}

function updateDiscoverStreamProgress() {
    if (!streamAudio || streamAudio.paused || isNaN(streamAudio.duration)) return;
    
    const currentTime = streamAudio.currentTime;
    const duration = streamAudio.duration;
    const percentage = (currentTime / duration) * 100;
    
    const progressFill = document.getElementById('streamProgressFill');
    const progressHandle = document.getElementById('streamProgressHandle');
    const currentTimeDisplay = document.getElementById('streamCurrentTime');
    
    if (progressFill) {
        progressFill.style.width = `${percentage}%`;
    }
    
    if (progressHandle) {
        progressHandle.style.left = `${percentage}%`;
    }
    
    if (currentTimeDisplay) {
        const minutes = Math.floor(currentTime / 60);
        const seconds = Math.floor(currentTime % 60);
        currentTimeDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    
    // Auto-stop when finished
    if (currentTime >= duration - 0.5 && duration > 0) {
        stopDiscoverStream();
    }
}

function stopDiscoverStream() {
    if (streamAudio) {
        streamAudio.pause();
        streamAudio.currentTime = 0;
        streamAudio = null;
    }
    
    if (streamProgressInterval) {
        clearInterval(streamProgressInterval);
        streamProgressInterval = null;
    }
    
    const progressFill = document.getElementById('streamProgressFill');
    const progressHandle = document.getElementById('streamProgressHandle');
    const currentTimeDisplay = document.getElementById('streamCurrentTime');
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressHandle) progressHandle.style.left = '0%';
    if (currentTimeDisplay) currentTimeDisplay.textContent = '0:00';
    
    const playPauseBtn = document.getElementById('streamDiscoverPlayPauseBtn');
    if (playPauseBtn) {
        playPauseBtn.innerHTML = '';
        playPauseBtn.style.background = 'var(--success)';
    }
}

function closeDiscoverStreamControls() {
    stopDiscoverStream();
    
    const streamControls = document.getElementById('streamControls');
    if (streamControls) {
        streamControls.remove();
    }
    
    currentDiscoverStream = null;
}

function showDiscoverPreview(track, streamInfo) {
    const modal = document.getElementById('discoverPreviewModal');
    const content = document.getElementById('discoverPreviewContent');
    
    if (!modal || !content) return;
    
    const thumbnail = streamInfo.thumbnail || track.thumbnail;
    
    content.innerHTML = `
        <div class="preview-track-header">
            <div class="preview-thumbnail">
                ${thumbnail ? 
                  `<img src="${thumbnail}" alt="${track.title}">` :
                  '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:64px;color:var(--text-muted);"></div>'
                }
            </div>
            <div class="preview-info">
                <div class="preview-title">${track.title}</div>
                <div class="preview-artist">${track.artist}</div>
                
                <div class="preview-stats">
                    <span> ${track.duration_str || '0:00'}</span>
                    ${streamInfo.view_count ? 
                      `<span> ${formatViewCount(streamInfo.view_count)} views</span>` : 
                      ''
                    }
                    ${streamInfo.upload_date ? 
                      `<span> ${formatDate(streamInfo.upload_date)}</span>` : 
                      ''
                    }
                </div>
                
                ${streamInfo.description ? `
                    <div class="preview-description">
                        ${streamInfo.description}
                    </div>
                ` : ''}
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    ${streamInfo.stream_url ? `
                        <button class="btn btn-primary" onclick="playDiscoveredStream('${encodeURIComponent(streamInfo.stream_url)}', '${encodeURIComponent(track.title)}', '${encodeURIComponent(track.artist)}')">
                            <span></span> Stream Now
                        </button>
                    ` : ''}
                    <button class="btn btn-success" onclick="downloadDiscoveredTrack(${discoverSearchResults.indexOf(track)})">
                        <span></span> Download
                    </button>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 25px; padding-top: 25px; border-top: 1px solid var(--border);">
            <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 15px;">
                Stream this track directly or download it to your library.
            </div>
        </div>
    `;
    
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
}

function formatDate(dateStr) {
    try {
        if (dateStr.length === 8) { // YYYYMMDD format
            const year = dateStr.substring(0, 4);
            const month = dateStr.substring(4, 6);
            const day = dateStr.substring(6, 8);
            return `${year}-${month}-${day}`;
        }
        return dateStr;
    } catch (e) {
        return dateStr;
    }
}

function closeDiscoverPreview() {
    const modal = document.getElementById('discoverPreviewModal');
    if (modal) {
        modal.style.display = 'none';
    }
    document.body.style.overflow = 'auto';
    
    // Stop any streaming
    closeDiscoverStreamControls();
}

async function addDiscoveredToPlaylist(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const track = discoverSearchResults[index];
    
    // Show playlist selection modal
    const playlists = appState.playlists;
    const playlistKeys = Object.keys(playlists);
    
    if (playlistKeys.length === 0) {
        if (confirm('No playlists found. Create a new playlist?')) {
            showCreatePlaylistModal();
        }
        return;
    }
    
    let playlistOptions = '';
    playlistKeys.forEach(key => {
        if (playlists[key].type !== 'system') {
            playlistOptions += `<option value="${key}">${playlists[key].name}</option>`;
        }
    });
    
    const playlistId = prompt(
        `Add "${track.title}" to which playlist?\n\n` +
        `Available playlists:\n${playlistKeys.map(k => ` ${playlists[k].name}`).join('\n')}\n\n` +
        `Enter playlist ID:`,
        playlistKeys.find(k => playlists[k].type !== 'system') || ''
    );
    
    if (playlistId && playlists[playlistId]) {
        try {
            const trackInfo = {
                title: track.title,
                artist: track.artist,
                duration: track.duration,
                duration_str: track.duration_str,
                thumbnail: track.thumbnail,
                source: 'discovered',
                youtube_url: track.youtube_url
            };
            
            if (window.pywebview && window.pywebview.api) {
                const result = await window.pywebview.api.add_to_playlist(playlistId, trackInfo);
                
                if (result.success) {
                    addLog(` Added to ${playlists[playlistId].name}: ${track.title}`, 'success');
                    alert(`Added to playlist: ${playlists[playlistId].name}`);
                } else {
                    addLog(` Failed to add to playlist`, 'error');
                }
            }
        } catch (error) {
            console.error('Error adding to playlist:', error);
            addLog(` Playlist error: ${error.message}`, 'error');
        }
    }
}

function clearDiscoverResults() {
    if (discoverResultsSection) discoverResultsSection.style.display = 'none';
    if (discoverSearchInput) discoverSearchInput.value = '';
    discoverSearchResults = [];
    currentDiscoverQuery = '';
    closeDiscoverStreamControls();
}

async function loadDiscoverPage() {
    // Load popular artists
    await loadPopularArtists();
    
    // Load most played (existing code)
    try {
        if (window.pywebview && window.pywebview.api) {
            const mostPlayed = await window.pywebview.api.get_most_played();
            renderMostPlayed(mostPlayed || []);
            
            // Load recommendations
            const recommendations = await window.pywebview.api.get_recommendations();
            renderRecommendations(recommendations || []);
            
            // Load genre explorer
            loadGenreExplorer();
        }
    } catch (error) {
        console.error('Error loading discover page:', error);
        addLog(` Error loading discover page: ${error.message}`, 'error');
    }
}

// Helper function to check if track is downloaded
async function isTrackDownloaded(trackTitle, trackArtist) {
    try {
        if (!window.pywebview || !window.pywebview.api) return false;
        
        const downloadedTracks = await window.pywebview.api.get_downloaded_tracks();
        
        // Exact match
        const exactMatch = downloadedTracks.find(track => 
            track.title.toLowerCase() === trackTitle.toLowerCase() && 
            track.artist.toLowerCase() === trackArtist.toLowerCase()
        );
        
        if (exactMatch) return true;
        
        // Partial match for better user experience
        const partialMatch = downloadedTracks.find(track => 
            track.title.toLowerCase().includes(trackTitle.toLowerCase()) || 
            track.artist.toLowerCase().includes(trackArtist.toLowerCase()) ||
            trackTitle.toLowerCase().includes(track.title.toLowerCase()) ||
            trackArtist.toLowerCase().includes(track.artist.toLowerCase())
        );
        
        return !!partialMatch;
    } catch (error) {
        console.error('Error checking if track is downloaded:', error);
        return false;
    }
}

// Updated version of renderRecommendations to show download status without duplicates
async function renderRecommendations(recommendations) {
    const container = document.getElementById('recommendationsGrid');
    if (!container) return;
    
    if (!recommendations || recommendations.length === 0) {
        container.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px;">
                <svg style="width: 48px; height: 48px; margin-bottom: 16px; color: var(--text-muted);" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M9 18V5l12-2v13"></path>
                    <circle cx="6" cy="18" r="3"></circle>
                    <circle cx="18" cy="16" r="3"></circle>
                </svg>
                <div style="font-size: 18px; font-weight: 500; color: var(--text-primary); margin-bottom: 8px;">
                    No recommendations yet
                </div>
                <div style="font-size: 14px; color: var(--text-muted);">
                    Like some tracks to get personalized recommendations
                </div>
            </div>
        `;
        return;
    }
    
    // Remove duplicates - keep only first occurrence of each track
    const uniqueTracks = [];
    const seenTracks = new Set();
    
    for (const track of recommendations) {
        const trackKey = `${track.artist.toLowerCase()}|${track.title.toLowerCase()}`;
        if (!seenTracks.has(trackKey)) {
            seenTracks.add(trackKey);
            uniqueTracks.push(track);
        }
    }
    
    // Also remove tracks that are already downloaded (optional - uncomment if you want)
    /*
    try {
        const downloadedTracks = await window.pywebview.api.get_downloaded_tracks();
        const downloadedSet = new Set();
        downloadedTracks.forEach(track => {
            downloadedSet.add(`${track.artist.toLowerCase()}|${track.title.toLowerCase()}`);
        });
        
        uniqueTracks = uniqueTracks.filter(track => {
            const trackKey = `${track.artist.toLowerCase()}|${track.title.toLowerCase()}`;
            return !downloadedSet.has(trackKey);
        });
    } catch (error) {
        console.error('Error filtering downloaded tracks:', error);
    }
    */
    
    let html = '';
    
    for (let i = 0; i < uniqueTracks.length; i++) {
        const track = uniqueTracks[i];
        
        // Check if track is already liked
        let isLiked = false;
        let likeBtnHtml = '';
        
        // Check if track is downloaded
        let isDownloaded = false;
        let playBtnIcon = '';
        let playBtnTitle = 'Stream from YouTube';
        
        try {
            // Check like status
            if (window.pywebview && window.pywebview.api) {
                const checkResult = await window.pywebview.api.is_track_liked(track.artist, track.title);
                if (checkResult.success && checkResult.is_liked) {
                    isLiked = true;
                }
                
                // Check download status
                const downloadedTracks = await window.pywebview.api.get_downloaded_tracks();
                isDownloaded = downloadedTracks.some(downloaded => 
                    downloaded.title.toLowerCase() === track.title.toLowerCase() && 
                    downloaded.artist.toLowerCase() === track.artist.toLowerCase()
                );
            }
        } catch (error) {
            console.error('Error checking track status:', error);
        }
        
        // Set play button based on download status
        if (isDownloaded) {
            playBtnIcon = `
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                    <polygon points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;
            playBtnTitle = 'Play downloaded file';
        } else {
            playBtnIcon = `
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
            `;
            playBtnTitle = 'Stream from YouTube';
        }
        
        // Like button HTML
        if (isLiked) {
            likeBtnHtml = `
                <button onclick="unlikeRecommendedTrack('${track.artist}', '${track.title}', this)" 
                        style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--error-color); background: var(--error-color); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                        title="Unlike track">
                    <svg viewBox="0 0 24 24" fill="white" style="width: 14px; height: 14px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </button>
            `;
        } else {
            likeBtnHtml = `
                <button onclick="likeRecommendedTrack(${i}, this, '${track.artist}', '${track.title}')" 
                        style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                        title="Like track">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </button>
            `;
        }
        
        html += `
            <div class="album-card">
                <div class="album-cover">
                    ${track.thumbnail ? 
                      `<img src="${track.thumbnail}" alt="${track.title}" style="width: 100%; height: 100%; object-fit: cover;">` : 
                      '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:var(--bg-secondary);"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="width: 48px; height: 48px; color: var(--text-muted);"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg></div>'
                    }
                    <button class="play-btn-overlay" onclick="playRecommendedTrack(${i})" title="${playBtnTitle}">
                        ${playBtnIcon}
                    </button>
                </div>
                <div class="album-title" title="${track.title}">${track.title}</div>
                <div class="album-artist" title="${track.artist}">${track.artist}</div>
                <div style="display: flex; gap: 8px; justify-content: center; margin-top: 12px;">
                    ${likeBtnHtml}
                    <button onclick="downloadRecommendedTrack(${i})" 
                            style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                            title="Download track">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 14px; height: 14px; color: var(--text-primary);">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    </button>
                    <button onclick="addRecommendedToPlaylist(${i})" 
                            style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; flex-shrink: 0;"
                            title="Add to playlist">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                            <path d="M12 5v14M5 12h14"/>
                        </svg>
                    </button>
                </div>
            </div>
        `;
    }
    
    container.innerHTML = html;
    
    // Store unique tracks for reference by index
    window.currentRecommendations = uniqueTracks;
}

// ========================================
// NOW PLAYING PROGRESS BAR FUNCTIONS
// ========================================

// Handle click on now playing progress bar
function handleNowPlayingProgressClick(event) {
    if (!appState.currentPlayingTrack || !appState.playbackDuration) {
        console.log('No track playing or no duration available');
        return;
    }
    
    const progressBar = document.getElementById('progressBar');
    if (!progressBar) return;
    
    const rect = progressBar.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const percentage = Math.max(0, Math.min(1, clickX / rect.width));
    const newPosition = percentage * appState.playbackDuration;
    
    console.log(`Seeking to: ${newPosition}s (${percentage * 100}%)`);
    
    // Update the playback position
    setPlaybackPosition(newPosition);
    
    // Update the progress bar immediately
    updateNowPlayingProgress();
}

// Update now playing progress bar
function updateNowPlayingProgress() {
    const currentTimeEl = document.getElementById('currentTime');
    const totalTimeEl = document.getElementById('totalTime');
    const progressFill = document.getElementById('progressFill');
    const progressThumb = document.querySelector('#progressBar .progress-thumb');

    updateFullscreenProgress();
    
    if (!appState.currentPlayingTrack) {
        // Reset to default state
        if (currentTimeEl) currentTimeEl.textContent = '0:00';
        if (totalTimeEl) totalTimeEl.textContent = '0:00';
        if (progressFill) progressFill.style.width = '0%';
        if (progressThumb) progressThumb.style.left = '0%';
        return;
    }
    
    // Calculate progress percentage
    const currentPosition = appState.playbackPosition || 0;
    const duration = appState.playbackDuration || 0;
    const percentage = duration > 0 ? (currentPosition / duration) * 100 : 0;
    
    // Ensure percentage stays within bounds
    const safePercentage = Math.max(0, Math.min(100, percentage));
    
    // Update time displays
    if (currentTimeEl) {
        currentTimeEl.textContent = formatTime(currentPosition);
    }
    
    if (totalTimeEl) {
        totalTimeEl.textContent = formatTime(duration);
    }
    
    // Update progress bar
    if (progressFill) {
        progressFill.style.width = `${safePercentage}%`;
    }
    
    // Update thumb position - position it at the same percentage as the fill
    if (progressThumb) {
        progressThumb.style.left = `${safePercentage}%`;
    }
}

// Enhanced startNowPlayingProgressUpdate that actually gets position from backend
async function startNowPlayingProgressUpdate() {
    // Clear any existing interval
    if (appState.nowPlayingProgressInterval) {
        clearInterval(appState.nowPlayingProgressInterval);
    }
    
    // Start new interval that fetches current position
    appState.nowPlayingProgressInterval = setInterval(async () => {
        if (appState.currentPlayingTrack && appState.isPlaying) {
            try {
                // Get current playback position from backend
                if (window.pywebview && window.pywebview.api && window.pywebview.api.get_current_position) {
                    const result = await window.pywebview.api.get_current_position();
                    
                    if (result && result.success) {
                        // Update playback position
                        appState.playbackPosition = result.position || 0;
                        
                        // If we don't have duration yet, try to get it
                        if (!appState.playbackDuration && result.duration) {
                            appState.playbackDuration = result.duration;
                        }
                        
                        // Update the progress bar
                        updateNowPlayingProgress();
                        
                        // Check if track finished
                        if (result.position >= appState.playbackDuration - 1 && appState.playbackDuration > 0) {
                            // Track finished, stop updates
                            stopNowPlayingProgressUpdate();
                            
                            // Reset play button
                            const playPauseBtn = document.getElementById('playPauseBtn');
                            if (playPauseBtn) {
                                playPauseBtn.classList.remove('playing');
                            }
                            
                            appState.isPlaying = false;
                            appState.playbackPosition = 0;
                            updateNowPlayingProgress();
                            
                            addLog(' Track finished playing', 'info');
                        }
                    }
                } else {
                    // Fallback: simulate progress if API not available
                    if (appState.playbackDuration > 0) {
                        appState.playbackPosition += 0.1; // Increment by 0.1 seconds
                        
                        if (appState.playbackPosition >= appState.playbackDuration) {
                            appState.playbackPosition = appState.playbackDuration;
                            stopNowPlayingProgressUpdate();
                        }
                        
                        updateNowPlayingProgress();
                    }
                }
            } catch (error) {
                console.error('Error updating playback position:', error);
            }
        } else if (!appState.isPlaying) {
            // If not playing, stop updates
            stopNowPlayingProgressUpdate();
        }
    }, 100); // Update every 100ms
    
    console.log('Started now playing progress updates');
}

// Stop now playing progress updates
function stopNowPlayingProgressUpdate() {
    if (appState.nowPlayingProgressInterval) {
        clearInterval(appState.nowPlayingProgressInterval);
        appState.nowPlayingProgressInterval = null;
    }
    console.log('Stopped now playing progress updates');
}

// Update player info and progress when a track starts playing
function updateNowPlayingPlayerInfo(track) {
    if (!track) return;
    
    // --- EXISTING LOGIC (Bottom Bar) ---
    const playerTrackTitle = document.getElementById('playerTrackTitle');
    const playerTrackArtist = document.getElementById('playerTrackArtist');
    
    if (playerTrackTitle) playerTrackTitle.textContent = track.title || 'Unknown Track';
    if (playerTrackArtist) playerTrackArtist.textContent = track.artist || 'Unknown Artist';
    
    console.log('Updated Now Playing info for:', track.title);
    
    // Update cover art
    const nowPlayingCover = document.querySelector('.now-playing-cover');
    if (nowPlayingCover) {
        if (track.thumbnail) {
            nowPlayingCover.innerHTML = `<img src="${track.thumbnail}" alt="Album Art" style="width:100%;height:100%;object-fit:cover;">`;
        } else {
            nowPlayingCover.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-secondary);"></div>';
        }
    }
    
    // Update like button state
    updateNowPlayingLikeButton(track);
    
    // Start progress updates
    startNowPlayingProgressUpdate();

    updateFullscreenContent();
    
    console.log('Updated now playing info:', track.title);
}

// Update like button in now playing bar
async function updateNowPlayingLikeButton(track) {
    const likeBtn = document.getElementById('likeBtn');
    if (!likeBtn) return;
    
    try {
        const checkResult = await window.pywebview.api.is_track_liked(track.artist, track.title);
        
        if (checkResult.success && checkResult.is_liked) {
            likeBtn.classList.add('active');
            likeBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
            `;
        } else {
            likeBtn.classList.remove('active');
            likeBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
            `;
        }
    } catch (error) {
        console.error('Error updating like button:', error);
    }
}

// Toggle like from now playing bar
async function toggleNowPlayingLike() {
    if (!appState.currentPlayingTrack) return;
    
    const track = appState.currentPlayingTrack;
    const likeBtn = document.getElementById('likeBtn');
    
    try {
        // Check current like status
        const checkResult = await window.pywebview.api.is_track_liked(track.artist, track.title);
        
        if (checkResult.success && checkResult.is_liked) {
            // Unlike the track
            const unlikeResult = await window.pywebview.api.unlike_track(checkResult.track.track_id);
            if (unlikeResult.success) {
                likeBtn.classList.remove('active');
                likeBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                `;
                addLog(` Unliked: ${track.artist} - ${track.title}`, 'info');
                await refreshRecommendations();
            }
        } else {
            // Like the track
            const likeResult = await window.pywebview.api.like_track({
                title: track.title,
                artist: track.artist,
                album: track.album || 'Unknown Album',
                duration: track.duration || 0,
                thumbnail: track.thumbnail,
                source: 'now_playing',
                filepath: track.filepath
            });
            
            if (likeResult.success) {
                likeBtn.classList.add('active');
                likeBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                `;
                addLog(` ${likeResult.message}`, 'success');
                await refreshRecommendations();
            }
        }
    } catch (error) {
        console.error('Error toggling like:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

// Add click event to like button in now playing bar
document.addEventListener('DOMContentLoaded', function() {
    const likeBtn = document.getElementById('likeBtn');
    if (likeBtn) {
        likeBtn.onclick = toggleNowPlayingLike;
    }
    
    // Add hover effects to progress bar thumb
    const progressBar = document.getElementById('progressBar');
    const progressThumb = document.querySelector('#progressFill .progress-thumb');
    
    if (progressBar && progressThumb) {
        progressBar.addEventListener('mouseenter', () => {
            progressThumb.style.opacity = '1';
        });
        
        progressBar.addEventListener('mouseleave', () => {
            progressThumb.style.opacity = '0';
        });
    }
});

// Like a recommended track (updated to use stored unique tracks)
async function likeRecommendedTrack(index, buttonElement, artist, title) {
    try {
        // Use artist and title from parameters, or get from stored tracks
        const trackArtist = artist || window.currentRecommendations?.[index]?.artist;
        const trackTitle = title || window.currentRecommendations?.[index]?.title;
        
        if (!trackArtist || !trackTitle) return;
        
        // Prepare track data
        const trackData = {
            title: trackTitle,
            artist: trackArtist,
            source: 'recommendation'
        };
        
        // Use the universal like function from your app
        const likeResult = await window.pywebview.api.like_track(trackData);
        
        if (likeResult.success) {
            // Update button to show liked state
            if (buttonElement) {
                buttonElement.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="var(--error-color)" style="width: 14px; height: 14px;">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                `;
                buttonElement.style.borderColor = 'var(--error-color)';
                buttonElement.style.background = 'var(--error-color)';
            }
            
            addLog(` Liked: ${trackArtist} - ${trackTitle}`, 'success');
            
            // Refresh recommendations to get new ones
            await refreshRecommendations();
        }
    } catch (error) {
        console.error('Error liking recommended track:', error);
        addLog(` Error liking track: ${error.message}`, 'error');
    }
}

// Unlike a recommended track
async function unlikeRecommendedTrack(artist, title, buttonElement) {
    try {
        // Get track info
        const checkResult = await window.pywebview.api.is_track_liked(artist, title);
        
        if (checkResult.success && checkResult.is_liked) {
            // Use the universal unlike function
            const unlikeResult = await window.pywebview.api.unlike_track(checkResult.track.track_id);
            
            if (unlikeResult.success) {
                // Update button to show unliked state
                if (buttonElement) {
                    buttonElement.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                        </svg>
                    `;
                    buttonElement.style.borderColor = 'var(--border-color)';
                    buttonElement.style.background = 'var(--bg-secondary)';
                }
                
                addLog(` Unliked: ${artist} - ${title}`, 'info');
                
                // Refresh recommendations
                await refreshRecommendations();
            }
        }
    } catch (error) {
        console.error('Error unliking recommended track:', error);
        addLog(` Error unliking track: ${error.message}`, 'error');
    }
}

// Download a recommended track
async function downloadRecommendedTrack(index) {
    try {
        const container = document.getElementById('recommendationsGrid');
        const albumCards = container.querySelectorAll('.album-card');
        const trackCard = albumCards[index];
        
        if (!trackCard) return;
        
        const trackTitle = trackCard.querySelector('.album-title').textContent;
        const trackArtist = trackCard.querySelector('.album-artist').textContent;
        
        // Confirm download
        if (!confirm(`Download "${trackTitle}" by ${trackArtist}?`)) {
            return;
        }
        
        addLog(` Searching for: ${trackArtist} - ${trackTitle}`, 'info');
        
        // Search YouTube for this track
        const youtubeResults = await window.pywebview.api.search_youtube_music(
            `${trackArtist} ${trackTitle} official audio`, 1
        );
        
        if (!youtubeResults || youtubeResults.length === 0) {
            addLog(` Could not find on YouTube: ${trackArtist} - ${trackTitle}`, 'error');
            alert('Could not find this track on YouTube for download');
            return;
        }
        
        const ytTrack = youtubeResults[0];
        
        // Prepare track data
        const trackData = {
            title: trackTitle,
            artist: trackArtist,
            duration: ytTrack.duration || 0,
            thumbnail: trackCard.querySelector('.album-cover img')?.src || '',
            youtube_url: ytTrack.youtube_url,
            album: 'Recommended Tracks'
        };
        
        addLog(` Downloading: ${trackArtist} - ${trackTitle}`, 'info');
        
        // Download the track
        const result = await window.pywebview.api.download_track_from_youtube(trackData);
        
        if (result && result.success) {
            addLog(` Downloaded: ${trackArtist} - ${trackTitle}`, 'success');
            alert(`Successfully downloaded:\n${trackArtist} - ${trackTitle}`);
            
            // Refresh downloaded tracks
            await loadDownloadedTracks();
        } else {
            addLog(` Download failed: ${result?.error || 'Unknown error'}`, 'error');
            alert(`Download failed:\n${result?.error || 'Please try again'}`);
        }
    } catch (error) {
        console.error('Error downloading recommended track:', error);
        addLog(` Download error: ${error.message}`, 'error');
        alert(`Download error: ${error.message}`);
    }
}

// Add recommended track to playlist
async function addRecommendedToPlaylist(index) {
    try {
        const container = document.getElementById('recommendationsGrid');
        const albumCards = container.querySelectorAll('.album-card');
        const trackCard = albumCards[index];
        
        if (!trackCard) return;
        
        const trackTitle = trackCard.querySelector('.album-title').textContent;
        const trackArtist = trackCard.querySelector('.album-artist').textContent;
        
        // Show the add to playlist modal using your existing function
        showAddToPlaylistModalForTrack(index, 'recommendation');
        
    } catch (error) {
        console.error('Error adding to playlist:', error);
        alert('Error adding to playlist: ' + error.message);
    }
}

// Play a recommended track (updated to use stored unique tracks)
async function playRecommendedTrack(index) {
    try {
        const track = window.currentRecommendations?.[index];
        if (!track) return;
        
        const trackTitle = track.title;
        const trackArtist = track.artist;
        
        // First, check if this track is already downloaded
        addLog(` Checking downloads for: ${trackArtist} - ${trackTitle}`, 'info');
        
        try {
            // Get all downloaded tracks
            const downloadedTracks = await window.pywebview.api.get_downloaded_tracks();
            
            // Try to find an exact match
            const downloadedTrack = downloadedTracks.find(t => 
                t.title.toLowerCase() === trackTitle.toLowerCase() && 
                t.artist.toLowerCase() === trackArtist.toLowerCase()
            );
            
            // If not found, try partial match
            if (!downloadedTrack) {
                const partialMatch = downloadedTracks.find(t => 
                    t.title.toLowerCase().includes(trackTitle.toLowerCase()) || 
                    t.artist.toLowerCase().includes(trackArtist.toLowerCase()) ||
                    trackTitle.toLowerCase().includes(t.title.toLowerCase()) ||
                    trackArtist.toLowerCase().includes(t.artist.toLowerCase())
                );
                
                if (partialMatch) {
                    addLog(` Found partial match in downloads: ${partialMatch.artist} - ${partialMatch.title}`, 'success');
                    
                    // Find the index of this downloaded track
                    const downloadedIndex = downloadedTracks.findIndex(t => t.filepath === partialMatch.filepath);
                    if (downloadedIndex !== -1) {
                        // Play the downloaded track
                        await playDownloadedTrack(downloadedIndex);
                        return;
                    }
                }
            } else {
                addLog(` Found exact match in downloads: ${downloadedTrack.artist} - ${downloadedTrack.title}`, 'success');
                
                // Find the index of this downloaded track
                const downloadedIndex = downloadedTracks.findIndex(t => t.filepath === downloadedTrack.filepath);
                if (downloadedIndex !== -1) {
                    // Play the downloaded track
                    await playDownloadedTrack(downloadedIndex);
                    return;
                }
            }
        } catch (error) {
            console.log('Error checking downloaded tracks:', error);
        }
        
        // If not found in downloads, stream from YouTube
        addLog(` Track not in downloads, streaming from YouTube...`, 'info');
        
        // Search YouTube for this track
        const youtubeResults = await window.pywebview.api.search_youtube_music(
            `${trackArtist} ${trackTitle} official audio`, 1
        );
        
        if (!youtubeResults || youtubeResults.length === 0) {
            addLog(` Could not find on YouTube: ${trackArtist} - ${trackTitle}`, 'error');
            alert('Could not find this track for preview');
            return;
        }
        
        const ytTrack = youtubeResults[0];
        
        // Prepare track data
        const trackData = {
            title: trackTitle,
            artist: trackArtist,
            thumbnail: track.thumbnail || '',
            youtube_url: ytTrack.youtube_url,
            duration: ytTrack.duration || 0,
            duration_str: ytTrack.duration_str || '0:00',
            source: 'recommendation'
        };
        
        // Get streaming URL
        const streamResult = await window.pywebview.api.get_discover_streaming_url(ytTrack.youtube_url);
        
        if (streamResult && streamResult.success) {
            // Show streaming controls using your existing function
            showStreamControlsForDiscover(trackData, streamResult);
            
            // Auto-play
            setTimeout(() => {
                const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (playBtn) playBtn.click();
            }, 300);
        } else {
            addLog(` Could not stream: ${trackArtist} - ${trackTitle}`, 'error');
            alert('Could not stream this track');
        }
    } catch (error) {
        console.error('Error playing recommended track:', error);
        addLog(` Play error: ${error.message}`, 'error');
        alert('Error playing track: ' + error.message);
    }
}

function renderMostPlayed(tracks) {
    const container = document.getElementById('tracksList');
    if (!container) return;
    
    if (!tracks || tracks.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">No playback history yet</div>';
        return;
    }
    
    const tracksToShow = tracks.slice(0, 5);
    
    container.innerHTML = tracksToShow.map((track, index) => `
        <div class="track-row">
            <div>
                <span class="track-number">${index + 1}</span>
                <button class="track-play-btn" onclick="playTrack('${track.title}')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
            </div>
            <div class="track-info">
                <div class="track-thumb">
                    ${track.thumbnail ? 
                      `<img src="${track.thumbnail}" alt="${track.title}">` : 
                      '<img src="https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=80&h=80&fit=crop" alt="">'
                    }
                </div>
                <div class="track-details">
                    <div class="track-title">${track.title}</div>
                    <div class="track-artist">${track.artist}</div>
                </div>
            </div>
            <div class="track-album">${track.album || 'Unknown Album'}</div>
            <div class="track-plays">${formatPlayCount(track.play_count || 0)}</div>
            <div class="track-duration-col">
                <span class="track-duration">${formatDuration(track.duration)}</span>
                <button class="track-more-btn" onclick="showTrackMenu(${index})">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="1"></circle>
                        <circle cx="19" cy="12" r="1"></circle>
                        <circle cx="5" cy="12" r="1"></circle>
                    </svg>
                </button>
            </div>
        </div>
    `).join('');
}

function formatPlayCount(count) {
    if (count >= 1000000000) {
        return (count / 1000000000).toFixed(1) + 'B';
    } else if (count >= 1000000) {
        return (count / 1000000).toFixed(1) + 'M';
    } else if (count >= 1000) {
        return (count / 1000).toFixed(1) + 'K';
    }
    return count.toString();
}

function formatDuration(seconds) {
    if (!seconds) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

async function refreshMostPlayed() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const mostPlayed = await window.pywebview.api.get_most_played();
            renderMostPlayed(mostPlayed || []);
            addLog(' Refreshed most played tracks', 'success');
        }
    } catch (error) {
        console.error('Error refreshing most played:', error);
    }
}

async function refreshRecommendations() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const recommendations = await window.pywebview.api.get_recommendations();
            renderRecommendations(recommendations || []);
            addLog(' Refreshed recommendations', 'success');
        }
    } catch (error) {
        console.error('Error refreshing recommendations:', error);
    }
}

async function downloadRecommended(index) {
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.download_recommended_track(index);
            if (result && result.success) {
                addLog(` Downloaded recommended track: ${result.title}`, 'success');
                await loadDownloadedTracks();
            } else {
                addLog(` Failed to download recommendation`, 'error');
            }
        }
    } catch (error) {
        console.error('Error downloading recommendation:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

function searchForSimilar(query) {
    setDiscoverSearch(query);
    showTab('discover');
}

async function playDownloadedTrackFromHistory(index) {
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.play_track_from_history(index);
            if (result && result.success) {
                appState.currentPlayingTrack = result.track;
                appState.isPlaying = true;
                appState.isPaused = false;
                appState.playbackDuration = result.track.duration || 0;
                
                showPlayer();
                updatePlayerInfo(result.track);
                playPauseBtn.innerHTML = '';
                playPauseBtn.title = 'Pause';
                
                addLog(` Now playing: ${result.track.artist} - ${result.track.title}`, 'success');
            }
        }
    } catch (error) {
        console.error('Error playing track from history:', error);
        addLog(` Error playing track: ${error.message}`, 'error');
    }
}

// ============================================
// PLAYLISTS FUNCTIONS
// ============================================

async function loadPlaylists() {
    try {
        if (window.pywebview && window.pywebview.api) {
            console.log('Loading playlists...');
            
            // Get playlists from backend
            const playlists = await window.pywebview.api.get_playlists();
            console.log('Playlists received:', playlists);
            
            // Store in app state
            appState.playlists = playlists || {};
            
            // --- FIX: POPULATE SIDEBAR LIST ---
            const sidebarList = document.getElementById('playlistList');
            if (sidebarList) {
                sidebarList.innerHTML = ''; // Clear existing list
                
                const playlistKeys = Object.keys(appState.playlists);
                
                // Filter out system playlists if you want only user ones
                const userPlaylists = playlistKeys.filter(key => appState.playlists[key].type !== 'system');
                
                if (userPlaylists.length > 0) {
                    userPlaylists.forEach(key => {
                        const playlist = appState.playlists[key];
                        
                        const link = document.createElement('div');
                        link.className = 'nav-item'; // Match your CSS style for sidebar items
                        link.textContent = playlist.name || key;
                        link.style.cursor = 'pointer';
                        link.onclick = () => openPlaylist(key); // Trigger playlist view
                        
                        sidebarList.appendChild(link);
                    });
                } else {
                    sidebarList.innerHTML = '<div style="padding:10px; color:var(--text-muted); font-size:12px;">No playlists</div>';
                }
            }
            // -----------------------------
            
            // Also refresh downloaded tracks for Downloads playlist if needed
            if (appState.playlists.Downloads) {
                const downloaded = await window.pywebview.api.get_downloaded_tracks();
                appState.downloadedTracks = downloaded || [];
                appState.playlists.Downloads.tracks = downloaded.map(track => ({
                    title: track.title,
                    artist: track.artist,
                    duration: track.duration,
                    duration_str: track.duration_str,
                    thumbnail: track.thumbnail,
                    filepath: track.filepath,
                    filename: track.filename
                }));
            }
            
            // Render the main grid view
            renderPlaylists();
        }
    } catch (error) {
        console.error('Error loading playlists:', error);
        addLog(` Error loading playlists: ${error.message}`, 'error');
    }
}

// Like a track
async function likeTrack(trackData) {
    try {
        if (!window.pywebview?.api?.like_track) {
            console.error('like_track API not available');
            return { success: false, message: 'Like feature not available' };
        }
        
        const result = await window.pywebview.api.like_track(trackData);
        console.log('Like result:', result);
        
        if (result.success) {
            addLog(result.message, 'success');
            
            // Update UI if needed
            const trackElement = document.querySelector(`[data-track-id="${result.track_id}"]`);
            if (trackElement) {
                trackElement.classList.add('liked');
                const likeBtn = trackElement.querySelector('.like-btn');
                if (likeBtn) likeBtn.innerHTML = '';
            }
            
            // Refresh Favorites playlist
            await loadPlaylists();
        } else {
            addLog(result.message, 'warning');
        }
        
        return result;
    } catch (error) {
        console.error('Error liking track:', error);
        addLog(` Error: ${error.message}`, 'error');
        return { success: false, message: error.message };
    }
}

// Unlike a track
async function unlikeTrack(trackId) {
    try {
        if (!window.pywebview?.api?.unlike_track) {
            console.error('unlike_track API not available');
            return { success: false, message: 'Unlike feature not available' };
        }
        
        const result = await window.pywebview.api.unlike_track(trackId);
        console.log('Unlike result:', result);
        
        if (result.success) {
            addLog(result.message, 'success');
            
            // Update UI if needed
            const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);
            if (trackElement) {
                trackElement.classList.remove('liked');
                const likeBtn = trackElement.querySelector('.like-btn');
                if (likeBtn) likeBtn.innerHTML = '';
            }
            
            // Refresh Favorites playlist
            await loadPlaylists();
        } else {
            addLog(result.message, 'warning');
        }
        
        return result;
    } catch (error) {
        console.error('Error unliking track:', error);
        addLog(` Error: ${error.message}`, 'error');
        return { success: false, message: error.message };
    }
}

// Check if track is liked
async function checkIfLiked(artist, title) {
    try {
        if (!window.pywebview?.api?.is_track_liked) {
            return { success: false, is_liked: false };
        }
        
        const result = await window.pywebview.api.is_track_liked(artist, title);
        return result;
    } catch (error) {
        console.error('Error checking if track is liked:', error);
        return { success: false, is_liked: false };
    }
}

// Add track to playlist
async function addTrackToPlaylist(playlistName, trackData) {
    try {
        if (!window.pywebview?.api?.add_track_to_playlist) {
            console.error('add_track_to_playlist API not available');
            return { success: false, message: 'Add to playlist feature not available' };
        }
        
        const result = await window.pywebview.api.add_track_to_playlist(playlistName, trackData);
        console.log('Add to playlist result:', result);
        
        if (result.success) {
            addLog(result.message, 'success');
            
            // Refresh playlists to show updated track count
            await loadPlaylists();
        } else {
            addLog(result.message, 'warning');
        }
        
        return result;
    } catch (error) {
        console.error('Error adding track to playlist:', error);
        addLog(` Error: ${error.message}`, 'error');
        return { success: false, message: error.message };
    }
}

// ============================================
// ADD TO PLAYLIST MODAL FUNCTIONS
// ============================================

async function showAddToPlaylistModalForTrack(trackIndex, source) {
    try {
        let track;
        
        // Get track based on source
        if (source === 'spotify') {
            if (trackIndex < 0 || trackIndex >= appState.tracks.length) return;
            track = appState.tracks[trackIndex];
        } else if (source === 'downloaded') {
            if (trackIndex < 0 || trackIndex >= appState.downloadedTracks.length) return;
            track = appState.downloadedTracks[trackIndex];
        } else if (source === 'discover') {
            if (trackIndex < 0 || trackIndex >= discoverSearchResults.length) return;
            const result = discoverSearchResults[trackIndex];
            track = result.track || result;
        }
        
        if (!track) {
            alert('Track not found');
            return;
        }
        
        // Get all playlists
        const playlists = await window.pywebview.api.get_playlists();
        const playlistKeys = Object.keys(playlists).filter(key => 
            key !== 'Downloads' && key !== 'Favorites'
        );
        
        if (playlistKeys.length === 0) {
            if (confirm('No playlists found. Create a new playlist?')) {
                showCreatePlaylistModal();
            }
            return;
        }
        
        // Create modal
        const modal = document.createElement('div');
        modal.id = 'addToPlaylistModalQuick';
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <div class="modal-title">Add to Playlist</div>
                    <button onclick="closeAddToPlaylistModalQuick()" class="close-modal-btn"></button>
                </div>
                
                <div class="modal-body">
                    <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                        <div style="font-weight: 600; margin-bottom: 5px; font-size: 15px;">${track.title}</div>
                        <div style="color: var(--text-secondary); font-size: 14px;">${track.artist}</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px;">Select Playlist:</label>
                        <select id="quickPlaylistSelect" class="select-control" style="width: 100%; padding: 12px; font-size: 14px;">
                            ${playlistKeys.map(key => `<option value="${key}">${playlists[key].name || key}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="font-size: 12px; color: var(--text-muted); text-align: center;">
                         Tip: Create new playlists from the Playlists tab
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button class="btn" onclick="closeAddToPlaylistModalQuick()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmAddToPlaylistQuick(${trackIndex}, '${source}')">
                        <span></span> Add to Playlist
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        document.body.style.overflow = 'hidden';
        
        // Focus on select
        setTimeout(() => {
            const select = document.getElementById('quickPlaylistSelect');
            if (select) select.focus();
        }, 100);
        
    } catch (error) {
        console.error('Error showing add to playlist modal:', error);
        alert('Error: ' + error.message);
    }
}

function closeAddToPlaylistModalQuick() {
    const modal = document.getElementById('addToPlaylistModalQuick');
    if (modal) modal.remove();
    document.body.style.overflow = 'auto';
}

async function confirmAddToPlaylistQuick(trackIndex, source) {
    try {
        const select = document.getElementById('quickPlaylistSelect');
        if (!select) return;
        
        const playlistName = select.value;
        
        if (!playlistName) {
            alert('Please select a playlist');
            return;
        }
        
        let track;
        
        // Get track based on source
        if (source === 'spotify') {
            track = appState.tracks[trackIndex];
        } else if (source === 'downloaded') {
            track = appState.downloadedTracks[trackIndex];
        } else if (source === 'discover') {
            const result = discoverSearchResults[trackIndex];
            track = result.track || result;
        }
        
        if (!track) {
            alert('Track not found');
            return;
        }
        
        // Prepare track data for playlist
        const trackData = {
            title: track.title,
            artist: track.artist,
            album: track.album || 'Unknown Album',
            duration: track.duration || 0,
            duration_str: track.duration_str || '0:00',
            thumbnail: track.thumbnail,
            source: source,
            youtube_url: track.youtube_url,
            spotify_id: track.id || track.spotify_id,
            filepath: track.filepath
        };
        
        addLog(` Adding to ${playlistName}: ${track.artist} - ${track.title}`, 'info');
        
        const result = await window.pywebview.api.add_track_to_playlist(playlistName, trackData);
        
        if (result && result.success) {
            addLog(` Added to ${playlistName}: ${track.artist} - ${track.title}`, 'success');
            closeAddToPlaylistModalQuick();
            
            // Refresh playlists
            await loadPlaylists();
            
            // Show success notification
            showNotification(`Added to ${playlistName}`, 'success');
        } else {
            addLog(` ${result.message || 'Failed to add to playlist'}`, 'error');
            alert(result.message || 'Failed to add to playlist');
        }
        
    } catch (error) {
        console.error('Error adding to playlist:', error);
        addLog(` Error: ${error.message}`, 'error');
        alert('Error adding to playlist: ' + error.message);
    }
}

// Show temporary notification
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: ${type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--error)' : 'var(--bg-card)'};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        font-weight: 500;
        max-width: 300px;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Show modal to add track to playlist
async function showAddToPlaylistModal(trackData) {
    const playlists = appState.playlists;
    const playlistKeys = Object.keys(playlists).filter(key => 
        key !== 'Downloads' && key !== 'Favorites'
    );
    
    if (playlistKeys.length === 0) {
        if (confirm('No user playlists found. Create a new playlist?')) {
            showCreatePlaylistModal();
        }
        return;
    }
    
    // Store trackData in a temporary variable
    window.tempTrackData = trackData;
    
    const modal = document.createElement('div');
    modal.id = 'addToPlaylistModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    `;
    
    modal.innerHTML = `
        <div style="background: var(--bg-card); border-radius: 12px; padding: 25px; width: 400px; max-width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
            <h3 style="margin-top: 0; margin-bottom: 20px;">Add to Playlist</h3>
            <div style="margin-bottom: 20px;">
                <div><strong>Track:</strong> ${trackData.title}</div>
                <div><strong>Artist:</strong> ${trackData.artist}</div>
            </div>
            
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Select Playlist:</label>
                <select id="playlistSelect" style="width: 100%; padding: 10px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; color: white; font-size: 14px;">
                    ${playlistKeys.map(key => `<option value="${key}">${playlists[key].name}</option>`).join('')}
                </select>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeAddToPlaylistModal()" class="btn" style="padding: 10px 20px;">
                    Cancel
                </button>
                <button onclick="confirmAddToPlaylist()" class="btn btn-success" style="padding: 10px 20px;">
                    Add to Playlist
                </button>
            </div>
            
            <button onclick="closeAddToPlaylistModal()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 20px; padding: 5px;">
                
            </button>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function closeAddToPlaylistModal() {
    const modal = document.getElementById('addToPlaylistModal');
    if (modal) {
        modal.remove();
    }
    document.body.style.overflow = 'auto';
    window.tempTrackData = null;
}

async function confirmAddToPlaylist() {
    const select = document.getElementById('playlistSelect');
    if (!select) return;
    
    const playlistName = select.value;
    
    if (!playlistName) {
        alert('Please select a playlist');
        return;
    }
    
    const trackData = window.tempTrackData;
    if (!trackData) {
        alert('Track data not found');
        return;
    }
    
    const result = await addTrackToPlaylist(playlistName, trackData);
    
    if (result.success) {
        closeAddToPlaylistModal();
    }
}

// ============================================
//  UNIFIED QUEUE INJECTION (NO RENAMES)
// ============================================

// ============================================
// COMPLETE PLAYBACK QUEUE SYSTEM
// ============================================

// Global playback queue state
window.playbackQueue = {
    tracks: [],              // Current playlist/queue
    currentIndex: -1,        // Current track index
    source: null,            // 'downloads', 'spotify', 'discover', 'playlist'
    isShuffled: false,
    repeatMode: 'off',       // 'off', 'all', 'one'
    shuffleHistory: [],
    playedIndices: new Set()
};

// ============================================
// QUEUE SETTER (MUST EXIST BEFORE USE)
// ============================================
function setQueue(list, source, index) {
    window.currentPlayingList = Array.isArray(list) ? list : [];
    window.currentPlayingIndex = typeof index === 'number' ? index : -1;
    window.currentPlayingSource = source || null;

    console.log(' Queue set:', {
        source: window.currentPlayingSource,
        index: window.currentPlayingIndex,
        size: window.currentPlayingList.length
    });
}


/**
 * Initialize playback queue
 */
function setPlaybackQueue(tracks, source, startIndex = 0) {
    window.playbackQueue.tracks = tracks;
    window.playbackQueue.source = source;
    window.playbackQueue.currentIndex = startIndex;
    window.playbackQueue.shuffleHistory = [startIndex];
    window.playbackQueue.playedIndices = new Set([startIndex]);
    
    console.log(`Queue set: ${tracks.length} tracks from ${source}, starting at ${startIndex}`);
}

/**
 * Get next track index based on shuffle/repeat
 */
function getNextTrackIndex() {
    const queue = window.playbackQueue;
    
    if (queue.tracks.length === 0) return -1;
    
    // Repeat one
    if (queue.repeatMode === 'one') {
        return queue.currentIndex;
    }
    
    let nextIndex;
    
    // Shuffle mode
    if (queue.isShuffled) {
        // Reset if all played
        if (queue.playedIndices.size >= queue.tracks.length) {
            queue.playedIndices.clear();
            queue.playedIndices.add(queue.currentIndex);
        }
        
        // Get unplayed tracks
        const unplayed = [];
        for (let i = 0; i < queue.tracks.length; i++) {
            if (!queue.playedIndices.has(i) && i !== queue.currentIndex) {
                unplayed.push(i);
            }
        }
        
        if (unplayed.length === 0) {
            nextIndex = Math.floor(Math.random() * queue.tracks.length);
        } else {
            nextIndex = unplayed[Math.floor(Math.random() * unplayed.length)];
        }
        
        queue.playedIndices.add(nextIndex);
        queue.shuffleHistory.push(nextIndex);
    } 
    // Normal mode
    else {
        nextIndex = queue.currentIndex + 1;
        
        // End of playlist
        if (nextIndex >= queue.tracks.length) {
            if (queue.repeatMode === 'all') {
                nextIndex = 0;
            } else {
                return -1; // No next track
            }
        }
    }
    
    return nextIndex;
}

/**
 * Get previous track index
 */
function getPreviousTrackIndex() {
    const queue = window.playbackQueue;
    
    if (queue.tracks.length === 0) return -1;
    
    // Repeat one
    if (queue.repeatMode === 'one') {
        return queue.currentIndex;
    }
    
    let prevIndex;
    
    // Shuffle mode - go back in history
    if (queue.isShuffled && queue.shuffleHistory.length > 1) {
        queue.shuffleHistory.pop(); // Remove current
        prevIndex = queue.shuffleHistory[queue.shuffleHistory.length - 1];
    }
    // Normal mode
    else {
        prevIndex = queue.currentIndex - 1;
        
        if (prevIndex < 0) {
            if (queue.repeatMode === 'all') {
                prevIndex = queue.tracks.length - 1;
            } else {
                prevIndex = 0;
            }
        }
    }
    
    return prevIndex;
}

/**
 * Skip to next track
 */
async function skipForward() {
    try {
        const queue = window.playbackQueue;
        
        if (queue.tracks.length === 0) {
            console.log('No queue available');
            return;
        }
        
        const nextIndex = getNextTrackIndex();
        
        if (nextIndex === -1) {
            console.log('End of playlist');
            await window.pywebview.api.stop_playback();
            return;
        }
        
        queue.currentIndex = nextIndex;
        console.log(` Skip forward to index ${nextIndex}`);
        
        await playTrackFromQueue(nextIndex);
        
    } catch (error) {
        console.error('Error skipping forward:', error);
        addLog(' Failed to skip forward', 'error');
    }
}

/**
 * Skip to previous track
 */
async function skipBackward() {
    try {
        const queue = window.playbackQueue;
        
        if (queue.tracks.length === 0) {
            console.log('No queue available');
            return;
        }
        
        const prevIndex = getPreviousTrackIndex();
        
        if (prevIndex === -1) {
            console.log('At start of playlist');
            return;
        }
        
        queue.currentIndex = prevIndex;
        console.log(` Skip backward to index ${prevIndex}`);
        
        await playTrackFromQueue(prevIndex);
        
    } catch (error) {
        console.error('Error skipping backward:', error);
        addLog(' Failed to skip backward', 'error');
    }
}

/**
 * Play track from current queue
 */
async function playTrackFromQueue(index) {
    const queue = window.playbackQueue;
    const track = queue.tracks[index];
    
    if (!track) {
        console.error('Track not found at index', index);
        return;
    }
    
    console.log(` Playing: ${track.artist} - ${track.title}`);
    
    // Play based on source
    if (queue.source === 'downloads') {
        const result = await window.pywebview.api.play_track(index);
        if (result.success) {
            updateNowPlayingDisplay(track);
        }
    } 
    else if (queue.source === 'spotify') {
        const result = await window.pywebview.api.play_track(index);
        if (result.success) {
            updateNowPlayingDisplay(track);
        }
    }
    else if (queue.source === 'discover' || track.youtube_url) {
        // Stream the track
        const streamInfo = await window.pywebview.api.get_discover_streaming_url(track.youtube_url || track.url);
        if (streamInfo.success) {
            playStreamAudio(streamInfo.stream_url, track);
            updateNowPlayingDisplay(track);
        }
    }
    else if (track.filepath) {
        const result = await window.pywebview.api.play_track(index);
        if (result.success) {
            updateNowPlayingDisplay(track);
        }
    }
}

/**
 * Toggle shuffle mode
 */
function toggleShuffle() {
    const queue = window.playbackQueue;
    queue.isShuffled = !queue.isShuffled;
    
    const shuffleBtn = document.querySelector('.control-btn[title="Shuffle"]');
    
    if (queue.isShuffled) {
        console.log(' Shuffle ON');
        shuffleBtn.style.color = 'var(--accent-color)';
        shuffleBtn.classList.add('active');
        
        // Initialize shuffle
        queue.shuffleHistory = [queue.currentIndex];
        queue.playedIndices = new Set([queue.currentIndex]);
    } else {
        console.log(' Shuffle OFF');
        shuffleBtn.style.color = '';
        shuffleBtn.classList.remove('active');
        
        queue.shuffleHistory = [];
        queue.playedIndices.clear();
    }
}

/**
 * Toggle repeat mode (off  all  one  off)
 */
function toggleRepeat() {
    const queue = window.playbackQueue;
    const repeatBtn = document.querySelector('.control-btn[title="Repeat"]');
    
    if (queue.repeatMode === 'off') {
        queue.repeatMode = 'all';
        console.log(' Repeat ALL');
        repeatBtn.style.color = 'var(--accent-color)';
        repeatBtn.classList.add('active');
        repeatBtn.title = 'Repeat: All';
    } 
    else if (queue.repeatMode === 'all') {
        queue.repeatMode = 'one';
        console.log(' Repeat ONE');
        repeatBtn.title = 'Repeat: One';
        
        // Add "1" indicator
        const indicator = document.createElement('span');
        indicator.className = 'repeat-one-indicator';
        indicator.textContent = '1';
        indicator.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: var(--accent-color);
        `;
        repeatBtn.style.position = 'relative';
        repeatBtn.appendChild(indicator);
    } 
    else {
        queue.repeatMode = 'off';
        console.log(' Repeat OFF');
        repeatBtn.style.color = '';
        repeatBtn.classList.remove('active');
        repeatBtn.title = 'Repeat';
        
        // Remove indicator
        const indicator = repeatBtn.querySelector('.repeat-one-indicator');
        if (indicator) indicator.remove();
    }
}

/**
 * Update now playing display
 */
function updateNowPlayingDisplay(track) {
    // Update player bar
    const titleEl = document.getElementById('trackTitle');
    const artistEl = document.getElementById('trackArtist');
    const albumArtEl = document.getElementById('albumArt');
    
    if (titleEl) titleEl.textContent = track.title || 'Unknown';
    if (artistEl) artistEl.textContent = track.artist || 'Unknown';
    
    if (albumArtEl && track.thumbnail) {
        albumArtEl.style.backgroundImage = `url(${track.thumbnail})`;
    }
    
    // Update play button state
    const playBtn = document.getElementById('playPauseBtn');
    if (playBtn) playBtn.classList.add('playing');
}

/**
 * Play streaming audio
 */
function playStreamAudio(streamUrl, track) {
    // Stop existing
    if (window.currentStreamAudio) {
        window.currentStreamAudio.pause();
        window.currentStreamAudio.src = '';
    }
    
    // Create new audio
    const audio = new Audio(streamUrl);
    audio.volume = 0.7;
    window.currentStreamAudio = audio;
    
    // Auto-play next when ended
    audio.addEventListener('ended', () => {
        console.log('Track ended, auto-playing next...');
        skipForward();
    });
    
    audio.addEventListener('error', (e) => {
        console.error('Stream error:', e);
        addLog(` Stream error: ${track.title}`, 'error');
    });
    
    audio.play().catch(err => {
        console.error('Play error:', err);
        addLog(` Play failed: ${err.message}`, 'error');
    });
}

// ============================================
// PLAY PLAYLIST TRACK (QUEUE ADDED INTERNALLY)
// ============================================
async function playPlaylistTrack(trackIndex) {
    let track;

    // ===== SOURCE 1: Spotify / online playlist =====
    if (window.currentPlaylistTracks && trackIndex < window.currentPlaylistTracks.length) {
        setQueue(window.currentPlaylistTracks, 'playlist:online', trackIndex);
        track = window.currentPlaylistTracks[trackIndex];

        console.log('Playing from currentPlaylistTracks:', track);

        // ---- Spotify preview ----
        if (track.preview_url && track.preview_url !== 'None') {
            showNowPlayingPreview(track);
            playSpotifyPreview(track);
            return;
        }

        // ---- YouTube fallback ----
        try {
            addLog(` Finding YouTube version for: ${track.artist} - ${track.title}`, 'info');

            const ytResults = await window.pywebview.api.search_youtube_music(
                `${track.artist} ${track.title} official audio`,
                1
            );

            if (!ytResults?.length) throw new Error('No YouTube result');

            const ytTrack = ytResults[0];
            const streamResult = await window.pywebview.api.get_discover_streaming_url(
                ytTrack.youtube_url
            );

            if (!streamResult?.success) throw new Error('Stream failed');

            const unifiedTrack = {
                title: track.title,
                artist: track.artist,
                album: track.album,
                thumbnail: track.thumbnail || ytTrack.thumbnail,
                youtube_url: ytTrack.youtube_url,
                duration: ytTrack.duration,
                duration_str: ytTrack.duration_str,
                source: 'Playlist (YouTube)'
            };

            showStreamControlsForDiscover(unifiedTrack, streamResult);

            setTimeout(() => {
                document.getElementById('streamDiscoverPlayPauseBtn')?.click();
            }, 300);

            addLog(` Playing: ${track.artist} - ${track.title}`, 'success');
            return;

        } catch (err) {
            console.error(err);
            alert('Could not play this track');
            return;
        }
    }

    // ===== SOURCE 2: Local playlists =====
    const playlistName = window.currentOpenPlaylist;
    if (!playlistName || !appState.playlists[playlistName]) {
        alert('Track not found');
        return;
    }

    const playlist = appState.playlists[playlistName];
    track = playlist.tracks?.[trackIndex];
    if (!track?.filepath) {
        alert('Track has no file');
        return;
    }

    const downloadedIndex = appState.downloadedTracks.findIndex(
        t => t.filepath === track.filepath
    );

    if (downloadedIndex === -1) {
        alert('Downloaded file not found');
        return;
    }

    //  SAME ENTRY POINT
    await playDownloadedTrack(downloadedIndex);
}

// ============================================
// DISCOVER STREAM (QUEUE ADDED)
// ============================================
function playDiscoveredStream(streamUrlEncoded, titleEncoded, artistEncoded) {
    const streamUrl = decodeURIComponent(streamUrlEncoded);
    const title = decodeURIComponent(titleEncoded);
    const artist = decodeURIComponent(artistEncoded);

    const trackList = discoverSearchResults || [];
    const track = trackList.find(t => t.title === title && t.artist === artist);
    if (!track) return;

    setQueue(trackList, 'discover', trackList.indexOf(track));

    showStreamControlsForDiscover(track, {
        stream_url: streamUrl,
        title,
        artist,
        thumbnail: track.thumbnail,
        duration: track.duration,
        duration_str: track.duration_str
    });

    setTimeout(() => {
        document.getElementById('streamDiscoverPlayPauseBtn')?.click();
    }, 500);
}

// ============================================
// SPOTIFY PREVIEW (QUEUE ADDED)
// ============================================
function playSpotifyPreview(track) {
    console.log('Playing Spotify 30-second preview');

    setQueue([track], 'spotify-preview', 0);

    if (streamAudio) {
        streamAudio.pause();
        streamAudio = null;
    }

    if (!track.preview_url || track.preview_url === 'None') {
        alert('No preview available');
        return;
    }

    streamAudio = new Audio(track.preview_url);
    streamAudio.volume = 0.7;

    streamTrackInfo = {
        title: track.title,
        artist: track.artist,
        duration: 30,
        duration_str: '0:30',
        thumbnail: track.thumbnail
    };

    streamAudio.addEventListener('playing', startStreamProgressUpdate);
    streamAudio.addEventListener('ended', stopStream);

    showStreamControlsForDiscover(track, {
        stream_url: track.preview_url,
        duration: 30,
        duration_str: '0:30'
    });

    setTimeout(() => {
        document.getElementById('streamDiscoverPlayPauseBtn')?.click();
    }, 300);
}

// ============================================
// DOWNLOADED TRACK (QUEUE ADDED HERE)
// ============================================
async function playDownloadedTrack(trackIndex) {
    try {
        const tracks = await window.pywebview.api.get_downloaded_tracks();
        setQueue(tracks, 'downloads', trackIndex);

        const result = await window.pywebview.api.play_track(trackIndex);
        if (!result?.success) return;

        appState.currentPlayingTrack = result.track;
        appState.isPlaying = true;
        appState.isPaused = false;
        appState.playbackDuration = result.track.duration || 0;
        appState.playbackPosition = 0;

        updateNowPlayingPlayerInfo(result.track);
        document.getElementById('playPauseBtn')?.classList.add('playing');

        updatePlayingStateVisuals();
        renderDownloadedTracks();
        renderTracks();

        addLog(` Now playing: ${result.track.artist} - ${result.track.title}`, 'success');

    } catch (error) {
        console.error('Error playing track:', error);
        addLog(` Error playing track: ${error.message}`, 'error');
    }
}

console.log(' Queue injected into existing play functions (no renames)');


async function removeFromPlaylist(playlistName, trackIndex) {
    if (!confirm('Remove this track from the playlist?')) return;
    
    try {
        if (window.pywebview && window.pywebview.api && window.pywebview.api.remove_from_playlist) {
            const result = await window.pywebview.api.remove_from_playlist(playlistName, trackIndex);
            
            if (result.success) {
                addLog(result.message, 'success');
                await loadPlaylists();
                
                const modal = document.getElementById('playlistTracksModal');
                if (modal) {
                    modal.remove();
                    setTimeout(() => openPlaylist(playlistName), 100);
                }
            } else {
                addLog(result.message, 'error');
            }
        }
    } catch (error) {
        console.error('Error removing from playlist:', error);
        addLog(` Error: ${error.message}`, 'error');
    }
}

function showCreatePlaylistModal() {
    const modal = document.getElementById('createPlaylistModal');
    if (modal) {
        modal.style.display = 'block';
    }
}

function closeCreatePlaylistModal() {
    const modal = document.getElementById('createPlaylistModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    const newPlaylistName = document.getElementById('newPlaylistName');
    const newPlaylistDescription = document.getElementById('newPlaylistDescription');
    
    if (newPlaylistName) newPlaylistName.value = '';
    if (newPlaylistDescription) newPlaylistDescription.value = '';
}

async function createPlaylist() {
    const nameInput = document.getElementById('newPlaylistName');
    const descInput = document.getElementById('newPlaylistDescription');
    
    if (!nameInput) return;
    
    const name = nameInput.value.trim();
    const description = descInput ? descInput.value.trim() : '';
    
    if (!name) {
        alert('Please enter a playlist name');
        return;
    }
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.create_playlist(name, description, null);
            console.log('Create playlist result:', result);
            
            if (result && result.success) {
                addLog(` Created playlist: ${name}`, 'success');
                closeCreatePlaylistModal();
                alert(`Playlist "${name}" created successfully!`);
                
                setTimeout(async () => {
                    await loadPlaylists();
                    showTab('playlists');
                }, 500);
            } else {
                const errorMsg = result?.message || 'Unknown error';
                console.error('Create playlist failed:', errorMsg);
                addLog(` Failed to create playlist: ${errorMsg}`, 'error');
                alert(`Failed to create playlist: ${errorMsg}`);
            }
        } else {
            console.error('API not available');
            alert('API not available. Please check if the application is properly loaded.');
        }
    } catch (error) {
        console.error('Error creating playlist:', error);
        const errorMsg = error.message || 'Unknown error';
        addLog(` Error creating playlist: ${errorMsg}`, 'error');
        alert(`Error creating playlist: ${errorMsg}`);
    }
}

async function debugPlaylists() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const playlists = await window.pywebview.api.get_playlists();
            console.log('Current playlists:', playlists);
            
            alert(`Found ${Object.keys(playlists || {}).length} playlists. Check console for details.`);
        }
    } catch (error) {
        console.error('Debug error:', error);
        alert(`Debug error: ${error.message}`);
    }
}

async function deletePlaylist(playlistId) {
    if (!confirm('Are you sure you want to delete this playlist?')) {
        return;
    }
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.delete_playlist(playlistId);
            if (result && result.success) {
                addLog(` Deleted playlist`, 'success');
                await loadPlaylists();
            } else {
                addLog(` Failed to delete playlist`, 'error');
            }
        }
    } catch (error) {
        console.error('Error deleting playlist:', error);
        addLog(` Error deleting playlist: ${error.message}`, 'error');
    }
}

async function editPlaylist(playlistId) {
    const playlist = appState.playlists[playlistId];
    if (!playlist) return;
    
    const newName = prompt('Enter new playlist name:', playlist.name);
    if (!newName) return;
    
    const newDescription = prompt('Enter new description:', playlist.description || '');
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.update_playlist(playlistId, newName, newDescription);
            if (result && result.success) {
                addLog(` Updated playlist: ${newName}`, 'success');
                await loadPlaylists();
            } else {
                addLog(` Failed to update playlist`, 'error');
            }
        }
    } catch (error) {
        console.error('Error updating playlist:', error);
        addLog(` Error updating playlist: ${error.message}`, 'error');
    }
}

async function refreshPlaylists() {
    await loadPlaylists();
    addLog(' Refreshed playlists', 'success');
}

// ============================================
// SEARCH FUNCTIONALITY
// ============================================

function handleSearchInput(event) {
    if (event.key === 'Enter' || event.keyCode === 13) {
        performSearch();
    } else if (searchInput && searchInput.value === '') {
        clearSearch();
    }
}

async function performSearch() {
    if (!searchInput) return;
    
    const searchTerm = searchInput.value.trim();
    
    if (!searchTerm) {
        clearSearch();
        return;
    }
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const results = await window.pywebview.api.search_tracks(searchTerm);
            currentSearchResults = results || [];
            
            if (results && results.length > 0) {
                highlightSearchResults(results);
                if (clearSearchBtn) clearSearchBtn.style.display = 'block';
                addLog(` Found ${results.length} tracks matching "${searchTerm}"`, 'success');
            } else {
                addLog(` No tracks found matching "${searchTerm}"`, 'info');
                clearSearch();
            }
        }
    } catch (error) {
        console.error('Error searching tracks:', error);
        addLog(` Search error: ${error.message}`, 'error');
    }
}

function highlightSearchResults(results) {
    const allCards = document.querySelectorAll('.track-card');
    allCards.forEach(card => {
        card.style.opacity = '0.5';
        card.style.borderColor = 'var(--border)';
        card.style.boxShadow = 'none';
    });
    
    results.forEach(result => {
        const trackIndex = result.index;
        const card = document.querySelectorAll('.track-card')[trackIndex];
        if (card) {
            card.style.opacity = '1';
            card.style.borderColor = 'var(--success)';
            card.style.boxShadow = '0 0 0 2px rgba(29, 185, 84, 0.3)';
        }
    });
}

function clearSearch() {
    if (searchInput) searchInput.value = '';
    if (clearSearchBtn) clearSearchBtn.style.display = 'none';
    
    const allCards = document.querySelectorAll('.track-card');
    allCards.forEach(card => {
        card.style.opacity = '1';
        card.style.borderColor = '';
        card.style.boxShadow = '';
    });
    
    currentSearchResults = [];
}

// ============================================
// SIMILAR TRACKS FUNCTIONALITY
// ============================================

async function openSimilarTracksModal() {
    const selectedIndices = Array.from(appState.selectedTracks);
    
    if (selectedIndices.length === 0) {
        addLog(' Please select at least one track first', 'warning');
        return;
    }
    
    if (selectedIndices.length > 1) {
        addLog(' Please select only one track to find alternatives', 'warning');
        return;
    }
    
    currentSimilarTrackIndex = selectedIndices[0];
    const track = appState.tracks[currentSimilarTrackIndex];
    
    // Get DOM elements
    const originalTrackTitle = document.getElementById('originalTrackTitle');
    const originalTrackArtist = document.getElementById('originalTrackArtist');
    const similarTracksModal = document.getElementById('similarTracksModal');
    const similarTracksLoading = document.getElementById('similarTracksLoading');
    const similarTracksError = document.getElementById('similarTracksError');
    const similarTracksList = document.getElementById('similarTracksList');
    
    if (!originalTrackTitle || !originalTrackArtist || !similarTracksModal) return;
    
    // 1. Update Header (Top of modal)
    originalTrackTitle.textContent = track.title;
    originalTrackArtist.textContent = track.artist;
    
    // 2. Show Modal
    similarTracksModal.style.display = 'block';
    
    // 3. Show Loading (Styled to match your new theme)
    if (similarTracksLoading) {
        similarTracksLoading.style.display = 'flex'; // Changed to flex for centered layout
        
        // Apply professional inline styles
        similarTracksLoading.style.cssText = `
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: #000000;
            color: #ffffff;
            border-radius: 0px;
            border: 1px solid rgba(255,255,255,0.1);
        `;

        // Professional HTML Content (No Emojis)
        similarTracksLoading.innerHTML = `
            <div style="
                width: 32px; 
                height: 32px; 
                border: 3px solid rgba(255,255,255,0.2); 
                border-top: 3px solid #ffffff; 
                border-radius: 50%; 
                animation: spin 0.8s linear infinite;
                margin-bottom: 20px;
            "></div>
            <div style="font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">
                Searching
            </div>
            <div style="font-size: 13px; color: rgba(255,255,255,0.5);">
                Looking for alternative tracks
            </div>
        `;
    }
    
    if (similarTracksError) similarTracksError.style.display = 'none';
    if (similarTracksList) similarTracksList.style.display = 'none';
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const results = await window.pywebview.api.find_similar_tracks(currentSimilarTrackIndex);
            
            if (similarTracksLoading) similarTracksLoading.style.display = 'none';
            
            if (results && results.length > 0) {
                displaySimilarTracks(results);
            } else {
                if (similarTracksError) {
                    similarTracksError.style.display = 'block';
                    // Remove emoji, generic text
                    similarTracksError.innerHTML = `
                        <div style="display:flex; flex-direction:column; align-items:center; gap:10px; padding:20px;">
                            <span style="font-size:14px; font-weight:600;">No Results Found</span>
                            <span style="font-size:13px; color:rgba(255,255,255,0.5);">Try selecting a different track</span>
                        </div>
                    `;
                }
            }
        } else {
            if (similarTracksError) {
                similarTracksError.style.display = 'block';
                similarTracksError.textContent = 'API not available';
            }
        }
    } catch (error) {
        console.error('Error finding similar tracks:', error);
        if (similarTracksLoading) similarTracksLoading.style.display = 'none';
        if (similarTracksError) {
            similarTracksError.style.display = 'block';
            // Professional error message
            similarTracksError.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; gap:10px; padding:20px;">
                    <span style="font-size:14px; font-weight:600;">Connection Error</span>
                    <span style="font-size:13px; color:rgba(255,255,255,0.5);">Please try again later</span>
                </div>
            `;
        }
    }
}

function closeSimilarTracksModal() {
    const modal = document.getElementById('similarTracksModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    const container = document.getElementById('similarTracksContainer');
    if (container) {
        container.innerHTML = '';
    }
    currentSimilarTrackIndex = null;
}

// ============================================
// STREAMING PLAYBACK FUNCTIONS
// ============================================

// Replace the entire playSimilarTrackPreview function with this updated version:

async function playSimilarTrackPreview(alternativeIndex) {
    // Use the global similar tracks array
    if (!window.similarTracks || alternativeIndex >= window.similarTracks.length) {
        console.error('Similar track not found at index:', alternativeIndex);
        return;
    }
    
    const track = window.similarTracks[alternativeIndex];
    console.log('Playing similar track from modal:', track);
    
    addLog(` Preparing to stream similar track: ${track.title}`, 'info');
    
    try {
        // Check if we have a direct YouTube URL in the track
        if (!track.url) {
            console.error('No URL found for similar track:', track);
            alert('No streaming URL available for this track');
            return;
        }
        
        // Get streaming URL using the same API as discover tracks
        const streamResult = await window.pywebview.api.get_discover_streaming_url(track.url);
        
        if (streamResult && streamResult.success) {
            // Create a track object compatible with the streaming system
            const streamTrack = {
                title: track.title,
                artist: track.uploader || 'Unknown Artist',
                thumbnail: track.thumbnail,
                youtube_url: track.url,
                duration: track.duration || 0,
                duration_str: track.duration_str || formatDuration(track.duration),
                source: 'Similar Tracks'
            };
            
            // Update now playing bar
            appState.currentPlayingTrack = streamTrack;
            appState.isPlaying = false; // Will be set when play button is clicked
            appState.playbackDuration = track.duration || 0;
            appState.playbackPosition = 0;
            
            updateNowPlayingPlayerInfo(streamTrack);
            
            // Use the existing streaming controls (same as track grid)
            showStreamControlsForDiscover(streamTrack, streamResult);
            
            // Auto-play after a short delay
            setTimeout(() => {
                const playBtn = document.getElementById('streamDiscoverPlayPauseBtn');
                if (playBtn) {
                    playBtn.click();
                }
            }, 500);
            
            addLog(` Streaming similar track: ${track.title}`, 'success');
            
            // Close the similar tracks modal
            closeSimilarTracksModal();
            
        } else {
            console.error('Failed to get streaming URL:', streamResult);
            addLog(` Could not get streaming URL for similar track`, 'error');
            alert('Could not stream this track. Please try another one.');
        }
        
    } catch (error) {
        console.error('Error streaming similar track:', error);
        addLog(` Streaming error: ${error.message}`, 'error');
        alert(`Error streaming track: ${error.message}`);
    }
}

function preloadImage(url) {
    return new Promise((resolve) => {
        if (!url) {
            resolve(false);
            return;
        }
        
        const img = new Image();
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = url;
        
        // Timeout after 5 seconds
        setTimeout(() => resolve(false), 5000);
    });
}

// Update thumbnail in stream controls
function updateStreamThumbnail(thumbnailUrl) {
    const coverImg = document.getElementById('streamCoverImg');
    if (coverImg && thumbnailUrl) {
        coverImg.src = thumbnailUrl;
        coverImg.style.display = 'block';
        coverImg.onerror = function() {
            this.style.display = 'none';
            const placeholder = document.getElementById('streamCoverPlaceholder');
            if (placeholder) {
                placeholder.style.display = 'flex';
            }
        };
    }
}

// Also update the showStreamControls function to handle thumbnail updates better
function showStreamControls(track) {
    let streamControls = document.getElementById('streamControls');
    
    if (!streamControls) {
        streamControls = document.createElement('div');
        streamControls.id = 'streamControls';
        streamControls.style.cssText = `
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: var(--bg-card);
            border: 2px solid var(--success);
            border-radius: 12px;
            padding: 15px;
            width: 350px;
            z-index: 1001;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        `;
        
        streamControls.innerHTML = `
            <div style="display: flex; align-items: flex-start; gap: 15px; margin-bottom: 15px;">
                <div style="width: 60px; height: 60px; background: var(--bg-secondary); border-radius: 8px; overflow: hidden; flex-shrink: 0; position: relative;">
                    <img id="streamCoverImg" style="width: 100%; height: 100%; object-fit: cover; display: none;" alt="Cover">
                    <div id="streamCoverPlaceholder" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-muted);"></div>
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 5px;" id="streamTrackTitle"></div>
                    <div style="color: var(--text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 5px;" id="streamTrackArtist"></div>
                    <div style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: var(--text-muted);">
                        <span id="streamCurrentTime">0:00</span>
                        <span>/</span>
                        <span id="streamTotalTime">0:00</span>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 15px; position: relative; cursor: pointer;" id="streamProgressBar" onclick="handleStreamProgressClick(event)">
                <div style="width: 100%; height: 4px; background: var(--border); border-radius: 2px;">
                    <div id="streamProgressFill" style="width: 0%; height: 100%; background: var(--success); border-radius: 2px;"></div>
                </div>
                <div id="streamProgressHandle" style="position: absolute; top: 50%; left: 0%; transform: translate(-50%, -50%); width: 12px; height: 12px; background: var(--success); border-radius: 50%; transition: opacity 0.2s; opacity: 0;"></div>
            </div>
            
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <button onclick="streamPlayPause()" id="streamPlayPauseBtn" style="flex-shrink: 0; background: var(--success); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px;">
                    
                </button>
                
                <button onclick="stopStream()" style="flex-shrink: 0; background: var(--error); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px;">
                    
                </button>
                
                <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                    <div style="font-size: 18px; color: var(--text-secondary);"></div>
                    <input type="range" min="0" max="100" value="70" oninput="setStreamVolume(this.value / 100)" style="flex: 1; height: 4px; background: var(--border); border-radius: 2px; appearance: none;">
                    <span id="streamVolumeValue" style="font-size: 12px; color: var(--text-secondary); min-width: 30px;">70%</span>
                </div>
            </div>
            
            <button onclick="closeStreamControls()" style="position: absolute; top: 5px; right: 5px; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; padding: 2px;">
                
            </button>
        `;
        
        document.body.appendChild(streamControls);
        
        // Add hover effect for progress bar
        const progressBar = document.getElementById('streamProgressBar');
        const progressHandle = document.getElementById('streamProgressHandle');
        
        if (progressBar && progressHandle) {
            progressBar.addEventListener('mouseenter', () => {
                progressHandle.style.opacity = '1';
            });
            
            progressBar.addEventListener('mouseleave', () => {
                progressHandle.style.opacity = '0';
            });
        }
        
        // Style the volume slider
        const volumeSlider = streamControls.querySelector('input[type="range"]');
        if (volumeSlider) {
            volumeSlider.style.cssText = `
                flex: 1;
                height: 4px;
                background: var(--border);
                border-radius: 2px;
                appearance: none;
                outline: none;
            `;
            
            volumeSlider.addEventListener('input', function() {
                this.style.background = `linear-gradient(to right, var(--success) ${this.value}%, var(--border) ${this.value}%)`;
            });
            
            // Initialize the slider background
            volumeSlider.style.background = `linear-gradient(to right, var(--success) 70%, var(--border) 70%)`;
        }
    }
    
    // Update track info
    const titleEl = document.getElementById('streamTrackTitle');
    const artistEl = document.getElementById('streamTrackArtist');
    
    if (titleEl) titleEl.textContent = track.title;
    if (artistEl) artistEl.textContent = track.artist;
    
    // Update cover image - show placeholder initially
    const coverImg = document.getElementById('streamCoverImg');
    const coverPlaceholder = document.getElementById('streamCoverPlaceholder');
    
    if (coverImg && coverPlaceholder) {
        coverImg.style.display = 'none';
        coverPlaceholder.style.display = 'flex';
        
        // If we have a thumbnail, try to load it
        if (track.thumbnail) {
            preloadImage(track.thumbnail).then(success => {
                if (success) {
                    coverImg.src = track.thumbnail;
                    coverImg.style.display = 'block';
                    coverPlaceholder.style.display = 'none';
                    
                    coverImg.onerror = function() {
                        this.style.display = 'none';
                        if (coverPlaceholder) {
                            coverPlaceholder.style.display = 'flex';
                        }
                    };
                }
            });
        }
    }
    
    // Update duration
    if (streamTrackInfo) {
        const totalTimeEl = document.getElementById('streamTotalTime');
        if (totalTimeEl) {
            totalTimeEl.textContent = streamTrackInfo.duration_str;
        }
    }
    
    // Reset play/pause button
    const playPauseBtn = document.getElementById('streamPlayPauseBtn');
    if (playPauseBtn) {
        playPauseBtn.innerHTML = '';
        playPauseBtn.style.background = 'var(--success)';
    }
    
    // Reset progress
    const progressFill = document.getElementById('streamProgressFill');
    const progressHandle = document.getElementById('streamProgressHandle');
    const currentTime = document.getElementById('streamCurrentTime');
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressHandle) progressHandle.style.left = '0%';
    if (currentTime) currentTime.textContent = '0:00';
}

// Replace your existing DOMContentLoaded event listener with this:

// ========================================
// ENHANCED INITIALIZATION
// ========================================

let appInitialized = false;
let initializationAttempts = 0;
const MAX_INIT_ATTEMPTS = 3;

async function safeInitialize() {
    if (appInitialized) return;
    
    initializationAttempts++;
    console.log(` App initializing (Attempt ${initializationAttempts}/${MAX_INIT_ATTEMPTS})...`);
    
    try {
        // 1. Wait for DOM to be fully ready
        if (!document.getElementById('trackGrid') || !document.getElementById('player')) {
            console.log(' Waiting for DOM elements...');
            if (initializationAttempts < MAX_INIT_ATTEMPTS) {
                setTimeout(safeInitialize, 1000);
                return;
            }
        }
        
        // 2. Wait for API to be available
        if (!window.pywebview || !window.pywebview.api) {
            console.log(' Waiting for backend API...');
            if (initializationAttempts < MAX_INIT_ATTEMPTS) {
                setTimeout(safeInitialize, 1000);
                return;
            } else {
                console.error(' Backend API not available after multiple attempts');
                showErrorBanner('Backend connection failed. Please restart the application.');
                return;
            }
        }
        
        // 3. Initialize core state
        updateStatus('ready', 'Ready to connect');
        await loadSettings();
        checkFFmpeg();
        loadDownloadedTracks();
        startPlaybackUpdate();
        loadDiscoverPage();
        await loadLikedSongsCount();
        
        // 4. Render initial content (NON-BLOCKING)
        setTimeout(() => {
            renderInitialContent();
            setupEventListeners();
            updateCounts();
            
            appInitialized = true;
            console.log(' App initialized successfully');
            
            // 5. Auto-connect to Spotify silently
            setTimeout(async () => {
                console.log(' Auto-connecting to Spotify...');
                await ensureSpotifyConnected();
                
                // 6. Load initial tracks AFTER Spotify connection
                setTimeout(async () => {
                    await loadTracks(true);
                    await loadLikedSongs();
                    await loadPlaylists();
                }, 500);
            }, 500);
        }, 100);
        
    } catch (error) {
        console.error(' Initialization error:', error);
        
        if (initializationAttempts < MAX_INIT_ATTEMPTS) {
            console.log(` Retrying initialization in 2 seconds...`);
            setTimeout(safeInitialize, 2000);
        } else {
            console.error(' Failed to initialize after multiple attempts');
            showErrorBanner('Failed to initialize. Please restart the application.');
        }
    }
}

function renderInitialContent() {
    console.log(' Rendering initial content...');
    
    // Render static content first
    renderAlbums();
    renderTracks();
    renderArtists();
    renderGenres();
    renderRecommended();
    renderPopular();
    renderPlaylists();
    renderLibraryRecent();
    
    // Update UI immediately
    updateCounts();
}

function setupEventListeners() {
    console.log(' Setting up controls...');
    setupPlayerControls();
    setupProgressBar();
    setupVolumeBar();
    setupNavigation();
    
    // Ensure search input handlers are set
    if (searchInput) {
        searchInput.addEventListener('keyup', handleSearchInput);
    }
    
    if (discoverSearchInput) {
        discoverSearchInput.addEventListener('keyup', handleDiscoverSearchKeyup);
    }
}

function showErrorBanner(message) {
    const banner = document.createElement('div');
    banner.id = 'errorBanner';
    banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: var(--error);
        color: white;
        padding: 15px 20px;
        text-align: center;
        z-index: 10000;
        font-weight: 500;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    `;
    banner.innerHTML = `
        <div style="max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center;">
            <span>${message}</span>
            <button onclick="document.getElementById('errorBanner').remove(); location.reload();" 
                    style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 15px; border-radius: 4px; cursor: pointer;">
                Retry
            </button>
        </div>
    `;
    document.body.prepend(banner);
}

// Start initialization
document.addEventListener('DOMContentLoaded', () => {
    console.log(' DOM fully loaded');
    safeInitialize();
});

// Also handle window load for good measure
window.addEventListener('load', () => {
    console.log(' All resources loaded');
    if (!appInitialized) {
        setTimeout(safeInitialize, 500);
    }
});

function updateStreamDuration() {
    if (streamAudio && !isNaN(streamAudio.duration)) {
        const duration = streamAudio.duration;
        const minutes = Math.floor(duration / 60);
        const seconds = Math.floor(duration % 60);
        const durationStr = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        
        if (streamTrackInfo) {
            streamTrackInfo.duration = duration;
            streamTrackInfo.duration_str = durationStr;
        }
        
        const totalTimeEl = document.getElementById('streamTotalTime');
        if (totalTimeEl) {
            totalTimeEl.textContent = durationStr;
        }
    }
}

function streamPlayPause() {
    if (!streamAudio) return;
    
    const btn = document.getElementById('streamPlayPauseBtn');
    if (!btn) return;
    
    if (streamAudio.paused) {
        streamAudio.play().then(() => {
            btn.innerHTML = '';
            btn.style.background = 'var(--success)';
        }).catch(error => {
            console.error('Error playing stream:', error);
            addLog(` Play error: ${error.message}`, 'error');
        });
    } else {
        streamAudio.pause();
        btn.innerHTML = '';
        btn.style.background = 'var(--warning)';
    }
}

function setStreamVolume(volume) {
    if (streamAudio) {
        volume = Math.max(0, Math.min(1, volume));
        streamAudio.volume = volume;
        
        const volumeValue = document.getElementById('streamVolumeValue');
        if (volumeValue) {
            volumeValue.textContent = `${Math.round(volume * 100)}%`;
        }
        
        // Update slider visual
        const volumeSlider = document.querySelector('#streamControls input[type="range"]');
        if (volumeSlider) {
            volumeSlider.value = volume * 100;
            volumeSlider.style.background = `linear-gradient(to right, var(--success) ${volume * 100}%, var(--border) ${volume * 100}%)`;
        }
    }
}

function handleStreamProgressClick(event) {
    if (!streamAudio || isNaN(streamAudio.duration)) return;
    
    const progressBar = document.getElementById('streamProgressBar');
    if (!progressBar) return;
    
    const rect = progressBar.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const percentage = Math.min(1, Math.max(0, clickX / rect.width));
    const newTime = percentage * streamAudio.duration;
    
    streamAudio.currentTime = newTime;
    updateStreamProgress();
}

function startStreamProgressUpdate() {
    if (streamProgressInterval) {
        clearInterval(streamProgressInterval);
    }
    
    streamProgressInterval = setInterval(updateStreamProgress, 100);
}

function stopStreamProgressUpdate() {
    if (streamProgressInterval) {
        clearInterval(streamProgressInterval);
        streamProgressInterval = null;
    }
}

function updateStreamProgress() {
    if (!streamAudio || isNaN(streamAudio.duration) || streamAudio.paused) return;
    
    const currentTime = streamAudio.currentTime;
    const duration = streamAudio.duration;
    const percentage = (currentTime / duration) * 100;
    
    const progressFill = document.getElementById('streamProgressFill');
    const progressHandle = document.getElementById('streamProgressHandle');
    const currentTimeDisplay = document.getElementById('streamCurrentTime');
    
    if (progressFill) {
        progressFill.style.width = `${percentage}%`;
    }
    
    if (progressHandle) {
        progressHandle.style.left = `${percentage}%`;
    }
    
    if (currentTimeDisplay) {
        const minutes = Math.floor(currentTime / 60);
        const seconds = Math.floor(currentTime % 60);
        currentTimeDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    
    // Auto-stop when finished
    if (currentTime >= duration - 0.5 && duration > 0) {
        stopStream();
    }
}

function stopStream() {
    if (streamAudio) {
        streamAudio.pause();
        streamAudio.currentTime = 0;
        streamAudio = null;
    }
    
    stopStreamProgressUpdate();
    closeStreamControls();
}

function closeStreamControls() {
    stopStream();
    
    const streamControls = document.getElementById('streamControls');
    if (streamControls) {
        streamControls.remove();
    }
    
    streamTrackInfo = null;
}

async function downloadSimilarTrack(alternativeIndex) {
    if (currentSimilarTrackIndex === null) return;
    
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.download_alternative_track(currentSimilarTrackIndex, alternativeIndex);
            
            if (result && result.success) {
                addLog(` Downloaded alternative: ${result.alternative_title}`, 'success');
                closeSimilarTracksModal();
                
                await loadDownloadedTracks();
                
                appState.tracks[currentSimilarTrackIndex].downloaded = true;
                renderTracks();
            } else {
                addLog(` Failed to download alternative: ${result?.message || 'Unknown error'}`, 'error');
            }
        }
    } catch (error) {
        console.error('Error downloading alternative track:', error);
        addLog(` Error downloading alternative: ${error.message}`, 'error');
    }
}

/* ===============================
   FORCE-GLOBAL DOWNLOAD MODAL
   =============================== */

window.__progressModalOpen = false;

window.openProgressModal = function () {
    console.log('[PROGRESS] openProgressModal called');

    const modal = document.getElementById('progressModal');
    if (!modal) {
        console.error('[PROGRESS] progressModal NOT FOUND');
        return;
    }

    modal.classList.remove('hidden');
    window.__progressModalOpen = true;

    console.log('[PROGRESS] modal is now OPEN');
};

window.closeProgressModal = function () {
    console.log('[PROGRESS] closeProgressModal called');

    const modal = document.getElementById('progressModal');
    if (!modal) {
        console.error('[PROGRESS] progressModal NOT FOUND');
        return;
    }

    modal.classList.add('hidden');
    window.__progressModalOpen = false;

    console.log('[PROGRESS] modal is now CLOSED');
};

/* HARD WIRED EVENT BINDING */
document.addEventListener('DOMContentLoaded', () => {
    console.log('[PROGRESS] DOM READY');

    const fab = document.getElementById('progressFab');
    const closeBtn = document.getElementById('progressCloseBtn');
    const backdrop = document.getElementById('progressBackdrop');

    if (!fab) {
        console.error('[PROGRESS] FAB BUTTON NOT FOUND');
    } else {
        fab.onclick = window.openProgressModal;
        console.log('[PROGRESS] FAB bound');
    }

    if (closeBtn) {
        closeBtn.onclick = window.closeProgressModal;
        console.log('[PROGRESS] Close button bound');
    }

    if (backdrop) {
        backdrop.onclick = window.closeProgressModal;
        console.log('[PROGRESS] Backdrop bound');
    }
});

// ============================================
// MEDIA PLAYER FUNCTIONS
// ============================================

async function playPause() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.play_pause();
            if (result && result.success) {
                
                // 1. Update State
                appState.isPlaying = result.is_playing;
                appState.isPaused = !result.is_playing;

                // 2. Toggle CSS Class (The Fix)
                const playPauseBtn = document.getElementById('playPauseBtn');
                if (playPauseBtn) {
                    if (result.is_playing) {
                        playPauseBtn.classList.add('playing');
                        playPauseBtn.title = "Pause";
                    } else {
                        playPauseBtn.classList.remove('playing');
                        playPauseBtn.title = "Play";
                    }
                }

                // 3. Update Track Visuals (Equalizers)
                updatePlayingStateVisuals();
                
                addLog(result.is_playing ? ' Playback resumed' : ' Playback paused', 'success');
            }
        }
    } catch (error) {
        console.error('Error toggling play/pause:', error);
    }
}

// ============================================
// GLOBAL QUEUE STATE
// ============================================
window.queueState = {
    tracks: [],
    index: 0,
    source: null, // 'downloads' | 'playlist:online'
    repeat: false,
    shuffle: false
};

// ============================================
// QUEUE MANAGEMENT
// ============================================
function setQueue(tracks, source, startIndex = 0) {
    if (!tracks || !tracks.length) tracks = [];
    window.queueState.tracks = tracks;
    window.queueState.source = source;
    window.queueState.index = startIndex;
}

// ============================================
// TOGGLES
// ============================================
function toggleRepeat() {
    window.queueState.repeat = !window.queueState.repeat;
    addLog(`Repeat ${window.queueState.repeat ? 'ON' : 'OFF'}`, 'info');
}

function toggleShuffle() {
    window.queueState.shuffle = !window.queueState.shuffle;
    addLog(`Shuffle ${window.queueState.shuffle ? 'ON' : 'OFF'}`, 'info');
}

// ============================================
// NEXT / PREVIOUS TRACK RESOLUTION
// ============================================
function getNextTrackIndex() {
    const state = window.queueState;
    if (!state.tracks || !state.tracks.length) return null;

    if (state.repeat) return state.index;

    if (state.shuffle) {
        const valid = state.tracks
            .map((t, i) => ({ t, i }))
            .filter(x => (x.t.duration || 0) > 0);
        if (!valid.length) return null;
        return valid[Math.floor(Math.random() * valid.length)].i;
    }

    const next = state.index + 1;
    return next < state.tracks.length ? next : null;
}

function getPreviousTrackIndex() {
    const state = window.queueState;
    if (!state.tracks || !state.tracks.length) return null;

    const prev = state.index - 1;
    return prev >= 0 ? prev : null;
}

// ============================================
// PLAY NEXT / PREVIOUS
// ============================================
async function playNextTrack() {
    const state = window.queueState;
    if (!state.tracks || !state.tracks.length) return;

    const nextIndex = getNextTrackIndex();
    if (nextIndex === null) return;

    state.index = nextIndex;
    const track = state.tracks[nextIndex];
    if (!track) return;

    if (state.source === 'downloads') await playDownloadedTrack(nextIndex);
    else await playPlaylistTrack(nextIndex);
}

async function playPreviousTrack() {
    const state = window.queueState;
    if (!state.tracks || !state.tracks.length) return;

    const prevIndex = getPreviousTrackIndex();
    if (prevIndex === null) return;

    state.index = prevIndex;
    const track = state.tracks[prevIndex];
    if (!track) return;

    if (state.source === 'downloads') await playDownloadedTrack(prevIndex);
    else await playPlaylistTrack(prevIndex);
}

// ============================================
// PLAY PLAYLIST TRACK
// ============================================
async function playPlaylistTrack(trackIndex) {
    const tracks = window.currentPlaylistTracks || [];
    if (!tracks.length || trackIndex >= tracks.length) return;

    setQueue(tracks, 'playlist:online', trackIndex);
    const track = tracks[trackIndex];
    if (!track) return;

    // Spotify preview
    if (track.preview_url && track.preview_url !== 'None') {
        showNowPlayingPreview(track);
        playSpotifyPreview(track);
        spotifyAudio.onended = playNextTrack;
        return;
    }

    // YouTube fallback
    try {
        const ytResults = await window.pywebview.api.search_youtube_music(
            `${track.artist} ${track.title} official audio`, 1
        );
        if (!ytResults?.length) throw new Error('No YouTube result');

        const ytTrack = ytResults[0];
        const streamResult = await window.pywebview.api.get_discover_streaming_url(ytTrack.youtube_url);
        if (!streamResult?.success) throw new Error('Stream failed');

        const unifiedTrack = {
            title: track.title,
            artist: track.artist,
            album: track.album,
            thumbnail: track.thumbnail || ytTrack.thumbnail,
            youtube_url: ytTrack.youtube_url,
            duration: ytTrack.duration,
            duration_str: ytTrack.duration_str,
            source: 'Playlist (YouTube)'
        };

        showStreamControlsForDiscover(unifiedTrack, streamResult);
        setTimeout(() => document.getElementById('streamDiscoverPlayPauseBtn')?.click(), 300);
        window.onDiscoverStreamEnded = playNextTrack;

    } catch (err) {
        console.error(err);
        alert('Could not play this track');
    }
}

// ============================================
// PLAY DOWNLOADED TRACK
// ============================================
async function playDownloadedTrack(trackIndex) {
    try {
        const tracks = (await window.pywebview.api.get_downloaded_tracks()) || [];
        if (!tracks.length || trackIndex >= tracks.length) return;

        setQueue(tracks, 'downloads', trackIndex);
        const track = tracks[trackIndex];
        if (!track) return;

        const result = await window.pywebview.api.play_track(trackIndex);
        if (!result?.success) return;

        appState.currentPlayingTrack = result.track;
        appState.isPlaying = true;
        appState.isPaused = false;
        appState.playbackDuration = result.track.duration || 0;
        appState.playbackPosition = 0;

        updateNowPlayingPlayerInfo(result.track);

        if (window.audioElement) window.audioElement.onended = playNextTrack;

        addLog(` Now playing: ${result.track.artist} - ${result.track.title}`, 'success');
    } catch (error) {
        console.error(error);
        addLog(` Error playing track: ${error.message}`, 'error');
    }
}

// ============================================
// BUTTON HOOKS
// ============================================
function skipForward() { playNextTrack(); }
function skipBackward() { playPreviousTrack(); }

async function previewSpotifyTrack(index) {
    if (index < 0 || index >= discoverSearchResults.length) return;
    
    const result = discoverSearchResults[index];
    if (result.source !== 'Spotify') return;
    
    const track = result.track;
    
    console.log('Previewing Spotify track:', track);
    console.log('Preview URL:', track.preview_url);
    
    // If Spotify has a preview URL, play it
    if (track.preview_url && track.preview_url !== 'None' && track.preview_url !== null) {
        console.log('Playing Spotify preview');
        playSpotifyPreview(track);
    } else {
        // No preview available - search YouTube for this track
        console.log('No Spotify preview available, searching YouTube...');
        addLog(` No Spotify preview - Searching YouTube for: ${track.artist} - ${track.title}`, 'info');
        
// Show loading indicator
const loadingDiv = document.createElement('div');
loadingDiv.id = 'audioLoadingIndicator';
loadingDiv.className = 'active';

// Strict Black and White Design
loadingDiv.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000000;
    padding: 50px 60px;
    border-radius: 0px; /* Sharp corners */
    box-shadow: 0 20px 50px rgba(0,0,0,0.7);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 25px;
    text-align: center;
`;

// Clean design (No Emoji, No YouTube reference)
loadingDiv.innerHTML = `
    <!-- Simple White Spinner -->
    <div style="
        width: 40px; 
        height: 40px; 
        border: 3px solid rgba(255,255,255,0.2); 
        border-top: 3px solid #ffffff; 
        border-radius: 50%; 
        animation: spin 0.8s linear infinite;
    "></div>

    <!-- Main Text -->
    <div style="font-size: 16px; font-weight: 700; color: #ffffff; text-transform: uppercase; letter-spacing: 2px;">
        Loading Stream
    </div>

    <!-- Subtitle (Generic) -->
    <div style="font-size: 13px; color: rgba(255,255,255,0.5); font-weight: 400;">
        Please wait a moment
    </div>

    <!-- Embedded Animation -->
    <style>
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
    </style>
`;

document.body.appendChild(loadingDiv);
        
        try {
            // Search YouTube for this exact track
            const searchQuery = `${track.artist} ${track.title} official audio`;
            console.log('YouTube search query:', searchQuery);
            
            const youtubeResults = await window.pywebview.api.search_youtube_music(searchQuery, 3);
            
            // Remove loading indicator
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            console.log('YouTube results:', youtubeResults);
            
            if (youtubeResults && youtubeResults.length > 0) {
                // Use the first result (best match)
                const ytTrack = youtubeResults[0];
                
                // Keep Spotify metadata but use YouTube URL
                const combinedTrack = {
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    thumbnail: track.thumbnail || ytTrack.thumbnail,
                    youtube_url: ytTrack.youtube_url,
                    duration: ytTrack.duration || track.duration,
                    duration_str: ytTrack.duration_str || track.duration_str,
                    source: 'YouTube (via Spotify)'
                };
                
                console.log('Playing YouTube version:', combinedTrack);
                addLog(` Found on YouTube: ${track.artist} - ${track.title}`, 'success');
                
                await previewYouTubeTrack(combinedTrack);
            } else {
                addLog(` Could not find preview for: ${track.artist} - ${track.title}`, 'error');
                alert(`Could not find preview for:\n${track.artist} - ${track.title}\n\nTry downloading instead!`);
            }
        } catch (error) {
            // Remove loading indicator on error
            if (loadingDiv && loadingDiv.parentNode) {
                loadingDiv.remove();
            }
            
            console.error('Error finding YouTube version:', error);
            addLog(` Preview error: ${error.message}`, 'error');
            alert(`Preview error: ${error.message}\n\nTry downloading the track instead.`);
        }
    }
  }

// Stop playback
async function stopPlayback() {
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.stop_playback();
            if (result && result.success) {
                appState.isPlaying = false;
                appState.isPaused = false;
                appState.playbackPosition = 0;
                appState.currentPlayingTrack = null;
                
                if (playPauseBtn) {
                    playPauseBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"><polygon points="8 5 19 12 8 19 8 5"/></svg>';
                    playPauseBtn.title = 'Play';
                }
                updateProgressDisplay();
                
                // Update playing state visuals
                updatePlayingStateVisuals();
                
                addLog(' Playback stopped', 'info');
                
                // Re-render all views
                renderDownloadedTracks();
                renderTracks();
                if (appState.likedTracks) {
                    renderLikedTracks();
                }
            }
        }
    } catch (error) {
        console.error('Error stopping playback:', error);
    }
}

// Also update the player's play button separately
function updatePlayerPlayButton(isPlaying) {
    if (playPauseBtn) {
        if (isPlaying) {
            playPauseBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
            playPauseBtn.title = 'Pause';
        } else {
            playPauseBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"><polygon points="8 5 19 12 8 19 8 5"/></svg>';
            playPauseBtn.title = 'Play';
        }
    }
}

function updatePlayerInfo(track) {
    if (!track) return;
    
    // Update Text
    const playerTrackTitle = document.getElementById('playerTrackTitle');
    if (playerTrackTitle) playerTrackTitle.textContent = track.title;

    const playerTrackArtist = document.getElementById('playerTrackArtist');
    if (playerTrackArtist) playerTrackArtist.textContent = track.artist;
    
    // Update Time (Optional, if duration is passed)
    const totalTimeEl = document.getElementById('totalTime');
    if (totalTimeEl) totalTimeEl.textContent = formatTime(track.duration || 0);

    // --- FIX: UPDATE COVER ART IN PLAYER BAR ---
    const nowPlayingCover = document.querySelector('.now-playing-cover');
    if (nowPlayingCover) {
        if (track.thumbnail) {
            // Insert image tag
            nowPlayingCover.innerHTML = `<img src="${track.thumbnail}" alt="Album Art" style="width:100%;height:100%;object-fit:cover;">`;
        } else {
            // Fallback generic music note
            nowPlayingCover.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text-secondary);"></div>';
        }
    }
    // -----------------------------------------
}

// Show/hide player
function showPlayer() {
    const player = document.getElementById('player');
    if (player) {
        player.style.display = 'flex';
    }
}

function hidePlayer() {
    const player = document.getElementById('player');
    if (player && !appState.currentPlayingTrack) {
        player.style.display = 'none';
    }
}

// ========================================
// UPDATE PLAYING STATE VISUALS
// ========================================
function updatePlayingStateVisuals() {
    const isPlaying = appState.isPlaying || false;
    const currentTrack = appState.currentPlayingTrack;
    
    // Remove playing state from all cards
    document.querySelectorAll('.track-card').forEach(card => {
        card.classList.remove('playing');
        card.style.borderColor = '';
        card.style.boxShadow = '';
        
        const equalizer = card.querySelector('.equalizer');
        if (equalizer) {
            equalizer.classList.remove('playing');
        }
    });
    
    // If there's a current track and it's playing, highlight it
    if (currentTrack && isPlaying) {
        let trackIndex = -1;
        let source = '';
        
        // Find the track in different sources
        if (currentTrack.filepath) {
            // Downloaded track
            trackIndex = appState.downloadedTracks.findIndex(t => t.filepath === currentTrack.filepath);
            source = 'downloaded';
        } else if (currentTrack.spotify_id) {
            // Spotify track
            trackIndex = appState.tracks.findIndex(t => t.spotify_id === currentTrack.spotify_id);
            source = 'spotify';
        } else if (currentTrack.youtube_url) {
            // Discover/streaming track
            // This would need additional logic based on your state structure
        }
        
        if (trackIndex !== -1) {
            // Find the specific card
            const cardSelector = `.track-card[data-track-index="${trackIndex}"][data-source="${source}"]`;
            const card = document.querySelector(cardSelector);
            
            if (card) {
                card.classList.add('playing');
                card.style.borderColor = 'var(--accent-color)';
                card.style.boxShadow = '0 0 0 2px var(--accent-color)';
                
                const equalizer = card.querySelector('.equalizer');
                if (equalizer) {
                    equalizer.classList.add('playing');
                }
            }
        }
    }
}

// Set playback position
async function setPlaybackPosition(position) {
    try {
        if (window.pywebview && window.pywebview.api) {
            const result = await window.pywebview.api.set_position(position);
            if (result && result.success) {
                appState.playbackPosition = position;
                updateProgressDisplay();
            }
        }
    } catch (error) {
        console.error('Error setting playback position:', error);
    }
}

// Handle progress bar click
function handleProgressClick(event) {
    if (!appState.currentPlayingTrack || !progressSlider) return;
    
    const rect = progressSlider.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const percentage = clickX / rect.width;
    const newPosition = percentage * appState.playbackDuration;
    
    setPlaybackPosition(newPosition);
}

// GLOBAL volume functions that work with inline onclick
function handleVolumeBarClick(event) {
    console.log(' Volume bar clicked (inline)');
    event.stopPropagation();
    const volumeBar = document.getElementById('volumeBar');
    const rect = volumeBar.getBoundingClientRect();
    const percentage = (event.clientX - rect.left) / rect.width;
    console.log('Setting volume to:', percentage);
    setVolume(percentage);
}

function startVolumeDrag(event) {
    console.log(' Volume drag started (inline)');
    event.preventDefault();
    
    const volumeBar = document.getElementById('volumeBar');
    const rect = volumeBar.getBoundingClientRect();
    const percentage = (event.clientX - rect.left) / rect.width;
    setVolume(percentage);
    
    window.volumeDragging = true;
    
    function onMouseMove(e) {
        if (window.volumeDragging) {
            const rect = volumeBar.getBoundingClientRect();
            const percentage = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            setVolume(percentage);
        }
    }
    
    function onMouseUp() {
        console.log(' Volume drag ended (inline)');
        window.volumeDragging = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
}

function toggleMute() {
    console.log(' Mute button clicked (inline)');
    if (appState.volume > 0) {
        appState.previousVolume = appState.volume;
        setVolume(0);
    } else {
        setVolume(appState.previousVolume || 0.7);
    }
}

// Show/hide player
function showPlayer() {
    if (mediaPlayer) {
        mediaPlayer.classList.add('active');
    }
}

function hidePlayer() {
    if (mediaPlayer) {
        mediaPlayer.classList.remove('active');
    }
}

function updateVolumeIcon(percentage) {
    const volumeBtn = document.getElementById('volumeBtn');
    if (!volumeBtn) return;

    let iconSvg = '';

    // 0 = Muted
    if (percentage === 0) {
        iconSvg = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="1" y1="1" x2="23" y2="23"></line>
                <path d="M9 9v6a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path>
                <path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path>
            </svg>`;
    } 
    // Less than 50% = Low
    else if (percentage < 0.5) {
        iconSvg = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>`;
    } 
    // Higher = High
    else {
        iconSvg = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>`;
    }

    volumeBtn.innerHTML = iconSvg;
}

// Update progress display
function updateProgressDisplay() {
    if (!appState.currentPlayingTrack) {
        if (currentTime) currentTime.textContent = '0:00';
        if (totalTime) totalTime.textContent = '0:00';
        if (progressFill) progressFill.style.width = '0%';
        if (progressHandle) progressHandle.style.left = '0%';
        return;
    }
    
    const percentage = appState.playbackDuration > 0 ? 
        (appState.playbackPosition / appState.playbackDuration) * 100 : 0;
    
    if (currentTime) currentTime.textContent = formatTime(appState.playbackPosition);
    if (progressFill) progressFill.style.width = `${percentage}%`;
    if (progressHandle) progressHandle.style.left = `${percentage}%`;
}

/* ===========================
NOW PLAYING FULLSCREEN (FIXED)
=========================== */

/* Global state */
if (typeof window.npFullscreenOpen === 'undefined') {
 window.npFullscreenOpen = false;
}

/* Toggle fullscreen */
function toggleNowPlayingFullscreen() {
 window.npFullscreenOpen ? closeNowPlayingFullscreen() : openNowPlayingFullscreen();
}

function openNowPlayingFullscreen() {
    if (window.npFullscreenOpen) return;
    window.npFullscreenOpen = true;

    const root = document.getElementById('nowPlayingFullscreenRoot');
    if (!root) {
        console.error('[NP] Root container not found!');
        return;
    }

    // Get current data
    const track = appState.currentPlayingTrack;
    const title = track ? track.title : 'No track';
    const artist = track ? track.artist : '';
    const thumbnail = track ? track.thumbnail : null;
    
    const coverHTML = thumbnail 
        ? `<img src="${thumbnail}" alt="Album Art" id="npFsImg" style="width:100%;height:100%;object-fit:cover;">` 
        : '';

    root.innerHTML = `
        <section class="np-fullscreen">
            <button class="np-close-btn" onclick="closeNowPlayingFullscreen()"></button>

            <div class="np-fs-content">

                <!-- UNIQUE ID: npFsCover -->
                <div class="np-fs-cover" id="npFsCover">
                    ${coverHTML}
                </div>

                <div class="np-fs-info">
                    <!-- UNIQUE ID: npFsTitle -->
                    <div class="np-fs-title" id="npFsTitle">${title}</div>
                    <!-- UNIQUE ID: npFsArtist -->
                    <div class="np-fs-artist" id="npFsArtist">${artist}</div>
                </div>

                <div class="progress-container">
                    <span class="progress-time" id="fsCurrentTime">0:00</span>
                    <div class="progress-bar" id="fsProgressBar" onclick="handleFsProgressClick(event)">
                        <div class="progress-fill" id="fsProgressFill"></div>
                        <div class="progress-thumb" id="fsProgressThumb"></div>
                    </div>
                    <span class="progress-time" id="fsTotalTime">0:00</span>
                </div>

                <div class="np-fs-controls">
                    <button onclick="toggleShuffle()">Shuffle</button>
                    <button onclick="skipBackward()">Prev</button>
                    <button onclick="playPause()">Play / Pause</button>
                    <button onclick="skipForward()">Next</button>
                    <button onclick="toggleRepeat()">Repeat</button>
                </div>

                <div class="np-lyrics-box">
                    <span>Coming soon</span>
                </div>

            </div>
        </section>
    `;

    // Apply initial gradient
    applyCoverGradient();
    
    // Ensure progress is synced on open
    updateFullscreenProgress();
}

/* Close fullscreen */
function closeNowPlayingFullscreen() {
 console.log('[NP] Closing fullscreen');
 window.npFullscreenOpen = false;
 const root = document.getElementById('nowPlayingFullscreenRoot');
 if (root) root.innerHTML = '';
}

/* NEW: Specific Update Function for Fullscreen */
function updateFullscreenProgress() {
 // Only run if fullscreen is actually open
 if (!window.npFullscreenOpen) return;

 const position = appState.playbackPosition || 0;
 const duration = appState.playbackDuration || 0;

 // Calculate percentage
 let percentage = 0;
 if (duration > 0) {
     percentage = (position / duration) * 100;
 }

 // Update Fullscreen Elements using the UNIQUE IDs
 const fill = document.getElementById('fsProgressFill');
 const thumb = document.getElementById('fsProgressThumb');
 const timeCurrent = document.getElementById('fsCurrentTime');
 const timeTotal = document.getElementById('fsTotalTime');

 if (fill) fill.style.width = `${percentage}%`;
 if (thumb) thumb.style.left = `${percentage}%`;
 
 if (timeCurrent) timeCurrent.textContent = formatTime(position);
 if (timeTotal) timeTotal.textContent = formatTime(duration);
}

/* NEW: Specific Click Handler for Fullscreen */
function handleFsProgressClick(event) {
 if (!appState.currentPlayingTrack || !appState.playbackDuration) return;
 
 const bar = document.getElementById('fsProgressBar');
 if (!bar) return;

 const rect = bar.getBoundingClientRect();
 const clickX = event.clientX - rect.left;
 const percentage = Math.max(0, Math.min(1, clickX / rect.width));
 const newPosition = percentage * appState.playbackDuration;

 // Seek
 setPlaybackPosition(newPosition);
 
 // Update visual immediately
 updateFullscreenProgress();
}

/* Apply gradient (Unchanged from your code, just ensuring IDs match if needed) */
function applyCoverGradient() {
 const img = document.querySelector('#npFsCover img');
 if (!img) return;

 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');

 img.crossOrigin = 'anonymous';
 img.onload = () => {
     canvas.width = img.naturalWidth;
     canvas.height = img.naturalHeight;
     ctx.drawImage(img, 0, 0);

     const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

     let r = 0, g = 0, b = 0, count = 0;
     for (let i = 0; i < data.length; i += 40) {
         r += data[i];
         g += data[i + 1];
         b += data[i + 2];
         count++;
     }

     r = Math.floor(r / count);
     g = Math.floor(g / count);
     b = Math.floor(b / count);

     const fs = document.querySelector('.np-fullscreen');
     if (fs) {
         fs.style.background = `linear-gradient(180deg, rgb(${r},${g},${b}) 0%, #000 70%)`;
     }

     console.log('[NP] Gradient applied', {r,g,b});
 };

 if (img.complete) img.onload();
}

/* ============================================
   UPDATE FULLSCREEN CONTENT IN REAL-TIME
   ============================================ */

function updateFullscreenContent() {
    // 1. Check if fullscreen is actually open
    if (!window.npFullscreenOpen) return;

    // 2. Get current track data from global state
    const track = appState.currentPlayingTrack;
    if (!track) return;

    // 3. Update Title and Artist (using UNIQUE IDs)
    const titleEl = document.getElementById('npFsTitle');
    const artistEl = document.getElementById('npFsArtist');

    if (titleEl) titleEl.textContent = track.title || 'Unknown Track';
    if (artistEl) artistEl.textContent = track.artist || 'Unknown Artist';

    // 4. Update Cover Art
    const coverContainer = document.getElementById('npFsCover');
    if (coverContainer) {
        if (track.thumbnail) {
            // Inject new image
            coverContainer.innerHTML = `<img src="${track.thumbnail}" alt="Album Art" id="npFsImg" style="width:100%;height:100%;object-fit:cover;">`;
        } else {
            // Fallback
            coverContainer.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:64px;color:var(--text-muted);"></div>';
        }

        // 5. Re-calculate background gradient for new image
        setTimeout(applyCoverGradient, 100); 
    }
}

// Format time (seconds to MM:SS)
function formatTime(seconds) {
    if (!seconds || isNaN(seconds)) return '0:00';
    
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

// Log management
function addLog(message, type = 'info') {
    if (!progressLog) return;
    
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry ${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    logEntry.textContent = `[${timestamp}] ${message}`;
    
    progressLog.appendChild(logEntry);
    
    const entries = progressLog.querySelectorAll('.log-entry');
    if (entries.length > 50) {
        entries[0].remove();
    }
    
    progressLog.scrollTop = progressLog.scrollHeight;
}
    </script>
</body>
</html>
